[{"title":"自动填报学生健康日报","url":"/posts/d1ee8702/","content":"背景众所周知，每天填报学生健康日报真的是一件很麻烦的事，万一某天忘记填报了还会被班委和辅导员催。其实这个程序在《Excelで自動に体温を申告し方》之前就已经写好了，现于myetyet ブログ开源。\n源码import jsonimport randomimport requestsimport sysimport timefrom bs4 import BeautifulSoupsess = requests.session()login_url = &quot;http://ids.nuist.edu.cn/amserver/UI/Login&quot;login_data = &#123;    &quot;IDToken1&quot;: sys.argv[1],    &quot;IDToken2&quot;: sys.argv[2],    &quot;goto&quot;: &quot;&quot;,    &quot;encoded&quot;: &quot;false&quot;,    &quot;gx_charset&quot;: &quot;UTF-8&quot;&#125;sess.post(login_url, data=login_data)jkrb1_url = &quot;http://e-office2.nuist.edu.cn/infoplus/form/XNYQSB/start&quot;jkrb1_res = sess.get(jkrb1_url)soup = BeautifulSoup(jkrb1_res.text, &quot;html.parser&quot;)jkrb2_url = &quot;http://e-office2.nuist.edu.cn/infoplus/interface/start&quot;csrfToken = soup.find(&quot;meta&quot;, &#123;&quot;itemscope&quot;: &quot;csrfToken&quot;&#125;).get(&quot;content&quot;)jkrb2_data = &#123;    &quot;idc&quot;: soup.find(&quot;input&quot;, id=&quot;idc&quot;).get(&quot;value&quot;),    &quot;release&quot;: soup.find(&quot;input&quot;, id=&quot;release&quot;).get(&quot;value&quot;),    &quot;csrfToken&quot;: csrfToken,    &quot;formData&quot;: &#x27;&#123;&quot;_VAR_URL&quot;:&quot;http://e-office2.nuist.edu.cn/infoplus/form/XNYQSB/start&quot;,&quot;_VAR_URL_Attr&quot;:&quot;&#123;&#125;&quot;&#125;&#x27;&#125;jkrb2_res = sess.post(jkrb2_url, data=jkrb2_data)jkrb3_url = jkrb2_res.json()[&quot;entities&quot;][0]print(jkrb3_url)stepId = jkrb3_url.split(&quot;form/&quot;)[1].split(&quot;/&quot;)[0]jkrb4_url = &quot;http://e-office2.nuist.edu.cn/infoplus/interface/render&quot;jkrb4_data = &#123;    &quot;stepId&quot;: stepId,    &quot;instanceId&quot;: &quot;&quot;,    &quot;admin&quot;: &quot;false&quot;,    &quot;rand&quot;: str(random.random() * 1000.0),    &quot;width&quot;: &quot;955&quot;,    &quot;lang&quot;: &quot;zh&quot;,    &quot;csrfToken&quot;: csrfToken&#125;jkrb4_headers = &#123;    &quot;Referer&quot;: &quot;http://e-office2.nuist.edu.cn/infoplus/form/&#123;&#125;/render&quot;.format(stepId)&#125;jkrb4_res = sess.post(jkrb4_url, data=jkrb4_data, headers=jkrb4_headers)jkrb4_json = jkrb4_res.json()[&quot;entities&quot;][0][&quot;data&quot;]jkrb5_url = &quot;http://e-office2.nuist.edu.cn/infoplus/interface/doAction&quot;jkrb5_data_formData = &#123;    &quot;_VAR_EXECUTE_INDEP_ORGANIZE_Name&quot;: jkrb4_json[&quot;_VAR_EXECUTE_INDEP_ORGANIZE_Name&quot;],    &quot;_VAR_ACTION_INDEP_ORGANIZES_Codes&quot;: jkrb4_json[&quot;_VAR_ACTION_INDEP_ORGANIZES_Codes&quot;],    &quot;_VAR_ACTION_REALNAME&quot;: jkrb4_json[&quot;_VAR_ACTION_REALNAME&quot;],    &quot;_VAR_ACTION_ORGANIZE&quot;: jkrb4_json[&quot;_VAR_ACTION_ORGANIZE&quot;],    &quot;_VAR_EXECUTE_ORGANIZE&quot;: jkrb4_json[&quot;_VAR_EXECUTE_ORGANIZE&quot;],    &quot;_VAR_ACTION_INDEP_ORGANIZE&quot;: jkrb4_json[&quot;_VAR_ACTION_INDEP_ORGANIZE&quot;],    &quot;_VAR_ACTION_INDEP_ORGANIZE_Name&quot;: jkrb4_json[&quot;_VAR_ACTION_INDEP_ORGANIZE_Name&quot;],        &quot;_VAR_ACTION_ORGANIZE_Name&quot;: jkrb4_json[&quot;_VAR_ACTION_ORGANIZE_Name&quot;],    &quot;_VAR_EXECUTE_ORGANIZES_Names&quot;: jkrb4_json[&quot;_VAR_EXECUTE_ORGANIZES_Names&quot;],    &quot;_VAR_OWNER_ORGANIZES_Codes&quot;: jkrb4_json[&quot;_VAR_OWNER_ORGANIZES_Codes&quot;],    &quot;_VAR_ADDR&quot;: jkrb4_json[&quot;_VAR_ADDR&quot;],    &quot;_VAR_OWNER_ORGANIZES_Names&quot;: jkrb4_json[&quot;_VAR_OWNER_ORGANIZES_Names&quot;],    &quot;_VAR_URL&quot;: jkrb4_json[&quot;_VAR_URL&quot;],    &quot;_VAR_EXECUTE_ORGANIZE_Name&quot;: jkrb4_json[&quot;_VAR_EXECUTE_ORGANIZE_Name&quot;],    &quot;_VAR_RELEASE&quot;: jkrb4_json[&quot;_VAR_RELEASE&quot;],    &quot;_VAR_NOW_MONTH&quot;: jkrb4_json[&quot;_VAR_NOW_MONTH&quot;],    &quot;_VAR_ACTION_USERCODES&quot;: jkrb4_json[&quot;_VAR_ACTION_USERCODES&quot;],    &quot;_VAR_ACTION_EMAIL&quot;: jkrb4_json[&quot;_VAR_ACTION_EMAIL&quot;],    &quot;_VAR_ACTION_ACCOUNT&quot;: jkrb4_json[&quot;_VAR_ACTION_ACCOUNT&quot;],    &quot;_VAR_ACTION_INDEP_ORGANIZES_Names&quot;: jkrb4_json[&quot;_VAR_ACTION_INDEP_ORGANIZES_Names&quot;],    &quot;_VAR_OWNER_ACCOUNT&quot;: jkrb4_json[&quot;_VAR_OWNER_ACCOUNT&quot;],    &quot;_VAR_ACTION_ORGANIZES_Names&quot;: jkrb4_json[&quot;_VAR_ACTION_ORGANIZES_Names&quot;],    &quot;_VAR_STEP_CODE&quot;: jkrb4_json[&quot;_VAR_STEP_CODE&quot;],    &quot;_VAR_OWNER_USERCODES&quot;: jkrb4_json[&quot;_VAR_OWNER_USERCODES&quot;],    &quot;_VAR_EXECUTE_ORGANIZES_Codes&quot;: jkrb4_json[&quot;_VAR_EXECUTE_ORGANIZES_Codes&quot;],    &quot;_VAR_NOW_DAY&quot;: jkrb4_json[&quot;_VAR_NOW_DAY&quot;],    &quot;_VAR_OWNER_EMAIL&quot;: jkrb4_json[&quot;_VAR_OWNER_EMAIL&quot;],    &quot;_VAR_OWNER_REALNAME&quot;: jkrb4_json[&quot;_VAR_OWNER_REALNAME&quot;],    &quot;_VAR_NOW&quot;: jkrb4_json[&quot;_VAR_NOW&quot;],    &quot;_VAR_URL_Attr&quot;: jkrb4_json[&quot;_VAR_URL_Attr&quot;],    &quot;_VAR_ENTRY_NUMBER&quot;: jkrb4_json[&quot;_VAR_ENTRY_NUMBER&quot;],    &quot;_VAR_EXECUTE_INDEP_ORGANIZES_Names&quot;: jkrb4_json[&quot;_VAR_EXECUTE_INDEP_ORGANIZES_Names&quot;],    &quot;_VAR_STEP_NUMBER&quot;: jkrb4_json[&quot;_VAR_STEP_NUMBER&quot;],    &quot;_VAR_POSITIONS&quot;: jkrb4_json[&quot;_VAR_POSITIONS&quot;],    &quot;_VAR_EXECUTE_INDEP_ORGANIZES_Codes&quot;: jkrb4_json[&quot;_VAR_EXECUTE_INDEP_ORGANIZES_Codes&quot;],    &quot;_VAR_EXECUTE_POSITIONS&quot;: jkrb4_json[&quot;_VAR_EXECUTE_POSITIONS&quot;],    &quot;_VAR_ACTION_ORGANIZES_Codes&quot;: jkrb4_json[&quot;_VAR_ACTION_ORGANIZES_Codes&quot;],    &quot;_VAR_EXECUTE_INDEP_ORGANIZE&quot;: jkrb4_json[&quot;_VAR_EXECUTE_INDEP_ORGANIZE&quot;],    &quot;_VAR_NOW_YEAR&quot;: jkrb4_json[&quot;_VAR_NOW_YEAR&quot;],    &quot;groupMQJCRList&quot;: [0],    &quot;fieldFLid&quot;: jkrb4_json[&quot;fieldFLid&quot;],    &quot;fieldSQSJ&quot;: jkrb4_json[&quot;fieldSQSJ&quot;],    &quot;fieldJBXXxm&quot;: jkrb4_json[&quot;fieldJBXXxm&quot;],    &quot;fieldJBXXxm_Name&quot;: jkrb4_json[&quot;fieldJBXXxm_Name&quot;],    &quot;fieldJBXXgh&quot;: jkrb4_json[&quot;fieldJBXXgh&quot;],    &quot;fieldJBXXxb&quot;: jkrb4_json[&quot;fieldJBXXxb&quot;],    &quot;fieldJBXXxb_Name&quot;: jkrb4_json[&quot;fieldJBXXxb_Name&quot;],    &quot;fieldJBXXlxfs&quot;: jkrb4_json[&quot;fieldJBXXlxfs&quot;],    &quot;fieldJBXXdw&quot;: jkrb4_json[&quot;fieldJBXXdw&quot;],    &quot;fieldJBXXdw_Name&quot;: jkrb4_json[&quot;fieldJBXXdw_Name&quot;],    &quot;fieldJBXXnj&quot;: jkrb4_json[&quot;fieldJBXXnj&quot;],    &quot;fieldJBXXsfzh&quot;: jkrb4_json[&quot;fieldJBXXsfzh&quot;],    &quot;fieldJBXXJG&quot;: jkrb4_json[&quot;fieldJBXXJG&quot;],    &quot;fieldJBXXcsny&quot;: &quot;&quot;,    &quot;fieldJBXXfdyxm&quot;: jkrb4_json[&quot;fieldJBXXfdyxm&quot;],    &quot;fieldJBXXfdyxm_Name&quot;: jkrb4_json[&quot;fieldJBXXfdyxm_Name&quot;],    &quot;fieldJBXXfdygh&quot;: jkrb4_json[&quot;fieldJBXXfdygh&quot;],    &quot;fieldJBXXjgs&quot;: jkrb4_json[&quot;fieldJBXXjgs&quot;],    &quot;fieldJBXXjgs_Name&quot;: jkrb4_json[&quot;fieldJBXXjgs_Name&quot;],    &quot;fieldJBXXjgshi&quot;: jkrb4_json[&quot;fieldJBXXjgshi&quot;],    &quot;fieldJBXXjgshi_Name&quot;: jkrb4_json[&quot;fieldJBXXjgshi_Name&quot;],    &quot;fieldJBXXjgshi_Attr&quot;: &#x27;&#123;&quot;_parent&quot;:&quot;&#123;&#x27; + jkrb4_json[&quot;fieldJBXXjgs&quot;] + &#x27;&#125;&quot;&#125;&#x27;,    &quot;fieldJBXXjgq&quot;: jkrb4_json[&quot;fieldJBXXjgq&quot;],    &quot;fieldJBXXjgq_Name&quot;: jkrb4_json[&quot;fieldJBXXjgq_Name&quot;],    &quot;fieldJBXXjgq_Attr&quot;: &#x27;&#123;&quot;_parent&quot;:&quot;&#123;&#x27; + jkrb4_json[&quot;fieldJBXXjgshi&quot;] + &#x27;&#125;&quot;&#125;&#x27;,    &quot;fieldJBXXjgsjtdz&quot;: jkrb4_json[&quot;fieldJBXXjgsjtdz&quot;],    &quot;fieldJBXXjjlxr&quot;: jkrb4_json[&quot;fieldJBXXjjlxr&quot;],    &quot;fieldJBXXjjlxrdh&quot;: jkrb4_json[&quot;fieldJBXXjjlxrdh&quot;],    &quot;fieldSTQKsfstbs&quot;: jkrb4_json[&quot;fieldSTQKsfstbs&quot;],    &quot;fieldSTQKks&quot;: jkrb4_json[&quot;fieldSTQKks&quot;],    &quot;fieldSTQKgm&quot;: jkrb4_json[&quot;fieldSTQKgm&quot;],    &quot;fieldSTQKfs&quot;: jkrb4_json[&quot;fieldSTQKfs&quot;],    &quot;fieldSTQKfl&quot;: jkrb4_json[&quot;fieldSTQKfl&quot;],    &quot;fieldSTQKhxkn&quot;: jkrb4_json[&quot;fieldSTQKhxkn&quot;],    &quot;fieldSTQKfx&quot;: jkrb4_json[&quot;fieldSTQKfx&quot;],    &quot;fieldSTQKqt&quot;: jkrb4_json[&quot;fieldSTQKqt&quot;],    &quot;fieldSTQKqtms&quot;: jkrb4_json[&quot;fieldSTQKqtms&quot;],    &quot;fieldSTQKfrtw&quot;: str(random.randint(366, 370) / 10),    &quot;fieldSTQKqtqksm&quot;: jkrb4_json[&quot;fieldSTQKqtqksm&quot;],    &quot;fieldSTQKdqstzk&quot;: jkrb4_json[&quot;fieldSTQKdqstzk&quot;],    &quot;fieldSTQKglsjrq&quot;: &quot;&quot;,    &quot;fieldSTQKglsjsf&quot;: &quot;&quot;,    &quot;fieldSTQKfrsjrq&quot;: &quot;&quot;,    &quot;fieldSTQKfrsjsf&quot;: &quot;&quot;,    &quot;fieldCXXXcxzt&quot;: jkrb4_json[&quot;fieldCXXXcxzt&quot;],    &quot;fieldCXXXjtzz&quot;: jkrb4_json[&quot;fieldCXXXjtzz&quot;],    &quot;fieldCXXXjtzz_Name&quot;: jkrb4_json[&quot;fieldCXXXjtzz_Name&quot;],    &quot;fieldCXXXjtzzs&quot;: jkrb4_json[&quot;fieldCXXXjtzzs&quot;],    &quot;fieldCXXXjtzzs_Name&quot;: jkrb4_json[&quot;fieldCXXXjtzzs_Name&quot;],    &quot;fieldCXXXjtzzs_Attr&quot;: &#x27;&#123;&quot;_parent&quot;:&quot;&#123;&#x27; + jkrb4_json[&quot;fieldCXXXjtzz&quot;] + &#x27;&#125;&quot;&#125;&#x27;,    &quot;fieldCXXXjtzzq&quot;: jkrb4_json[&quot;fieldCXXXjtzzq&quot;],    &quot;fieldCXXXjtzzq_Name&quot;: jkrb4_json[&quot;fieldCXXXjtzzq_Name&quot;],    &quot;fieldCXXXjtzzq_Attr&quot;: &#x27;&#123;&quot;_parent&quot;:&quot;&#123;&#x27; + jkrb4_json[&quot;fieldCXXXjtzzs&quot;] + &#x27;&#125;&quot;&#125;&#x27;,    &quot;fieldCXXXjtjtzz&quot;: jkrb4_json[&quot;fieldCXXXjtjtzz&quot;],    &quot;fieldCXXXfxxq&quot;: jkrb4_json[&quot;fieldCXXXfxxq&quot;],    &quot;fieldCXXXfxxq_Name&quot;: jkrb4_json[&quot;fieldCXXXfxxq_Name&quot;],    &quot;fieldCXXXssh&quot;: jkrb4_json[&quot;fieldCXXXssh&quot;],    &quot;fieldCXXXdqszd&quot;: jkrb4_json[&quot;fieldCXXXdqszd&quot;],    &quot;fieldCXXXcqwdq&quot;: jkrb4_json[&quot;fieldCXXXcqwdq&quot;],    &quot;fieldCXXXfxcfsj&quot;: &quot;&quot;,    &quot;fieldCXXXjtfsfj&quot;: jkrb4_json[&quot;fieldCXXXjtfsfj&quot;],    &quot;fieldCXXXjtfshc&quot;: jkrb4_json[&quot;fieldCXXXjtfshc&quot;],    &quot;fieldCXXXjtfsdb&quot;: jkrb4_json[&quot;fieldCXXXjtfsdb&quot;],    &quot;fieldCXXXjtfspc&quot;: jkrb4_json[&quot;fieldCXXXjtfspc&quot;],    &quot;fieldCXXXjtfslc&quot;: jkrb4_json[&quot;fieldCXXXjtfslc&quot;],    &quot;fieldCXXXjtfsqt&quot;: jkrb4_json[&quot;fieldCXXXjtfsqt&quot;],    &quot;fieldCXXXjtfsqtms&quot;: jkrb4_json[&quot;fieldCXXXjtfsqtms&quot;],    &quot;fieldCXXXjtgjbc&quot;: jkrb4_json[&quot;fieldCXXXjtgjbc&quot;],    &quot;fieldYQJLjrsfczbl&quot;: jkrb4_json[&quot;fieldYQJLjrsfczbl&quot;],    &quot;fieldYQJLjrsfczbldqzt&quot;: jkrb4_json[&quot;fieldYQJLjrsfczbldqzt&quot;],    &quot;fieldYQJLsfjcqtbl&quot;: jkrb4_json[&quot;fieldYQJLsfjcqtbl&quot;],    &quot;fieldCXXXsftjwh&quot;: jkrb4_json[&quot;fieldCXXXsftjwh&quot;],    &quot;fieldCXXXsftjhb&quot;: jkrb4_json[&quot;fieldCXXXsftjhb&quot;],    &quot;fieldCXXXsftjhbs&quot;: jkrb4_json[&quot;fieldCXXXsftjhbs&quot;],    &quot;fieldCXXXsftjhbs_Name&quot;: jkrb4_json[&quot;fieldCXXXsftjhbs_Name&quot;],    &quot;fieldCXXXsftjhbs_Attr&quot;: &#x27;&#123;&quot;_parent&quot;:&quot;420000&quot;&#125;&#x27;,    &quot;fieldCXXXsftjhbq&quot;: jkrb4_json[&quot;fieldCXXXsftjhbq&quot;],    &quot;fieldCXXXsftjhbq_Name&quot;: jkrb4_json[&quot;fieldCXXXsftjhbq_Name&quot;],    &quot;fieldCXXXsftjhbq_Attr&quot;: &#x27;&#123;&quot;_parent&quot;:&quot;&quot;&#125;&#x27;,    &quot;fieldCXXXsftjhbjtdz&quot;: jkrb4_json[&quot;fieldCXXXsftjhbjtdz&quot;],    &quot;fieldYC&quot;: jkrb4_json[&quot;fieldYC&quot;],    &quot;fieldMQJCRxh&quot;: [1],    &quot;fieldMQJCRxm&quot;: [&quot;&quot;],    &quot;fieldMQJCRlxfs&quot;: [&quot;&quot;],    &quot;fieldMQJCRcjdd&quot;: [&quot;&quot;],    &quot;fieldCNS&quot;: True,    &quot;_VAR_ENTRY_NAME&quot;: u&quot;\\u5b66\\u751f\\u5065\\u5eb7\\u72b6\\u51b5\\u7533\\u62a5&quot;, # 学生健康状况申报    &quot;_VAR_ENTRY_TAGS&quot;: u&quot;\\u5b66\\u5de5\\u90e8&quot; # 学工部&#125;jkrb5_data = &#123;    &quot;actionId&quot;: &quot;1&quot;,    &quot;formData&quot;: json.dumps(jkrb5_data_formData),    &quot;remark&quot;: &quot;&quot;,    &quot;rand&quot;: str(random.random() * 1000.0),    &quot;nextUsers&quot;: &quot;&#123;&#125;&quot;,    &quot;stepId&quot;: str(stepId),    &quot;timestamp&quot;: str(int(time.time())),    &quot;boundFields&quot;: &quot;fieldCXXXjtgjbc,fieldMQJCRxh,fieldCXXXsftjhb,fieldSTQKqt,fieldSTQKglsjrq,\\                    fieldYQJLjrsfczbldqzt,fieldCXXXjtfsqtms,fieldCXXXjtfsfj,fieldJBXXjjlxrdh,fieldJBXXxm,\\                    fieldJBXXjgsjtdz,fieldSTQKfrtw,fieldMQJCRxm,fieldCXXXsftjhbq,fieldSTQKqtms,\\                    fieldCXXXjtfslc,fieldJBXXlxfs,fieldJBXXxb,fieldCXXXjtfspc,fieldYQJLsfjcqtbl,\\                    fieldCXXXssh,fieldJBXXgh,fieldCNS,fieldYC,fieldSTQKfl,\\                    fieldCXXXsftjwh,fieldCXXXfxxq,fieldSTQKdqstzk,fieldSTQKhxkn,fieldSTQKqtqksm,\\                    fieldFLid,fieldYQJLjrsfczbl,fieldJBXXjjlxr,fieldCXXXfxcfsj,fieldMQJCRcjdd,\\                    fieldSQSJ,fieldSTQKfrsjrq,fieldSTQKks,fieldJBXXcsny,fieldSTQKgm,\\                    fieldJBXXnj,fieldCXXXjtzzq,fieldJBXXJG,fieldCXXXdqszd,fieldCXXXjtzzs,\\                    fieldSTQKfx,fieldSTQKfs,fieldCXXXjtfsdb,fieldCXXXcxzt,fieldCXXXjtfshc,\\                    fieldCXXXjtjtzz,fieldCXXXsftjhbs,fieldJBXXsfzh,fieldSTQKsfstbs,fieldCXXXcqwdq,\\                    fieldJBXXfdygh,fieldJBXXjgshi,fieldJBXXfdyxm,fieldCXXXjtzz,fieldJBXXjgq,\\                    fieldCXXXjtfsqt,fieldJBXXjgs,fieldSTQKfrsjsf,fieldSTQKglsjsf,fieldJBXXdw,\\                    fieldCXXXsftjhbjtdz,fieldMQJCRlxfs&quot;,    &quot;csrfToken&quot;: csrfToken,    &quot;lang&quot;: &quot;zh&quot;&#125;jkrb5_res = sess.post(jkrb5_url, jkrb5_data)print(jkrb5_res.json())\n使用方法\n利用命令pip install bs4安装bs4包，若已安装可跳过。\n复制上述源码保存至任意位置，命名为jkrb.py。\n切换至源码所在文件夹，在命令行中输入python jkrb.py 学号 信息门户密码。\n若成功运行，则会输出以下类似的内容：http://e-office2.nuist.edu.cn/infoplus/form/*****/render&#123;&quot;errno&quot;: 0, &quot;ecode&quot;: &quot;SUCCEED&quot;, &quot;entities&quot;: [&#123;&quot;stepId&quot;: 2, &quot;name&quot;: &quot;提交&quot;, &quot;code&quot;: &quot;autoStep1&quot;, &quot;status&quot;: 0, &quot;type&quot;: &quot;Auto&quot;, &quot;flowStepId&quot;: 0, &quot;executorSelection&quot;: 0, &quot;timestamp&quot;: 0, &quot;posts&quot;: [], &quot;users&quot;: [], &quot;parallel&quot;: false, &quot;hasInstantNotification&quot;: false, &quot;hasCarbonCopy&quot;: false, &quot;entryId&quot;: *****, &quot;entryStatus&quot;: 0, &quot;entryRelease&quot;: false&#125;]&#125;\n\n\n注意\n源码第127行对应填报的体温，默认为36.6、36.7、36.8、36.9、37.0中随机选择一个。\n\n","categories":["形式主義を倒す"],"tags":["Python"]},{"title":"Excelで自動に体温を申告し方","url":"/posts/12e72ab6/","content":"Background学校へ戻れた後で、学院にオンラインで日に３回（朝・昼・夜）体温を申告させられる。着眼点が良いけど、正直に言って、こうする必要がなさそう。これに対して、Excelの様々な関数を用いて自動に体温を申告する。\nCode核心の関数はこちら：=IF(NOW()&gt;DATE(2020,4,21)+TIME(12,0,0),RANDBETWEEN(366,370)/10,&quot;&quot;)ご注意：この中、DATE(2020,4,21)とTIME(12,0,0)の各３つのパラメータは申告の日付と時刻という意味で、事実によって書くこと。ここは２０２０年４月２１日の昼の申告という例である。そして、体温は36.6から37までの範囲内の乱数である。\nUpdateこちらはパラメータを申告の日付と時刻によって変える必要がない関数：=IF(NOW()&gt;=INDIRECT(ADDRESS(2,INT(COLUMN()/3)*3))+IF(INDIRECT(ADDRESS(3,COLUMN()))=&quot;早&quot;,TIME(7,30,0),IF(INDIRECT(ADDRESS(3,COLUMN()))=&quot;中&quot;,TIME(12,0,0),TIME(19,30,0))),RANDBETWEEN(366,370)/10,&quot;&quot;)\nEnding他の学院によると、自分の体温が正常か否かは自覚してもいいという。さすが長望だ。形式主義はあっちこっちで流れている。\n","categories":["形式主義を倒す"],"tags":["Excel"]},{"title":"Preliminaries for Benelux Algorithm Programming Contest 2019 - F.Floor Plan","url":"/posts/3925b7ac/","content":"原题面描述You are an architect and you have just been appointed to build a new swimming hall. The organisation behind these plans has acquired funding for a swimming pool and surrounding building as large as they want, but unfortunately they could not find anyone willing to pay for the floor surrounding the pool. They decided to pay for the floor tiles out of their own pocket. Because this has already cost them an arm and a leg, they want you to use all the floor tiles in your proposed plan.Being an architect, you care for aesthetics. You see it as absolutely vital that both the swimming pool and the surrounding building are perfect squares. This raises an interesting problem: how can you make sure that the square shapes are guaranteed, while still using all the floor tiles the organisation bought?Given the number of tiles , find the length of the side of the building  and the length of the side of the pool  such that , or print impossible if no suitable  and  exist.\n输入One line containing a single integer .\n输出Print two non-negative integers ,  such that , or print impossible if no such integers exist. If there are multiple valid solutions, you may output any one of them.\n数据范围For all case,  and .\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n7\n4 3\n\n\n10\nimpossible\n\n\n15\n4 1\n\n\n\n\n链接\nhttps://nanti.jisuanke.com/t/43470\n\n题解题意给定正整数，求任意一组满足的正整数和。\n思路\n考虑。\n令，，，其中。\n枚举，求得，再判断与是否为整数即可。\n\n时间复杂度\n代码#include &lt;cstdio&gt;int n, x, y;int main() {    scanf(\"%d\", &amp;n);    for (int i = 1; i * i &lt;= n; ++i)        if (n % i == 0) {            x = i;            y = n / i;            if ((y + x) % 2 == 0 &amp;&amp; (y - x) % 2 == 0) {                printf(\"%d %d\\n\", (y + x) / 2, (y - x) / 2);                return 0;            }        }    printf(\"impossible\\n\");    return 0;}","categories":["ACM"],"tags":["C/C++","数论"]},{"title":"2017-2018 ACM-ICPC Southwestern European Regional Programming Contest - C.Macarons","url":"/posts/a0d78876/","content":"原题面描述Pierre is famous for his macarons. He makes round macarons, stored in square boxes of size , and oval-shaped macarons, stored inrectangular boxes of size  (or, rotated, in rectangular boxes of size ). For the purpose of a buffet, Pierre wishes to tile a rectangular table of size  with the two kinds of macarons, meaning that the table must be completely full, with no empty space left. The width  of the table is small, for the guest to be able to grab the macarons easily, and the length  of the table is large, to accommodate a huge number of guests. To keep the table pretty, the orientation of macarons should always be aligned with the sides of the table.Pierre wishes to know how many ways there are to tile the table. Can you help him?\n输入The input consists of the following integers:the value of , an integer, on the first line;the value of , an integer, on the second line.\n输出The output should consist of the total number of tilings, given modulo , on a single line.\n数据范围The input satisfies  and .\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n22\n7\n\n\n24\n71\n\n\n\n\n链接\nhttps://nanti.jisuanke.com/t/A1560\n\n题解题意用、和的色块填满整个个单元格组成的格网。\n思路\n下面、和的色块分别用红色、蓝色、绿色表示。\n考虑的情况，即一个两行两列的格网，左边一列称为cur，右边一列称为next。并规定一列从上至下，若一个单元格被填充（红色）则为1，否则（白色）为0。\n由于最终目的是填满整个格网，故必须保证cur全填满（并保证从上至下依次填充）的情况下再填充next。\n考虑在此情况下，还能填充的单元格。很显然只有红色单元格下面的一个的单元格可以被填充，可以填充或者的色块，如下图。\n把每列从上至下看成一个二进制数（最上对应最低位，最下对应最高位），则得到将cur从初始状态01填满为11并转移至next的00和10两种途径，转化为十进制分别对应和。\n还是的情况，再考虑全空的情况，将cur从初始状态00填满共有五种情况，如下图所示，分别转移至next的00、00、01、10和11状态，转化为十进制分别对应、、、和。\n构造数组，表示从（的二进制）所代表的cur的初始状态填满为（其二进制表示为个1）并转移至next的（的二进制）所代表的状态的所有方案数。如上图可得到、、和。\n因此可以遍历cur的所有可能的初始状态，即从到，枚举出由此初始状态可以转移至next的所有可能状态的方案数，从而构造出完整的矩阵。由于色块的最大宽度为，故在cur中填充色不会对next右边的空格网产生影响。如当时，构造出的矩阵为T=\\begin{bmatrix}2&1&1&1\\\\1&0&1&0\\\\1&1&0&0\\\\1&0&0&0\\end{bmatrix}\n设当前处于的列cur的状态为，下一列tran的状态为，再下一列next的状态为，则。当tran为第列时，假象存在next列，其状态为。\n由此可得到答案为。\n由于，需要用矩阵快速幂快速计算矩阵乘法。\n\n时间复杂度\n矩阵大小\n矩阵乘法\n快速幂\n合计\n\n代码#include &lt;cstdio&gt;int const N = 1 &lt;&lt; 8;long long const mod = 1000000000ll;int n, target;long long m, T[N][N], ans[N][N], t[N][N];void dfs(int init, int cur, int next) {    int fzp = -1; // 第一个为0的位    for (int i = 0; i &lt; n; ++i)        if (!(cur &amp; (1 &lt;&lt; i))) { // 判断cur的二进制从低至高的第i位是否为0            fzp = i;            break;        }    if (fzp == -1) {        ++T[init][next]; // 找到一种将cur从初始状态init填满并转移至next的途径        return;    }    dfs(init, cur | (1 &lt;&lt; fzp), next); // 1×1    dfs(init, cur | (1 &lt;&lt; fzp), next | (1 &lt;&lt; fzp)); // 1×2    if (fzp &lt; n - 1 &amp;&amp; !(cur &amp; (1 &lt;&lt; (fzp + 1))))        dfs(init, cur | (1 &lt;&lt; fzp) | (1 &lt;&lt; (fzp + 1)), next); // 2×1}// 矩阵乘法，A *= Bvoid times(long long a[N][N], long long b[N][N]) {    long long sum;    for (int i = 0; i &lt;= target; ++i)        for (int j = 0; j &lt;= target; ++j) {            sum = 0ll;            for (int k = 0; k &lt;= target; ++k)                sum = (sum + a[i][k] * b[k][j]) % mod;            t[i][j] = sum;        }    for (int i = 0; i &lt;= target; ++i)        for (int j = 0; j &lt;= target; ++j)            a[i][j] = t[i][j];}// 矩阵快速幂，ans = T ^ mvoid fpower(long long ans[N][N], long long T[N][N], long long m) {    for (int i = 0; i &lt;= target; ++i)        for (int j = 0; j &lt;= target; ++j)            ans[i][j] = (long long)(i == j);    while (m) {        if (m &amp; 1)            times(ans, T);        times(T, T);        m &gt;&gt;= 1;    }}int main() {    scanf(\"%d%lld\", &amp;n, &amp;m);    target = (1 &lt;&lt; n) - 1; // target = 2 ^ n - 1    for (int i = 0; i &lt;= target; ++i)        for (int j = 0; j &lt;= target; ++j)            T[i][j] = 0ll;    for (int i = 0; i &lt;= target; ++i)        dfs(i, i, 0);    // for (int i = 0; i &lt;= target; ++i) {    //     for (int j = 0; j &lt;= target; ++j)    //         printf(\"%lld \", T[i][j]);    //     printf(\"\\n\");    // }    fpower(ans, T, m);    printf(\"%lld\\n\", ans[0][0]);    return 0;}","categories":["ACM"],"tags":["C/C++","矩阵快速幂"]},{"title":"第八届“图灵杯”NEUQ-ACM程序设计竞赛个人赛（同步赛） - 部分题解","url":"/posts/10b8f9b8/","content":"B - 小宝的幸运数组原题面描述对于小宝来说，如果一个数组的总和能够整除他的幸运数字，就是他的幸运数组，而其他数组小宝都很讨厌。现在有一个长度为的数组，小宝想知道这个数组的子数组中，最长的幸运子数组有多长。对于子数组的定义，如果可以通过从开头和从结束分别删除若干个（可以为零或全部，前后删除个数不必相同）元素来从数组获得数组，则称数组是数组的子数组。（子数组包含原数组，但不包含空串）\n输入多组输入。第一行包含一个整数()，表示有组测试数据。每组测试数据包含两行，第一行包含两个整数和()，分别表示数组长度和小宝的幸运数字。第二行包含个空格分隔的整数()，为数组的元素。\n输出对于每组数据，输出和能被整除的最长子数组的长度。如果没有这样的子数组，则输出。\n时空限制\n时间限制：C/C++，其他语言\n空间限制：C/C++，其他语言\n\n样例\n\n\n输入\n输出\n\n\n\n\n43 31 2 33 51 2 33 71 2 31 65\n32-1-1\n\n\n\n\n链接https://ac.nowcoder.com/acm/contest/11746/B\n题解题意求元素之和能被整除的最长子串（子数组）的长度。\n思路\n考虑数组的前缀和，表示前个元素之和。\n若区间为的子数组元素之和能被整除，则，变形得。\n在求算前缀和的同时记录每一次前缀和对取模的运算结果第一次出现的位置，若某一取模结果出现了两次及以上，则区间为（为该取模结果第一次出现的下标，为当前求算到的下标）的子数组为“幸运数组”。\n\n时间复杂度\n代码T = int(input())for t in range(T):    n, k = [int(x) for x in input().split()]    a = [int(x) for x in input().split()]    pos = {(s := 0): 0}    ans = -1    for i in range(n):        if (s := (s + a[i]) % k) in pos:            ans = max(ans, i + 1 - pos[s])        else:            pos[s] = i + 1    print(ans)\nC - 上进的凡凡原题面描述凡凡是一个上进的人，他的人生没有下坡路，他也讨厌带有“下坡路”的东西。所以，对于凡凡来说，只有非降序的数组才是nice的（如：）；若数组元素个数为，也满足非降序，也是nice的。现在有一个长度为的数组，凡凡想知道它的子数组中有多少个数组是nice的。你能帮帮他吗？对于子数组的定义，如果可以通过从开头和从结束分别删除若干个（可以为零或全部，前后删除个数不必相同）元素来从数组获得数组，则称数组是数组的子数组。（子数组包含原数组，但不包含空串）\n输入第一行输入一个整数()，表示数组的长度。第二行包含个空格分隔的整数()，为数组的元素。\n输出输出给定数组的子数组中是nice数组的个数。（注意使用long long）\n时空限制\n时间限制：C/C++，其他语言\n空间限制：C/C++，其他语言\n\n样例\n\n\n输入\n输出\n\n\n\n\n51 2 3 4 5\n15\n\n\n\n\n链接https://ac.nowcoder.com/acm/contest/11746/C\n题解题意求一个数组中首尾下标不同的不下降子串（子数组）的个数。\n思路\n记为数组中以第个元素作为不下降子串的结尾元素时，整个数组中不下降子串的个数。\n设为某一不下降子串中从开头到当前下标的元素个数。\n若（为当前下标），则将累加；否则令。之后令。\n最后的答案为。\n\n时间复杂度\n代码n = int(input())a = [int(x) for x in input().split()]b = [k := 1]for i in range(1, len(a)):    if a[i] &lt; a[i - 1]:        b.append(k := 1)    else:        b.append(k := k + 1)print(sum(b))\nD - Seek the Joker I原题面描述长达数日的春日祭终于告一段落，作为巫女的朝野芳乃在打扫完神社本决定好好享受一下久违的宁静。然而守护了神刀数百年的丛雨难耐寂寞，希望芳乃能陪她一起玩扑克消解愁闷。芳乃并不擅长市井的游戏，所以总是输多赢少。而昨日被芳乃的神乐舞深深吸引，以致一早就前来建实神社希望能再睹芳华的你碰巧听见了此事。尽管不知道为什么美丽的巫女要自言自语地为玩扑克而苦恼，但你毅然决然地毛遂自荐，希望能为芳乃一解眉间愁。芳乃告诉了你丛雨准备了张扑克牌作为牌堆，每人每次至多从牌堆顶部抽张牌，至少抽张牌。牌堆底部的最后一张牌作为乌龟，抽中的将输掉这一轮比赛。芳乃想知道在你的帮助下，她和丛雨都采取积极策略时，她自己是否一定能获胜。作为被丛雨邀请的一方，每轮游戏都是芳乃先抽。因为看不见丛雨而误认芳乃罹患精神分裂的你在不由感叹红颜薄命的同时，决定尽全力帮助芳乃完成她的委托。声明：本题中的所有角色在剧情发生时均已超过18岁。\n输入第一行包含一个整数，表示共有组测试数据。每组测试数据共一行，包含两个正整数和，分别表示牌堆中有张牌和每次抽取最多抽取张。数据保证。\n输出对于每组测试数据给出一行结果。如果芳乃必胜，则输出“yo xi no forever!”，否则输出 “ma la se mi no.1!”。\n时空限制\n时间限制：C/C++，其他语言\n空间限制：C/C++，其他语言\n\n样例\n\n\n输入\n输出\n\n\n\n\n41 123 26 4114 514\nma la se mi no.1!yo xi no forever!ma la se mi no.1!yo xi no forever!\n\n\n\n\n链接https://ac.nowcoder.com/acm/contest/11746/D\n题解题意巴什博弈。\n思路\n若为的倍数，则后手有必胜策略：在一个回合内保证与先手拿走的牌的总数为。\n对于其余情况，后手无法保证出现只剩一张扑克牌的情况。\n\n时间复杂度\n代码T = int(input())for t in range(T):    n, k = [int(x) for x in input().split()]    if (n - 1) % (k + 1) == 0:        print(\"ma la se mi no.1!\")    else:        print(\"yo xi no forever!\")\nF - 成绩查询ing原题面描述去年的新冠疫情爆发让众多大学生只能只能在家里上学，老师为了方便自己录入成绩和方便大家成绩查询，建立了一个录入和查询成绩的系统，能完成次两种不同的查询，输入查询次数，查询次，每次首先输入查询的模式，为时，输入同学的姓名，并依次输出同学的成绩(）， 学号（}，性别（），为时，输入成绩，输出有具体有哪些同学考到了这个分数，输出同学的，并要求按字典序输出，当没有同学为此分数时，则不输出。字典序，对于字符串，先按首字符排序，如果首字符相同，再按第二个字符排序，以此类推。\n输入第一行包含一个整数，表示系统中共有个人（）。 下面行分别输入个人的姓名，成绩（成绩在之间），性别（或分别表示男性、女性），学号。表示系统中成员的信息 输入查询次数()，接下来行完成次查询任务\n输出输出次查询的结果，当为时，输入同学的姓名，并在一行中依次输出同学的成绩(）， 学号（}，性别（），用空格间隔（注意行末无空格），为时，输入成绩，输出有具体有哪些同学考到了这个分数，输出同学的（每个输出一行，无空格），并要求按字典序输出，当没有同学为此分数时，则不输出。\n时空限制\n时间限制：C/C++，其他语言\n空间限制：C/C++，其他语言\n\n样例\n\n\n输入\n输出\n\n\n\n\n5N 28 2 7475UN 83 2 27550EXF 5 2 17298OVYNH 51 2 14827XNV 53 1 759121XNV227\n53 7591 1\n\n\n\n\n链接https://ac.nowcoder.com/acm/contest/11746/F\n题解题意用名字查询该学生的信息；或用成绩查询获得该成绩的所有学生的姓名。\n思路\n采用支持哈希的容器按姓名存储信息。\n对于按成绩查询，可以先将所有姓名按字典序排序，再按成绩存储信息。\n\n时间复杂度\n代码from collections import defaultdictn = int(input())hmc = list()for i in range(n):    xm, cj, xb, xh = input().split()    hmc.append((xm, cj, xh, xb))hmc.sort(key=lambda x: x[0])q = [{xm: y for xm, *y in hmc}, defaultdict(list)]for xm, cj, *_ in hmc:    q[1][cj].append(xm)m = int(input())for i in range(m):    t = int(input()) - 1    s = input()    if s in q[t]:        print((\" \", \"\\n\")[t].join(q[t][s]))\nH - 数羊原题面描述憨憨小杨晚上睡不着觉，就开始数羊，她觉得一只一只数太慢了，突发奇想出了一种新的数羊方式，羊羊数量由两个整形变量和决定，计算方式如下:\n\\begin{cases}A\\left(1,0\\right)=2&\\\\A\\left(0,m\\right)=1&m\\geq0\\\\A\\left(n,0\\right)=n+2&n\\geq2\\\\A\\left(n,m\\right)=A\\left(A\\left(n,m-1\\right),m-1\\right)&n,m\\geq1\\end{cases}现在给出和的值，请你帮小杨数数一共有多少只羊。\n输入多组输入。第一行包含一个整数()，表示有组测试数据。每组测试数据包含一行，包含两个整数()和().\n输出对每一组输入，在一行中输出的值,由于输出的结果可能会很大，答案对取模\n时空限制\n时间限制：C/C++，其他语言\n空间限制：C/C++，其他语言\n\n样例\n\n\n输入\n输出\n\n\n\n\n33 03 13 2\n568\n\n\n\n\n链接https://ac.nowcoder.com/acm/contest/11746/H\n题解题意计算函数。\n思路\n由于较大，直接递归计算不可取。\n观察到范围中的，又因为为整数，故只会取三个值。\n引理：最终会化归为（）或（）的形式。\n推论：由引理可知的结果是一个正整数。\n若，则。\n若，则。\n若，则左边最终会化归为的形式，故，即。故。\n若，则且，故为一个首项为、公差为的等差数列。故通项为（）。\n综上所述，（）。\n\n\n若，则（），故为一个首项为、公比为的等比数列。故通项为（）。\n综上所述，。\n\n时间复杂度\n代码def fpower(a: int, b: int) -&gt; int:    ans = 1    while b:        if b &amp; 1:            ans = ans * a % 998244353        a = a * a % 998244353        b &gt;&gt;= 1    return ansT = int(input())for t in range(T):    n, m = [int(x) for x in input().split()]    if m == 0:        print(2 if n == 1 else n + 2)    elif m == 1:        print(2 * n)    else:        print(fpower(2, n))\nI - 买花原题面描述情人节马上要到了，阳阳想送出朵花给喜欢的妹妹，他打算提前开始买。但是，因为他有强迫症，所有的花要分天买（，即不能一天全买完）,第一天他可以买任意朵花，之后每一天买花的数量为前一天的两倍，（如若第一天买朵，第二天就要买朵，以此类推）。现在离情人节还有天（），请你告诉阳阳，他能不能刚好买到朵花。\n输入多组输入。第一行一个正整数（)，表示数据组数。接下来T行，每行一个正整数（)，表示预计买花的数量。\n输出每组数据输出一行，共行。判断能否刚好买到朵花，可以则输出”YE5“，否则输出”N0“。\n时空限制\n时间限制：C/C++，其他语言\n空间限制：C/C++，其他语言\n\n样例\n\n\n输入\n输出\n\n\n\n\n22120\nYE5N0\n\n\n\n\n链接https://ac.nowcoder.com/acm/contest/11746/I\n题解题意构造数列满足（）。求是否，使得。\n思路\n设，则通项为，前项之和为。\n原问题可以转化为是否存在一个使得。\n由于只会取得之间的整数，故可以预处理出所有后依次判断是否能被整除。\n注意输出。\n\n时间复杂度\n代码F = [(1 &lt;&lt; i) - 1 for i in range(2, 16)]for t in range(int(input())):    n = int(input())    for f in F:        if n % f == 0:            print(\"YE5\")            break    else:        print(\"N0\")\nJ - 这是一题简单的模拟原题面描述财务计划要从家里出发，去个城市出差，然后再回到家中，但个出差地点之间不一定都能通车，现在他要筛选出花费最少的路径，你能帮帮他吗？\n输入第一行为两个正整数和（，），分别表示有个出差地点和这些地点之间的条通路，其中出差地点用到编号，而财务的家所在城市用编号表示。随后的行，每行给出通路连接的两个城市和这条通路上的花费，格式为：```城市A 城市B 花费```通路是双向的，且两个城市间最多有一条通路，不存在自环。保证所有花费大于。再下一行给出一个正整数（），表示现在有K条推荐路径（注意：给出的路径不一定能通过或可能不满足财务的要求）。接下来行每一行表示一个推荐路径，第一个整数表示途径的城市数，后面有()个整数()(表示途经的城市（不包括财务的家），如：3 1 2 3表示实际路径为。\n输出请你检验给出的条推荐路径，当它满足：\n\n给出的路径能实际通车，即路径中相邻城市存在通路；\n给出的路径恰好能都到达个出差城市一次，即不能漏掉某个城市，也不能重复到达。\n\n则称这条路径是可行的。对于给出的条推荐路径，请输出其中可行路径中最少的花费，若不存在可行路径，请输出”-1“。(题目保证花费和不超过int范围）\n时空限制\n时间限制：C/C++，其他语言\n空间限制：C/C++，其他语言\n\n样例\n\n\n输入\n输出\n\n\n\n\n5 100 1 50 5 121 2 22 3 83 4 131 3 110 2 50 4 94 5 63 5 755 1 3 2 3 15 3 2 1 4 55 2 1 \n3 5 46 1 2 3 4 5 15 1 2 3 5 4\n37\n\n\n\n\n链接https://ac.nowcoder.com/acm/contest/11746/J\n题解题意在一张给定的无向图上，判断给定的一条路线是否可以从起点既不重复、又不遗漏地经过全部个点再回到起点。\n思路\n由于较小，可以使用邻接矩阵存图。\n直接按照给定的路线模拟遍历即可。\n用set（集合）可以达到不重复、不遗漏的需求。\n\n时间复杂度\n代码n, m = [int(x) for x in input().split()]dis = [[0] * (n + 1) for i in range(n + 1)]for i in range(m):    u, v, cap = [int(x) for x in input().split()]    dis[u][v] = dis[v][u] = capk = int(input())ans = 0x7ffffffffor i in range(k):    _, *a = [int(x) for x in input().split()]    a.append(0)    vis = set()    cur = 0    s = 0    for x in a:        if dis[cur][x] &gt; 0 and x not in vis:            s += dis[cur][x]            vis.add(x)            cur = x        else:            break    else:        if len(vis) == n + 1:            ans = min(ans, s)print(-1 if ans == 0x7fffffff else ans)\n题外话\n这题是2020年团体程序设计天梯赛进阶级第四题《网红点打卡攻略》的原题，只是换了个背景，最终要求算的内容比原题要简单一些。\n题目数据存在问题：不考虑重复到达也可以AC。\n\nK - 黑洞密码原题面描述近些日子，某科学家接受到了来自外太空的神秘讯息，在经过了一段时间的研究后，科学家发现讯息是一个由字母和数字组成的字符串str，想要破译，需要通过一定的规则将字符串进行转换。规则如下：\n\n确定讯息的长度为；\n字符串中第的字母和第()的数字为一组，共组；\n每组的第个字符分别往后推每组第个数字个数 例：如第一个字母为a，第一个数字为，转换后变为d，’z‘之后是’B‘,’Z‘之后是’b‘;\n将每组内部字母的顺序颠倒；\n将四组字符合并就是最后的讯息。\n\n输入输入一个长度为的字符串\n输出输出转换后的密码\n时空限制\n时间限制：C/C++，其他语言\n空间限制：C/C++，其他语言\n\n样例\n\n\n输入\n输出\n\n\n\n\nZzc6Ltw2OD4yR640263W7G8G30HW9C71\nRgCgJQwxJfYCDeQG\n\n\n\n\n链接https://ac.nowcoder.com/acm/contest/11746/K\n题解题意\n将字符串中所有字母、数字按原字符串顺序分成两排。\n字母和数字分别按顺序取四位为一组，各分为四组。\n取第一组字母和第一组数字，第一个字母向后移动第一个数字位，第二个字母向后移动第二个数字位，……，以此类推，然后将得到的四个新字母颠倒顺序。\n取第二组字母和第二组数字，重复上一步中的流程。\n第三、四组字母和数组按上述流程重复。\n将得到的四组新字母依次首尾拼接，得到答案并输出。\n\n思路按照题意模拟即可，但需要一些花时间来理解出题人的谜语。\n时间复杂度\n代码def trans(c: str, k: int) -&gt; str:    y = (x := ord(c)) + k    if x &lt;= 90 and y &gt; 90:        y += 7    elif x &lt;= 122 and y &gt; 122:        y -= 57    return chr(y)s = input()ds = list()ls = list()for c in s:    if 48 &lt;= ord(c) &lt;= 57:        ds.append(int(c))    else:        ls.append(c)ans = \"\"for i in range(0, 16, 4):    ans += trans(ls[i + 3], ds[i + 3])\\         + trans(ls[i + 2], ds[i + 2])\\         + trans(ls[i + 1], ds[i + 1])\\         + trans(ls[i], ds[i])print(ans)\nL - 建立火车站原题面描述新冠疫情，导致了各个城市之间物资输送的障碍。假设有个城市在一条直线上，为了物资能顺利抵达各个城市，可以在路线上建立最多个数为个暂时停靠站，由于火车在两个站台（城市也算站台）之间的距离越近，需要的总花费越少，因此我们需要让火车相邻两个站台之间的最大距离最小，求出距离,, ，所有城市坐标小于等于，且不存在负值。提醒： 城市坐标均为正整数，且停靠站只能建在整数坐标点上。\n输入第一行输入城市个数，可建立停靠站个数，第二行输入个城市的坐标（不保证前一个城市坐标比后一个城市小）。\n输出输出\n时空限制\n时间限制：C/C++，其他语言\n空间限制：C/C++，其他语言\n\n样例\n\n\n输入\n输出\n\n\n\n\n2 24 106\n34\n\n\n\n\n链接https://ac.nowcoder.com/acm/contest/11746/L\n题解题意数轴的正半轴上有一部分整数点已知，现需要在正半轴上添加一些整数点，使得相邻两点之间的最大距离最小。\n思路\n若已知相邻两点之间的最大距离为，则对于以任意两相邻已知点为左右端点的区间内，都可以计算出在保证在当前这一区间内添加若干个点后的相邻两点间的最大距离为的前提下，添加最少的点的数量。\n即，在当前这一区间内距离左端点处添加点。\n若从左往右遍历所有由相邻已知点构成的区间后添加的点的数量不超过给定的，则表示这个最大距离是可能的答案之一，并且最优答案不会超过。\n故，该问题满足答案单调性，可以使用二分答案求解。\n\n时间复杂度\n代码n, k = [int(x) for x in input().split()]pos = sorted(int(x) for x in input().split())l = 1ans = r = 1000000000000def check(itv: int) -&gt; bool:    cnt = 0    for i in range(1, n):        dis = pos[i] - pos[i - 1]        cnt += dis // itv - (0 if dis % itv &gt; 0 else 1)    return cnt &lt;= kwhile l &lt;= r:    if check((mid := l + r &gt;&gt; 1)):        r = (ans := mid) - 1    else:        l = mid + 1print(ans)","categories":["ACM"],"tags":["Python"]},{"title":"2017-2018 ACM-ICPC Pacific Northwest Regional Contest - 部分水题题解","url":"/posts/1fa445b6/","content":"A - Odd Palindrome原题面描述We say that a string is odd if and only if all palindromic substrings of the string have odd length.Given a string s, determine if it is odd or not.A substring of a string s is a nonempty sequence of consecutive characters from s. A palindromic substring is a substring that reads the same forwards and backwards.\n输入The input consists of a single line containing the string s ().It is guaranteed that s consists of lowercase ASCII letters (‘a’–‘z’) only.\n输出If s is odd, then print “Odd.” on a single line (without quotation marks). Otherwise, print “Or not.” on a single line (without quotation marks).\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\namanaplanacanalpanama\nOdd.\n\n\nmadamimadam\nOdd.\n\n\nannamyfriend\nOr not.\n\n\nnopalindromes\nOdd.\n\n\n\n\n题解题意给定字符串s，判断s中所有回文子串长度是否都为奇数。\n思路暴力枚举s的所有子串，并判断其是否为回文字符串以及其长度是否为奇数。\n时间复杂度\n代码def palindromic(s: str) -&gt; bool:    l = len(s)    for i in range(l):        if s[i] != s[l - i - 1]:            return False    return Truedef check(s: str) -&gt; bool:    for i in range(len(s) - 1):        # [0, len(s) - 2]        for j in range(i + 1, len(s)): # [i + 1, len(s) - 1]            if palindromic(s[i : j + 1]) and (j - i + 1) % 2 == 0:                return False    return Truewhile True:    s = input()    if s == \"\":        break    print(\"Odd.\" if check(s) else \"Or not.\")\nE. Straight Shot原题面描述You have a toy robot that walks straight at a constant speed , and you wish for it to travel on the two-dimensional plane from  to . If the plane were empty, you could start the robot facing straight east from the origin, and it would walk there in  time. Unfortunately, between the start and the destination are n moving sidewalks, each moving directly north or south, which affect the robot’s position while it is walking.The direction that robot is facing is not changed by the sidewalks; the robot will face in the same orientation for the entire duration of its walk. These sidewalks are aligned with the -axis and are infinitely long. You still must get the robot to go from start to finish, but you’ll need to adjust the orientation of the robot at the start. Given that you choose this direction correctly, so that the robot arrives exactly at the destination, how long will it take the robot to get there?One final caveat: You don’t want the toy robot to walk for too long. If the robot cannot reach the destination in at most twice the time it would take in the absence of all moving sidewalks (i.e., ), indicate this.\n输入The first line consists of three space-separated numbers , , and  (; ; ). Note that  is not necessarily an integer.Each of the next  lines contains three space-separated numbers , , and  (; ), describing the th moving sidewalk. The integer  denotes the left edge of the sidewalk, the integer  denotes the right edge of the sidewalk, and the decimal number  denotes the speed of the sidewalk. A positive speed means the sidewalk moves north, while a negative speed means the sidewalk moves south.\n输出If the robot cannot reach the destination in at most twice the time it would take in the absence of all moving sidewalks, output “Too hard” on a single line (without quotation marks).Otherwise, output, on a single line, the travel time of the robot from the start to the destination, rounded and displayed to exactly three decimal places.\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n1 806873 6691411 631975 -57.5\n15055.988\n\n\n2 422193 10038180 307590 86.4366035 403677 -4.7\n5043.896\n\n\n1 670764 22.4113447 642610 -64.8\nToo hard\n\n\n\n\n题解题意\n求一质点从恰好运动到的时间。\n在起点处可设定其速度的方位角（从轴正方向起顺时针转过的角度，其中），之后不可再改变该角度。\n在质点向运动的过程中，若质点当前坐标满足，则会叠加上平行于轴的速度矢量（以轴正方向为的正方向）。\n质点全程分段做匀速直线运动。\n\n思路\n将初速度正交分解到平行于坐标轴方向，以坐标轴的正方向为分速度的正方向，分别为方向上的速度与方向上的速度。\n当质点位于传送带（sidewalk）上时，方向上的速度改变为。\n由于要求恰好运动到，则需要保证方向上的位移为。\n质点位于第个传送带上时，通过该传送带（横坐标不在该传送带区间内）的时间只与方向上的速度有关，为。\n在上述的时间内方向上的位移为。\n该部分位移累计。\n令、，则。\n注意到常数实际表示所有传送带的总长度，故不在传送带上的总长度为，通过时间为。\n在上述的时间内方向上的位移为。\n故方向上的总位移为。\n令，由于，则，。\n若，则可计算时间。\n\n时间复杂度\n代码from math import sqrtn, x, vr = [float(_) for _ in input().split()]n = int(n)C = 0.0for i in range(n):    l, r, vs = [float(_) for _ in input().split()]    C += (r - l) * vs / vrtry:    sin = 1.0 if n == 0 else sqrt(1.0 - C ** 2 / x ** 2)    t = x / (vr * sin)    print(\"Too hard\" if vr * t &gt; 2.0 * x else \"%.3lf\" % t)except:    print(\"Too hard\")\nL - Delayed Work原题面描述You own a company that hires painters to paint houses. You can hire as many painters as you want, but for every painter you hire, you have to pay  dollars (independent of how long the painter works on the house). In addition, you have to pay a penalty of  dollars overall if it takes  days to finish painting the house. This penalty does not depend on the number of painters you hire; furthermore, even if the time taken is not a whole number of days, you are only penalized for the exact time taken.All painters paint at the same rate. One painter can finish painting the house in  days. The painters cooperate so well that it will only take  days for  painters to finish painting the house.What is the minimum amount of money you will have to pay, including what you pay to the painters and the cost penalty, to get a house painted?\n输入The input consists of a single line containing three space-separated integers , , and  ().\n输出Print, on a single line, the minimum cost to have the house painted, rounded and displayed to exactly three decimal places.\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n31 41 59\n549.200\n\n\n3 4 5\n16.000\n\n\n\n\n题解题意雇个工人花费天完成一个总量为的工程，其中。整个工期内需要支付每个工人费用；另外，工期结束后还需支付 费用。求最小花费。\n思路\n目标函数为，其中为正整数。\n根据基本不等式，得（当且仅当，即时取等号）。\n最小花费则为与f\\left(\\left\\lfloor\\dfrac{KP}X\\right\\rfloor+1\\right)中的较小者。\n\n时间复杂度\n代码from math import sqrtk, p, x = [int(x) for x in input().split()]m = int(sqrt(k * p / x))f = lambda m: m * x + p * k / mprint(\"%.3lf\" % min(f(m), f(m + 1)))\nO - Halfway原题面描述A friend of yours has written a program that compares every pair of a list of items. With n items, it works as follows. First, it prints a 1, and it compares item  to items . It then prints a 2, and compares item  to items . It continues like that until every pair of items has been compared exactly once. If it compares item  to item , it will not later compare item  to item . Also, it does not compare any item to itself.Your friend wants to know when his program is halfway done. For a program that makes an odd number of total comparisons, this is when it is doing the middle comparison. For a program that makes an even number of total comparisons, this is when it is doing the first of the two middle comparisons.What will the last number printed be when the program is halfway done?Note that since the earlier items have more comparisons than the later items, the answer is notsimply .\n输入The input consists of a single line containing the integer  ().\n输出Print, on a single line, the last number your friend’s program prints when it is halfway done.\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n4\n1\n\n\n\n\n题解题意输出下列C++程序的最后一个输出的值。\n#include &lt;cstdio&gt;long long n;void work() {    long long cnt = 0;    long long tot = n * (n - 1) / 2;    long long half = (tot + 1) / 2;    for (int i = 1; i &lt; n; ++i) {        printf(\"%d\\n\", i);        for (int j = i + 1; j &lt;= n; ++j) {            ++cnt;            if (cnt == half)                return;        }    }}int main() {    scanf(\"%lld\", &amp;n);    work();    return 0;}\n思路\n比较总次数；中间次比较次数。\n当外层循环执行第次时，内层循环最多会将cnt的值加上。\n问题可转化为求满足的最小正整数。\n变形得。\n二次函数的对称轴为直线，故答案在区间上单调递减。因此可以使用二分答案法进行求解。\n由于当取，即外层循环执行到第次时，内层循环并不会改变cnt的值，因此答案不会为。\n\n时间复杂度\n代码n = int(input())C = (n * (n - 1) // 2 + 1) // 2l, r = 1, n - 1ans = 1f = lambda x: x ** 2 - (2 * n - 1) * x + 2 * Cwhile l &lt;= r:    mid = l + r &gt;&gt; 1    if f(mid) &lt;= 0:        ans = mid        r = mid - 1    else:        l = mid + 1print(ans)\nQ - Unloaded Die原题面描述Consider a six-sided die, with sides labeled  through . We say the die is fair if each of its sides is equally likely to be face up after a roll. We say the die is loaded if it isn’t fair. For example, if the side marked  is twice as likely to come up as than any other side, we are dealing with a loadeddie.For any die, define the expected result of rolling the die to be equal to the average of the values of the sides, weighted by the probability of those sides coming up. For example, all six sides of a fair die are equally likely to come up, and thus the expected result of rolling it is .You are given a loaded die, and you would like to unload it to make it more closely resemble a fair die. To do so, you can erase the number on one of the sides, and replace it with a new number which does not need to be an integer or even positive. You want to do so in such a way that\n\nThe expected result of rolling the die is , just like a fair die.\nThe difference between the old label and the new label on the side you change is as small as possible.\n\n输入The input consists of a single line containing six space-separated nonnegative real numbers  , where  represents the probability that side  (currently labeled by the number ) is rolled.It is guaranteed that the given numbers will sum to .\n输出Print, on a single line, the absolute value of the difference between the new label and old label, rounded and displayed to exactly three decimal places.\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n0.16666 0.16667 0.16667 0.16666 0.16667 0.16667\n0.000\n\n\n0.2 0.2 0.1 0.2 0.2 0.1\n1.000\n\n\n\n\n题解题意给出一个六面骰子（点数为至）每个面朝上的概率，修改至多一个面的点数，使期望为，求最小的修改差值。\n思路\n未修改前的期望为。\n设被修改的面原点数为，修改后点数为。\n修改后的期望为。\n修改差值为。\n为使差值最小，取最大的即可。\n\n时间复杂度\n代码v = [float(x) for x in input().split()]e = 0.0for i in range(6):    e += (i + 1) * v[i]v.sort()print(\"%.3lf\" % (abs(e - 3.5) / max(v)))\nR - Star Arrangements原题面描述The recent vote in Puerto Rico favoring United States statehood has made flag makers very excited. An updated flag with  stars rather than the current one with  would cause a huge jump in U.S. flag sales. The current pattern for  stars is five rows of  stars, interlaced with four offset rows of  stars. The rows alternate until all stars are represented.* * * * * * * * * * ** * * * * * * * * * ** * * * * * * * * * ** * * * * * * * * * ** * * * * *This pattern has the property that adjacent rows differ by no more than one star. We represent this star arrangement compactly by the number of stars in the first two rows: 6,5.A -star flag that has the same property can have three rows of  stars, interlaced with three rows of  stars (with a compact representation of 9,8). Conversely, if a state were to leave the union, one appealing representation would be seven rows of seven stars (7,7).A flag pattern is visually appealing if it satisfies the following conditions:\n\nEvery other row has the same number of stars.\nAdjacent rows differ by no more than one star.\nThe first row cannot have fewer stars than the second row.\n\nYour team sees beyond the short-term change to  for the U.S. flag. You want to corner the market on flags for any union of three or more states. Given the number  of stars to draw on a flag, find all possible visually appealing flag patterns.\n输入The input consists of a single line containing the integer  ().\n输出On the first line, print , followed by a colon. Then, for each visually appealing flag of  stars, print its compact representation, one per line.This list of compact representations should be printed in increasing order of the number of stars in the first row; if there are ties, print them in order of the number of stars in the second row. The cases -by- and -by- are trivial, so do not print those arrangements.The compact representations must be printed in the form “x,y”, with exactly one comma between x and y and no other characters.\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n3\n3:2,1\n\n\n50\n50:2,12,23,25,45,56,510,1013,1217,1625,25\n\n\n51\n51:2,13,39,817,1726,25\n\n\n\n\n题解题意将总共个星号按一行个、一行个的格式交叉排列，其中。求所有排列情况。\n思路\n分以下三种情况讨论：\n一行个、一行个为一组，总共组。\n一行个、一行个为一组，总共组，最后多出一行个。\n一行个为一组，总共组。\n注意且。\n\n时间复杂度\n代码s = int(input())print(\"{}:\".format(s))for i in range(2, (s + 1) // 2 + 1):    if s % (2 * i - 1) == 0 or (s - i) % (2 * i - 1) == 0:        print(\"{},{}\".format(i, i - 1))    if s % i == 0:        print(\"{},{}\".format(i, i))\nS - Forbidden Zero原题面描述You’re writing the positive integers in increasing order starting from one. But you’ve never learned the digit zero, and thus omit any number that contains a zero in any position. The first ten integers you write are:  and .You have just written down the integer  (which is guaranteed to not contain the digit zero). What will be the next integer that you write down?\n输入The input consists of a single line containing the integer  (n$ does not contain the digit zero.\n输出Print, on a single line, the next integer you will be writing down.\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n99\n111\n\n\n1234\n1235\n\n\n\n\n题解题意求大于的不包含数字的最小正整数。\n思路枚举大于的正整数，判断是否包含数字即可。\n时间复杂度\n代码def hasZero(x: int) -&gt; bool:    while x:        if x % 10 == 0:            return True        x //= 10    return Falsen = int(input())n += 1while hasZero(n):    n += 1print(n)","categories":["ACM"],"tags":["Python"]},{"title":"pybind11学习笔记","url":"/posts/dc90fd13/","content":"介绍pybind11是一个轻量级的仅含头文件的C++库，用简单的语法为Python创建拓展模块，以加速运行。官方介绍可参考官方文档。\n安装Windows端\n环境配置\nWindows 10 家庭版 64位\nPython 3.8.0 [MSC v.1916 32 bit (Intel)] on win32\ngcc (MinGW.org GCC-8.2.0-3) 8.2.0\ng++ (MinGW.org GCC-8.2.0-3) 8.2.0\npybind11 v2.6.2\n\n\n从官方仓库的发布页下载pybind11的源码。\n解压下载的压缩包，将其中的include文件夹单独放置。Linux端\n在Baidu AI Studio上注册帐户并登录。\n点击上方菜单栏中的[项目]，点击[创建项目]。\n选择类型：选择[Notebook]类型，点击[下一步]。\n配置环境：项目框架选择[PaddlePaddle 2.0.0]，项目环境选择[python 3.7]，点击[下一步]。\n项目环境：三个项目均可随意设置，点击[创建]。\n启动环境：选择[基础版 (免费使用)]，点击[确定]。\n待提示“环境启动成功”后点击[进入]，进入环境。\n点击菜单栏下方的[终端-1]，切换至终端选项卡，并依次执行以下命令：mkdir pybindcd pybindgit clone https://github.com.cnpmjs.org/pybind/pybind11.git\n\n\n编写测试程序Windows端\n在include文件夹下创建myetyet.cpp文件，编写如下内容后保存。#include &lt;pybind11/pybind11.h&gt;namespace py = pybind11;int add(int i, int j) &#123;    return i + j;&#125;PYBIND11_MODULE(myetyet, m) &#123;    m.doc() = &quot;myetyet&#x27;s pybind11 test module&quot;;    m.def(&quot;add&quot;, &amp;add, &quot;A function which adds two integers.&quot;);&#125;\n重复上述过程，创建setup.py文件，编写如下内容后保存。from setuptools import setup, Extensionsetup(ext_modules=[Extension(name=&quot;myetyet&quot;, sources=[&quot;myetyet.cpp&quot;], include_dirs=[&quot;.&quot;])])\n在终端依次执行以下命令：python setup.py build_ext -c mingw32 --inplacedir | find &quot;pyd&quot;\n若终端给出形如myetyet.cp38-win32.pyd的信息，即代表测试程序编译完成。\n继续在终端依次执行python命令。\n在Python交互式终端中依次执行以下语句：import osos.add_dll_directory(&quot;C:\\\\MinGW\\\\bin&quot;)import myetyetmyetyet.add(233, 666)\n注意，此处的C:\\\\MinGW\\\\bin应为pyd文件依赖的动态链接库的所在目录，一般为MinGW安装目录的bin文件夹。\n若终端先后给出&lt;AddedDllDirectory(&#39;C:\\\\MinGW\\\\bin&#39;)&gt;和899的信息，即代表测试程序可以正确运行。\n在Python交互式终端中输入exit()退出。\n\nLinux端\n点击左侧侧边栏上方第四个按钮[刷新]。\n随后将在侧边栏中刷新出刚创建的pybind文件夹，点击之进入。\n点击上方第一个按钮[新建文件]，名称为myetyet.cpp，点击[确定]。\n点击侧边栏中的myetyet.cpp，在右侧代码编辑区中输入以下代码后保存。#include &lt;pybind11/pybind11.h&gt;namespace py = pybind11;int add(int i, int j) &#123;    return i + j;&#125;PYBIND11_MODULE(myetyet, m) &#123;    m.doc() = &quot;myetyet&#x27;s pybind11 test module&quot;;    m.def(&quot;add&quot;, &amp;add, &quot;A function which adds two integers.&quot;);&#125;\n重复上述过程，创建CMakeLists.txt文件，输入以下代码后保存。cmake_minimum_required(VERSION 3.4)project(myetyet LANGUAGES CXX)set(CMAKE_CXX_STANDARD 14)add_subdirectory(pybind11)pybind11_add_module(myetyet myetyet.cpp)\n在终端依次执行以下命令：mkdir buildcd buildcmake ..makels | grep so\n若终端给出形如myetyet.cpython-37m-x86_64-linux-gnu.so的信息，即代表测试程序编译完成。\n继续在终端依次执行python命令。\n在Python交互式终端中依次执行以下语句：import myetyetmyetyet.add(233, 666)\n若终端给出899的信息，即代表测试程序可以正确运行。\n在Python交互式终端中输入exit()退出。\n方便起见，在pybind文件夹下创建build.sh。在终端依次执行以下命令：cd ~/pybindecho -e &quot;if [ ! -d \\&quot;./build\\&quot; ]; then\\n  mkdir build\\nfi&quot; &gt; build.shecho -e &quot;cd build\\ncmake ..\\nmake\\ncp *.so ../&quot; &gt;&gt; build.sh\n之后对myetyet.cpp进行修改后则可在pybind文件夹下执行sh build.sh命令进行自动编译并复制.so文件至该目录。\n执行python命令进入Python交互式终端后，则可直接使用import myetyet进行模块的导入。\n\npybind11语法\n基础\n引用头文件及命名空间\nC++侧#include &lt;pybind/pybind11&gt;namespace py = pybind11;\n\n\n创建模块\nC++侧PYBIND11_MODULE(module_name, m) &#123; ... &#125;\n备注\n严格意义上该条语法并不是函数定义，而是宏定义。\n\n\n参数\nmodule_name：模块名（切勿加引号）\nm：主要接口（py::module_型变量）\n\n\n\n\n属性\nC++侧// Normal types of variables exportingm.attr(&quot;a_bool&quot;) = true;m.attr(&quot;a_char&quot;) = &#x27;A&#x27;;m.attr(&quot;a_float&quot;) = 6.66;m.attr(&quot;an_int&quot;) = 233;m.attr(&quot;a_string&quot;) = py::cast(&quot;myetyet&quot;);// Include in advance#include &lt;pybind11/stl.h&gt;#include &lt;vector&gt;// STL container variables exportingm.attr(&quot;a_vector&quot;) = py::cast(std::vector&lt;int&gt; &#123;233, 666&#125;);\nPython侧from myetyet import *a_bool, type(a_bool) # Output: (True, &lt;class &#x27;bool&#x27;&gt;)a_char, type(a_char) # Output: (&#x27;A&#x27;, &lt;class &#x27;str&#x27;&gt;)a_float, type(a_float) # Output: (6.66, &lt;class &#x27;float&#x27;&gt;)an_int, type(an_int) # Output: (233, &lt;class &#x27;int&#x27;&gt;)a_string, type(a_string) # Output: (&#x27;myetyet&#x27;, &lt;class &#x27;str&#x27;&gt;)a_vector, type(a_vector) # Output: ([233, 666], &lt;class &#x27;list&#x27;&gt;)\n\n\n枚举类型\nC++侧// Structure wrapper and inner enumerations definitionstruct Enums &#123;    enum DialogResult &#123; Cancel = 2, OK = 0, Abort, Retry = 4 &#125;;&#125;;// Structure wrapper exportingpy::class_&lt;Enums&gt; pyEnums(m, &quot;Enums&quot;);// Enumerations exportingpy::enum_&lt;Enums::DialogResult&gt;(pyEnums, &quot;DialogResult&quot;)    .value(&quot;Cancel&quot;, Enums::DialogResult::Cancel)    .value(&quot;OK&quot;, Enums::DialogResult::OK)    .value(&quot;Abort&quot;, Enums::DialogResult::Abort)    .value(&quot;Retry&quot;, Enums::DialogResult::Retry)    .export_values();\nPython侧from myetyet import *Enums.DlgRes.OK # Output: &lt;DlgRes.OK: 0&gt;str(Enums.DlgRes.Abort) # Output: &#x27;DlgRes.Abort&#x27;int(Enums.DlgRes.Cancel) # Output: 2from pprint import pprintpprint(Enums.DlgRes.__members__) # Output as follows:&quot;&quot;&quot;&#123;&#x27;Abort&#x27;: &lt;DlgRes.Abort: 1&gt;, &#x27;Cancel&#x27;: &lt;DlgRes.Cancel: 2&gt;, &#x27;OK&#x27;: &lt;DlgRes.OK: 0&gt;, &#x27;Retry&#x27;: &lt;DlgRes.Retry: 4&gt;&#125;&quot;&quot;&quot;\n\n\n\n\n函数\n简单函数\nC++侧// Function definitionint add(int i, int j) &#123;    return i + j;&#125;// Function exporting with referencing a defined functionm.def(&quot;add&quot;, &amp;add, &quot;A function which adds two integers.&quot;);// Function exporting with a lambda functionm.def(&quot;mod&quot;, [](int i, int j) &#123; return i % j; &#125;, &quot;C++ mod function&quot;);\nPython侧help(myetyet.mod) # Output as follows:&quot;&quot;&quot;Help on built-in function mod in module myetyet:mod(...) method of builtins.PyCapsule instance    mod(arg0: int, arg1: int) -&gt; int        C++ mod function&quot;&quot;&quot;myetyet.add(666, 233) # Output: 899myetyet.mod(666, 233) # Output: 200\n\n\n关键字参数\nC++侧// Function definitionint _xor(int x, int y) &#123;    return x ^ y;&#125;// Regular notationm.def(&quot;xor&quot;, &amp;_xor, py::arg(&quot;x&quot;), py::arg(&quot;y&quot;));// Shorthandusing namespace pybind11::literals;m.def(&quot;xor_&quot;, &amp;_xor, &quot;x&quot;_a, &quot;y&quot;_a);\nPython侧help(myetyet.div) # Output as follows:&quot;&quot;&quot;Help on built-in function xor in module myetyet:xor(...) method of builtins.PyCapsule instance    xor(x: int, y: int) -&gt; int&quot;&quot;&quot;myetyet.xor(x=666, y=233) # Output: 627myetyet.xor(y=233, x=666) # Output: 627help(myetyet.xor) # Output as follows:&quot;&quot;&quot;Help on built-in function xor_ in module myetyet:xor_(...) method of builtins.PyCapsule instance    xor_(x: int, y: int) -&gt; int&quot;&quot;&quot;myetyet.xor_(666, y=233) # Output: 627\n\n\n参数默认值\nC++侧// Regular notationm.def(&quot;xor&quot;, &amp;_xor, py::arg(&quot;x&quot;) = 666, py::arg(&quot;y&quot;) = 233);// Shorthandusing namespace py::literals;m.def(&quot;xor_&quot;, &amp;_xor, &quot;x&quot;_a = 666, &quot;y&quot;_a = 233);\nPython侧help(myetyet.xor) # Output as follows:&quot;&quot;&quot;Help on built-in function xor in module myetyet:xor(...) method of builtins.PyCapsule instance    xor(x: int = 666, y: int = 233) -&gt; int&quot;&quot;&quot;myetyet.xor(y=666) # Output: 0myetyet.xor(233) # Output: 0help(myetyet.xor_) # Output as follows:&quot;&quot;&quot;Help on built-in function xor_ in module myetyet:xor_(...) method of builtins.PyCapsule instance    xor_(x: int = 666, y: int = 233) -&gt; int&quot;&quot;&quot;myetyet.xor_() # Output: 627\n\n\n重载\nC++侧// Function definitiondouble add(double x, double y) &#123; return x + y; &#125;string add(string x, string y) &#123; return x + y; &#125;// Function exporting with a lambda functionm.def(&quot;add&quot;, [](int x, int y)&#123; return x + y; &#125;, &quot;x&quot;_a, &quot;y&quot;_a);// Function exporting with referencing a defined function// C++ 11 stylem.def(&quot;add&quot;, static_cast&lt;double (*)(double, double)&gt;(&amp;add), &quot;x&quot;_a, &quot;y&quot;_a);// C++ 14 stylem.def(&quot;add&quot;, py::overload_cast&lt;string, string&gt;(&amp;add), &quot;x&quot;_a, &quot;y&quot;_a);\nPython侧help(myetyet.add) # Output as follows:&quot;&quot;&quot;Help on built-in function add in module myetyet:add(...) method of builtins.PyCapsule instance    add(*args, **kwargs)    Overloaded function.        1. add(x: float, y: float) -&gt; float        2. add(x: str, y: str) -&gt; str        3. add(x: int, y: int) -&gt; int&quot;&quot;&quot;myetyet.add(2.33, 6.66) # Output: 8.99myetyet.add(233, 666) # Output: 899myetyet.add(&quot;myet&quot;, &quot;yet&quot;) # Output: &#x27;myetyet&#x27;\n\n\n\n\n自定义类\n构造函数与简单函数\nC++侧// Include in advance#include &lt;string&gt;using namespace std;// Structure definitionstruct Person &#123;    string name;    Person(const string &amp;name) : name(name) &#123; &#125;    const string &amp;getName() const &#123; return name; &#125;    void setName(const string &amp;name) &#123; this-&gt;name = name; &#125;&#125;;// Structure exportingpy::class_&lt;Person&gt;(m, &quot;Person&quot;)    .def(py::init&lt;const string &amp;&gt;(), &quot;Initialize&quot;, &quot;name&quot;_a = &quot;&quot;)    // Function exporting with referencing a defined function    .def(&quot;getName&quot;, &amp;Person::getName, &quot;Get name&quot;)    .def(&quot;setName&quot;, &amp;Person::setName, &quot;Set name&quot;, &quot;name&quot;_a);    // Function exporting with a lambda function    .def(&quot;__repr__&quot;, [](const Person &amp;p) &#123; return &quot;&lt;a Person named &#x27;&quot; + p.name + &quot;&#x27;&gt;&quot;; &#125;);\nPython侧p = myetyet.Person(&quot;123&quot;); p # Output: &lt;a Person named &#x27;123&#x27;&gt;p.setName(&quot;myetyet&quot;); p.getName() # Output: &#x27;myetyet&#x27;\n\n\n属性\nC++侧// Structure definitionstruct Person &#123;    string name;    const string ID = &quot;233666&quot;;    Person(const string &amp;name) : name(name) &#123; &#125;    const string &amp;getName() const &#123; return name; &#125;    void setName(const string &amp;name) &#123; this-&gt;name = name; &#125;    const string &amp;getID() const &#123; return ID; &#125;&#125;;// Structure exportingpy::class_&lt;Person&gt;(m, &quot;Person&quot;)    // Read/Write property    .def_readwrite(&quot;name&quot;, &amp;Person::name)    // Or apply following 1 choice when a property is not public    // .def_property(&quot;name&quot;, &amp;Person::getName, &amp;Person::setName)    // Readonly property    .def_readonly(&quot;ID&quot;, &amp;Person::ID)    // Or apply following 2 choices when a property is not public    // .def_property(&quot;ID&quot;, &amp;Person::getID, nullptr)    // .def_property_readonly(&quot;ID&quot;, &amp;Person::getID)    .def(py::init&lt;const string &amp;&gt;(), &quot;Initialize&quot;, &quot;name&quot;_a = &quot;&quot;);\nPython侧p = myetyet.Person(&quot;myetyet&quot;)p.name, p.ID # Output: (&#x27;myetyet&#x27;, &#x27;233666&#x27;)p.name = &quot;myetyet_&quot;; p.name # Output: &#x27;myetyet_&#x27;p.ID = &quot;666666&quot; # Output as follows:&quot;&quot;&quot;Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: can&#x27;t set attribute&quot;&quot;&quot;\n\n\n动态属性\nC++侧// Class definitionclass Person &#123;public:    Person(const string &amp;name) : name(name) &#123; &#125;    const string &amp;getName() const &#123; return name; &#125;    void setName(const string &amp;name) &#123; this-&gt;name = name; &#125;private:    string name;    const string ID = &quot;233666&quot;;&#125;;// Class exportingpy::class_&lt;Person&gt;(m, &quot;Person&quot;, py::dynamic_attr())    .def_readwrite(&quot;name&quot;, &amp;Person::name)    .def(py::init&lt;const string &amp;&gt;(), &quot;Initialize&quot;, &quot;name&quot;_a = &quot;&quot;);\nPython侧p = myetyet.Person(&quot;myetyet&quot;)p.ID = 233666; p.url = &quot;https://myetyet.js.org/&quot;p.__dict__ # Output: &#123;&#x27;ID&#x27;: 233666, &#x27;url&#x27;: &#x27;https://myetyet.js.org/&#x27;&#125;\n\n\n继承\nC++侧// Structure definitionstruct Person &#123;    string name;    Person(const string &amp;name) : name(name) &#123; &#125;&#125;;struct Student : Person &#123;    Student(const string &amp;name): Person&#123;name&#125; &#123; &#125;    string loaf() &#123; return &quot;mo yu&quot;; &#125;&#125;;// Structure exportingpy::class_&lt;Person&gt;(m, &quot;Person&quot;)    .def_readwrite(&quot;name&quot;, &amp;Person::name)    .def(py::init&lt;const string &amp;&gt;(), &quot;Initialize Person&quot;, &quot;name&quot;_a = &quot;&quot;);py::class_&lt;Student, Person&gt;(m, &quot;Student&quot;)    .def(&quot;loaf&quot;, &amp;Student::loaf)    .def(py::init&lt;const string &amp;&gt;(), &quot;Initialize Student&quot;, &quot;name&quot;_a = &quot;&quot;);\nPython侧p = Student(&quot;myetyet&quot;)p.name, p.loaf() # Output: (&#x27;myetyet&#x27;, &#x27;mo yu&#x27;)\n\n\n函数重载\nC++侧// Structure definitionstruct Vector2 &#123;    double x, y;    Vector2() : x(0.0), y(0.0) &#123;&#125;    Vector2(double x, double y) : x(x), y(y) &#123;&#125;    void set(char lbl, double val) &#123; switch (lbl) &#123; case &#x27;x&#x27;: x = val; break; case &#x27;y&#x27;: y = val; break; &#125; &#125;    void set(double x, double y) &#123; this-&gt;x = x; this-&gt;y = y; &#125;&#125;;// Structure exportingpy::class_&lt;Vector2&gt;(m, &quot;Vector2&quot;)    // Constructor overloading    .def(py::init&lt;&gt;())    .def(py::init&lt;double, double&gt;(), &quot;x&quot;_a, &quot;y&quot;_a)    // Member function overloading    // C++ 11 style    .def(&quot;set&quot;, static_cast&lt;void (Vector2::*)(double, double)&gt;(&amp;Vector2::set), &quot;x&quot;_a, &quot;y&quot;_a)    // C++ 14 style    .def(&quot;set&quot;, py::overload_cast&lt;char, double&gt;(&amp;Vector2::set), &quot;label&quot;_a, &quot;value&quot;_a)    // Class display info    .def(&quot;__repr__&quot;, [](const Vector2 &amp;v) &#123; return &quot;&lt;2D Vector (&quot; + to_string(v.x) + &quot;, &quot; + to_string(v.y) + &quot;)&gt;&quot;; &#125;);\nPython侧help(myetyet.Vector2.__init__) # Output as follows:&quot;&quot;&quot;Help on instancemethod in module myetyet:__init__(...)    __init__(*args, **kwargs)    Overloaded function.        1. __init__(self: myetyet.Vector2) -&gt; None        2. __init__(self: myetyet.Vector2, x: float, y: float) -&gt; None&quot;&quot;&quot;v = myetyet.Vector2(); v # Output: &lt;2D Vector (0.000000, 0.000000)&gt;v = myetyet.Vector2(.1, .2); v # Output: &lt;2D Vector (0.100000, 0.200000)&gt;help(myetyet.Vector2.set) # Output as follows:&quot;&quot;&quot;Help on instancemethod in module myetyet:set(...)    set(*args, **kwargs)    Overloaded function.        1. set(self: myetyet.Vector2, x: float, y: float) -&gt; None        2. set(self: myetyet.Vector2, label: str, value: float) -&gt; None&quot;&quot;&quot;v.set(6.66, 2.33); v # Output: &lt;2D Vector (6.660000, 2.330000)&gt;v.set(&quot;x&quot;, 6.1234575); v # Output: &lt;2D Vector (6.123457, 2.330000)&gt;v.set(&quot;y&quot;, 6.1234585); v # Output: &lt;2D Vector (6.123457, 6.123458)&gt;\n\n\n重载运算符\nC++侧// Structure definitionstruct Vector2 &#123;    double x, y;    Vector2(double x, double y) : x(x), y(y) &#123;&#125;    Vector2 operator-() const &#123; return Vector2(-x, -y); &#125;    Vector2 operator*(double k) const &#123; return Vector2(k * x, k * y); &#125;    Vector2 &amp;operator*=(double k) &#123; x *= k; y *= k; return *this; &#125;    double operator*(const Vector2 &amp;b) const &#123; return x * b.x + y * b.y; &#125;    friend Vector2 operator*(double k, const Vector2 &amp;v) &#123; return Vector2(k * v.x, k * v.y); &#125;&#125;;// Structure exportingpy::class_&lt;Vector2&gt;(m, &quot;Vector2&quot;)    .def(py::init&lt;double, double&gt;(), &quot;x&quot;_a, &quot;y&quot;_a)    .def(-py::self)    .def(py::self * double())    .def(py::self *= double())    .def(py::self * py::self)    .def(double() * py::self)    .def(&quot;__add__&quot;, [](const Vector2 &amp;a, const Vector2 &amp;b) &#123; return Vector2(a.x + b.x, a.y + b.y); &#125;, py::is_operator())    .def(&quot;__repr__&quot;, [](const Vector2 &amp;v) &#123; return &quot;&lt;2D Vector (&quot; + to_string(v.x) + &quot;, &quot; + to_string(v.y) + &quot;)&gt;&quot;; &#125;);\nPython侧a = myetyet.Vector2(3, 4)-a # Output: &lt;2D Vector (-3.000000, -4.000000)&gt;a * 2 # Output: &lt;2D Vector (6.000000, 8.000000)&gt;a *= -2.0; a # Output: &lt;2D Vector (-6.000000, -8.000000)&gt;b = myetyet.Vector2(1, 2)a * b # Output: -22.0-.3 * a # Output: &lt;2D Vector (1.800000, 2.400000)&gt;a + b # Output: &lt;2D Vector (-5.000000, -6.000000)&gt;2 * a + b * 3 # Output: &lt;2D Vector (-9.000000, -10.000000)&gt;\n\n\n\n\n\n","tags":["Python","C/C++"]},{"title":"2018-2019 ACM-ICPC Pacific Northwest Regional Contest - 部分水题题解","url":"/posts/cb8f4655/","content":"A - Exam原题面描述Your friend and you took a true/false exam of  questions. You know your answers, your friend’s answers, and that your friend got  questions correct.Compute the maximum number of questions you could have gotten correctly.\n输入The first line of input contains a single integer .The second line contains a string of  () characters, the answers you wrote down. Each letter is either a ‘T’ or an ‘F’.The third line contains a string of n characters, the answers your friend wrote down. Each letter is either a ‘T’ or an ‘F’.The input will satisfy .\n输出Print, on one line, the maximum number of questions you could have gotten correctly.\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n3FTFFFTFTTT\n2\n\n\n6TTFTFFTFTFTTTTFFTTTT \n9\n\n\n\n\n题解题意已知自己的和朋友的判断题每题所选的答案，以及朋友的答案中正确的个数（具体是哪些题未知），求自己最多可能答对了多少道判断题。\n思路\n首先需要保证自己与朋友答案一致的题目（数量记为）为朋友所答对的，因为若有一题朋友答对了而自己的答案与之相反，则自己一定答错了。\n若，则需要保证自己与朋友答案一致的其中有题答对，不一致的题目全为自己对。此时问题答案为。\n若，则需要保证自己与朋友答案一致的两者全答对，不一致的题目中有道题朋友答对了（即朋友没答对的题全为自己答对了）。此时答案为。\n故最终答案为。\n\n时间复杂度\n代码k, a, b = int(input()), input(), input()n = len(a)s = sum([int(a[i] == b[i]) for i in range(n)])print(n - abs(k - s))\nC - Contest Setting原题面描述A group of contest writers have written  problems and want to use  of them in an upcoming contest. Each problem has a difficulty level. A contest is valid if all of its  problems have different difficulty levels.Compute how many distinct valid contests the contest writers can produce. Two contests are distinct if and only if there exists some problem present in one contest but not present in the other.Print the result modulo .\n输入The first line of input contains two space-separated integers  and  ().The next line contains n space-separated integers representing the difficulty levels. The difficulty levels are between  and  (inclusive).\n输出Print the number of distinct contests possible, modulo .\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n5 21 2 3 4 5\n10\n\n\n5 21 1 1 2 2\n6\n\n\n12 53 1 4 1 5 9 2 6 5 3 5 8\n316\n\n\n\n\n题解题意有道不同的题目，每个题目有一个难度值，组织一场比赛需要从这道题目中选出道难度值互不相同的题目，求方案数。\n思路\n将题目的难度值离散化，因为只需要考虑一共有多少种不同的难度值。设第种难度值对应有个题目。\n考虑动态规划。定义表示前种难度值中挑选出种难度值互不相同的题的方案数。\n对于每一种难度值的题，有选一道或不选两种情况。\n若从该种难度值的题目中选出一道，则需要保证前种难度中恰好选了种互不相同的难度值，故。\n若不选该种难度值的题目，则需要保证前前种难度中恰好已经选了种互不相同的难度值，故。\n故转移方程为Missing \\left or extra \\rightf\\left(i,j\\right)=\\max\\left\\\\{c_i\\cdot f\\left(i-1,j-1\\right),f\\left(i-1,j\\right)\\right\\\\}。\n\n时间复杂度\n代码from collections import CounterMOD = 998244353n, k = [int(_) for _ in input().split()]counter = Counter([int(_) for _ in input().split()])n = len(counter)dp = [[1] + [0] * k for _ in range(n + 1)]for _i, cnt in enumerate(counter):    i = _i + 1    for j in range(1, k + 1):        dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1] * counter[cnt]) % MODprint(dp[n][k])\nH - Repeating Goldbachs原题面描述The Goldbach Conjecture states that any even number  can be expressed as the sum of two primes. It can be verified that the conjecture is true for all .Define a Goldbach step as taking  (), finding primes  and  (with ) that sum to , and replacing  with . If there are multiple pairs of primes which sum to , we take the pair with the largest difference. That difference must be even and less than . Therefore, we can repeat more Goldbach steps, until we can reach a number less than .Given , find how many Goldbach steps it takes until reaching a number less than .\n输入The input will consist of a single integer  ().\n输出Print, on a single line, the number of Goldbach steps it takes to reach a number less than .\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n20\n3\n\n\n30\n4\n\n\n40\n5\n\n\n50\n6\n\n\n60\n7\n\n\n70\n8\n\n\n\n\n题解题意给定正整数，每次寻找两个差值最大的质数和，满足且，然后将替换为。重复该步骤直至。输出执行的次数。\n思路\n根据题意模拟该过程即可。\n注意要将以内的质数预处理出来。\n\n时间复杂度整个过程理论上是，但由于每次都很小，寻找和的开销并不大。\n代码#include &lt;cstdio&gt;int x, primes[1000006], primecnt = 0, cnt = 0, p, q;bool vis[1000006] = {false};int main() {    freopen(\"a.txt\", \"w\", stdout);    scanf(\"%d\", &amp;x);    for (int i = 2; i &lt;= x; ++i) {        if (!vis[i])            primes[++primecnt] = i;        for (int j = 1; i * primes[j] &lt;= x; ++j) {            vis[i * primes[j]] = true;            if (i % primes[j] == 0)                break;        }    }    vis[1] = true; // 1 is not a prime    while (x &gt;= 4) {        for (int i = 1; i &lt;= primecnt; ++i)            if (!vis[x - primes[i]]) {                p = primes[i];                q = x - primes[i];                break;            }        printf(\"%d\\n\", p);        x = q - p;        ++cnt;    }    printf(\"%d\\n\", cnt);    return 0;}\nI - Greedy Scheduler原题面描述A store has  cashiers numbered sequentially from  to , with  customers in a queue. A customer at the front of the queue is constantly assigned to the first unoccupied cashier, i.e., cashier with the smallest number. The th customer’s shopping cart takes  seconds to process.Find which cashier will process each customer’s shopping cart.\n输入The first line of input contains two space-separated integers  and  (). The second line of input contains  space-separated integers , representing the length of time required to handle that customer.\n输出Output a single line containing  space-separated integers, each with the cashier number that handles that customer.\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n3 10406 424 87 888 871 915 516 81 275 578\n1 2 3 3 1 2 3 1 2 1\n\n\n\n\n题解题意个顾客需要按顺序在个收银员处结账，每个顾客结账需要时间，求为每个顾客结账的收银员编号。\n思路\n维护每个收银员的下一个空闲的时间点。\n对于每个顾客，寻找编号最小的空闲收银员。\n可以利用优先队列加速寻找最小编号收银员的速度。\n\n时间复杂度\n代码from queue import PriorityQueuen, c = [int(_) for _ in input().split()]t = [int(_) for _ in input().split()]q = PriorityQueue()for i in range(n):    q.put((0, i + 1))opt = list()for time in t:    ava = q.get()    opt.append(str(ava[1]))    q.put((ava[0] + time, ava[1]))print(\" \".join(opt))\nJ - House Numbers原题面描述Peter was walking down the street, and noticed that the street had houses numbered sequentially from  to . While standing at a particular house , he also noticed that the sum of the house numbers behind him (numbered from  to ) equaled the sum of the house numbers in front of him (numbered from  to ).Given , and assuming there are at least three houses total, find the lowest  such that this is possible.\n输入Input consists of a single line containing the integer  ().\n输出On a single line, print , , and , in order, separated by spaces.It is guaranteed that there will be a solution with  less than or equal to .\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n1\n1 6 8\n\n\n11\n11 49 68\n\n\n999999\n999999 1317141 1571535\n\n\n999000\n999000 1000000 1000999\n\n\n\n\n题解题意给定正整数，求满足的最小正整数解，同时需要保证，使得。\n思路\n将求和符号展开，得。\n展开，整理，得。\n变形，得。将右边记为。\n从小到大遍历，当上述方程中有正整数解时即为问题答案。\n若需要保证精度，可采用二分答案法求的解，避免浮点数运算。此时时间复杂度为，也可接受。\n\n时间复杂度\n代码#include &lt;cstdio&gt;#include &lt;cmath&gt;long long m, x, n, C;int main() {    scanf(\"%lld\", &amp;m);    n = m + 1;    while (true) {        ++n;        C = m * m - m + n * n + n;        if (C &amp; 1)            continue;        C &gt;&gt;= 1;        x = (long long)sqrt((double)C);        if (x * x == C)            break;    }    printf(\"%lld %lld %lld\\n\", m, x, n);    return 0;}\nM - Liars原题面描述There are n people in a circle, numbered from  to , each of whom always tells the truth or always lies.Each person  makes a claim of the form: “the number of truth-tellers in this circle is between  and  , inclusive.”Compute the maximum number of people who could be telling the truth.\n输入The first line contains a single integer  (). Each of the next  lines contains two space-separated integers  and  ().\n输出Print, on a single line, the maximum number of people who could be telling the truth. If the given set of statements is inconsistent, print -1 instead.\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n31 12 32 2\n2\n\n\n80 11 74 83 71 24 53 71 8\n-1\n\n\n\n\n题解题意个人中一部分永远说真话，剩下一部分永远说假话。给出每个人对永远说真话的人数区间的描述，计算最多可能的说真话的人数。\n思路\n由于输入的较小，因此可以直接枚举最多可能的说真话的人数。\n对于每个可能的人数，检查每个人的描述，可以得出某个人是否说了真话，统计个数，与枚举的人数比较即可。\n\n时间复杂度\n代码n = int(input())claims = list()for i in range(n):    claims.append([int(_) for _ in input().split()])ans = -1for i in range(1, n + 1):    cnt = 0    for claim in claims:        if claim[0] &lt;= i &lt;= claim[1]:            cnt += 1    if cnt == i:        ans = iprint(ans)\nO - Pizza Deal原题面描述There’s a pizza store which serves pizza in two sizes: either a pizza slice, with area  and price P 1 , or a circular pizza, with radius  and price .You want to maximize the amount of pizza you get per dollar. Should you pick the pizza slice or the whole pizza?\n输入The first line contains two space-separated integers  and .Similarly, the second line contains two space-separated integers  and .It is guaranteed that all values are positive integers at most . We furthermore guarantee that the two will not be worth the same amount of pizza per dollar.\n输出If the better deal is the whole pizza, print ‘Whole pizza’ on a single line.If it is a slice of pizza, print ‘Slice of pizza’ on a single line.\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n8 47 9\nWhole pizza\n\n\n9 24 7\nWhole pizza\n\n\n841 1088 606\nSlice of pizza\n\n\n\n\n题解题意比较扇形披萨和圆形披萨的单位价格的披萨面积。\n思路直接计算即可。\n时间复杂度\n代码import matha1, p1 = [int(_) for _ in input().split()]r, p2 = [int(_) for _ in input().split()]a2 = math.pi * r ** 2if a1 / p1 &gt; a2 / p2:    print(\"Slice of pizza\")else:    print(\"Whole pizza\")\nQ - Poker Hand原题面描述You’re given a five-card hand drawn from a standard -card deck. Each card has a rank (one of ), and a suit (one of ).The strength of your hand is defined as the maximum value  such that there are  cards in your hand that have the same rank.Find the strength of your hand.\n输入The input consists of a single line, with five two-character strings separated by spaces.The first character in each string will be the rank of the card, and will be one of A23456789TJQK. The second character in the string will be the suit of the card, and will be one of CDHS.It is guaranteed that all five strings are distinct.\n输出Output, on a single line, the strength of your hand.\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\nAC AD AH AS KD\n4\n\n\n2C 4D 4H 2D 2H\n3\n\n\nAH 2H 3H 4H 5H\n1\n\n\n\n\n题解题意统计五张扑克牌中点数相同的最大张数。\n思路直接统计即可。\n时间复杂度\n代码from collections import Countercounter = Counter([card[0] for card in input().split()])print(counter.most_common(1)[0][1])\nR - Random Index Vectors原题面描述A Random Index Vector (RIV) is a data structure that can represent very large arrays where most elements are zero. Here, we consider a version of RIVs which can contain only , , and  as elements. There are three basic operations on RIVs:\n\nAddition of two RIVs  and ; the resulting RIV  is defined by . The values are clamped at , i.e., we define  and .\nMultiplication of two RIVs  and ; the resulting RIV  is defined by .\nRotation of an RIV  by some integer ; this shifts all of the values in  to the left by  indices. The first  values at the start of  go to the end of the array and become the rightmost values.\n\nAn RIV is written in its condensed form. This representation is a list that starts with the number of nonzero values, followed by a sorted list of indices (-indexed) that have nonzero values, where the indices are negated if the values there are .For example, consider an RIV representing an array . There are  nonzero elements at indices , ,  and , and the values at  and  are , so the condensed form of this RIV is .Given two RIVs in condensed form, add them, multiply them, and rotate them both. Output the results in condensed form.\n输入The first line of input contains two space-separated integers  and  (), where  is the full (uncondensed) length of the RIVs and  is the number of indices to rotate by.Each of the next two lines contains a condensed form of an RIV, starting with an integer  (), followed by  space-separated indices . Each index  is a nonzero integer between  and  (inclusive).\n输出Output four vectors, one per line, in condensed form:\n\nSum of the two input RIVs.\nProduct of the two input RIVs.\nFirst RIV rotated by .\nSecond RIV rotated by .\n\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n30 136 6 -9 -13 18 22 268 -1 3 7 11 13 19 20 -27\n12 -1 3 6 7 -9 11 18 19 20 22 26 -271 -136 5 9 13 23 -26 -308 6 7 -14 -18 20 24 28 30\n\n\n20 49 -2 -4 -8 -11 -12 15 18 19 207 4 5 -10 \n11 15 18 -20\n8 -2 5 -8 -10 -12 15 18 195 -4 -11 15 18 -209 -4 -7 -8 11 14 15 16 -18 -207 1 -6 7 11 14 -16 20\n\n\n\n\n题解题意计算两个RIV的和、积，以及两者分别位移位后的结果。\n思路\n和：筛选出所有非零位相加后保留所有非零位。\n积：筛选出所有非零位相乘后保留所有非零位。\n位移：所有非零位下标减，若小于则再加。\n\n时间复杂度\n代码from collections import defaultdictdef resD_show(resD):    if isinstance(resD, dict):        res = sorted([(1 if resD[x] &gt; 0 else -1) * x for x in resD if resD[x] != 0], key=abs)    else:        res = sorted(resD, key=abs)    print(len(res), end=\"\")    for x in res:        print(\"\", x, end=\"\")    print()def Operate(op):    A = defaultdict(int)    B = defaultdict(int)    pos = set()    for x in a:        A[abs(x)] = 1 if x &gt; 0 else -1        pos.add(abs(x))    for x in b:        B[abs(x)] = 1 if x &gt; 0 else -1        pos.add(abs(x))    resD = dict()    for p in pos:        resD[p] = op(A[p], B[p])    resD_show(resD)def Shift(lst):    for i in range(len(lst)):        sig = 1 if lst[i] &gt; 0 else -1        lst[i] = abs(lst[i]) - k        if lst[i] &lt;= 0:            lst[i] += n        lst[i] *= sig    resD_show(lst)n, k = [int(_) for _ in input().split()]na, *a = [int(_) for _ in input().split()]nb, *b = [int(_) for _ in input().split()]Operate(lambda x, y: 1 if x + y == 2 else -1 if x + y == -2 else x + y)Operate(lambda x, y: x * y)Shift(a)Shift(b)\nS - Time Limits原题面描述A contest setter wants to determine the time limits for a given problem. There are  model solutions, and solution  takes  milliseconds to run on the test data. The contest setter wants the time limit to be an integer number of seconds, and wants the time limit to be at least  times larger than the slowest model solution. Compute the minimum time limit the contest setter can set.\n输入The first line of input contains two space-separated integers  and  ( and ).The second line of input contains  space-separated integers  ( for all ).\n输出Print, on one line, the minimum time limit (in seconds) as a single integer.\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n2 5200 250\n2\n\n\n3 447 1032 1107\n5\n\n\n\n\n题解题意输出最大运行时间的倍向上取整到最小的整数秒数。\n思路直接计算即可。\n时间复杂度\n代码from math import ceiln, s = [int(_) for _ in input().split()]slowest = max([int(_) for _ in input().split()])print(ceil(slowest * s / 1000))","categories":["ACM"],"tags":["Python","C++"]},{"title":"《遥感原理》笔记","url":"/posts/52370b53/","content":"绪论\n遥感定义\n广义：指各种非直接接触、远距离探测目标的技术，往往是通过间接手段来获取目标状态信息。\n狭义：利用安装在遥感平台上的可见光、红外、微波等各种传感器，通过摄影、扫描等方式，从高空或远距离甚至外层空间接受来自地球表层或地表以下一定深度各类地物发射或反射的电磁波信息，并对这些信息进行加工处理，进而识别出地表物体的性质和运动状态。\n简略：遥远的感知。\n\n\n遥感分类\n根据遥感平台分类\n地面遥感\n遥感车\n手提平台\n地面观测台\n\n\n航空平台\n飞机\n气球\n其他航空器\n\n\n航天平台\n火箭\n人造卫星\n宇宙飞船\n空间实验室\n航天飞机\n\n\n\n\n根据传感器的探测波段分类\n紫外遥感：\n可见光遥感\n紫：\n蓝：\n青：\n绿：\n黄：\n橙：\n红：\n\n\n红外遥感\n近红外：\n中红外：\n远红外：\n超远红外：\n\n\n微波遥感：\n\n\n根据工作方式分类\n主动遥感\n侧视雷达\n微波散射计\n雷达高度计\n激光雷达\n\n\n被动遥感\n光学摄影\n电子扫描\n光机扫描\n固体自扫描\n\n\n\n\n根据数据的显示形式分类\n成像遥感\n数字图像\n模拟图像\n\n\n非成像遥感\n光谱辐射计\n散射计\n高度计\n\n\n\n\n根据波段宽度和波谱连续性分类\n常规遥感：分辨率：，举例：TM、SPOT、AVIRIS\n高光谱遥感：分辨率：，举例：Hyperion\n超光谱遥感：分辨率更高\n\n\n根据遥感的应用领域分类\n宏观上\n外层空间遥感\n大气层遥感\n陆地遥感\n海洋遥感\n\n\n微观上\n资源遥感\n环境遥感\n林业遥感\n渔业遥感\n城市遥感\n农业遥感\n水利遥感\n地质遥感\n军事遥感\n\n\n\n\n\n\n遥感的特点\n优点\n宏观性与同步性\n时效性与动态性——动态、快速获取监测范围数据\n多波段性\n综合性与可比性\n经济性——应用领域多，经济效益高\n\n\n局限性\n遥感技术本身的局限性\n工作量大、周期长\n现有遥感图像处理技术难以满足实际需要\n易受天气条件影响\n遥感数据共享和集成难度较大\n\n\n\n\n遥感过程\n信息收集：接收、记录电磁波信号\n信息接收与存储：在卫星地面接收站完成\n信息处理：目的是为了提取有用信息\n信息应用\n\n\n遥感技术系统\n遥感平台系统（天-空-地）\n传感器系统（遥感技术系统核心部分）\n数据的接收记录和处理系统（地面接收站、处理站）\n基础研究和应用系统\n\n\n\n遥感物理基础\n电磁波\n产生\n当导体或电路中的某处有迅速变化的电流时，在该处就会产生一种电磁振荡，在周围空间就会产生向外传播的电磁波。\n\n\n特性\n横波\n叠加原理\n波粒二象性\n传播过程体现波动性。\n与物质作用体现粒子性。\n波长越长，波动性越明显。\n波长越短，粒子性越明显。\n\n\n干涉\n衍射\n偏振\n\n\n参数\n波长\n频率\n波数\n振幅\n速度\n相互转化关系\n\n\n\n\n\n\n\n\n电磁波谱\n按电磁波的波长或频率大小的顺序把它们排列成谱。\n紫外波段（UV）\n可见光波段（VIS）\n红外波段（IR）\n微波波段\n\n\n电磁辐射\n辐射能量\n电磁辐射能量的度量\n记作或\n单位为\n\n\n辐射通量/辐射功率\n单位时间内通过的辐射能量\n记作\n单位为\n是波长的函数\n\n\n辐射通量密度\n单位时间通过单位面积上的辐射能量\n记作\n单位为\n\n\n辐照度\n被辐射物体表面的辐射通量密度\n记作\n单位为\n\n\n辐射出射度\n向外发出辐射的辐射源物体表面的辐射通量密度\n记作\n单位为\n\n\n辐射亮度\n辐射源在某一特定方向单位投影面积单位立体角内的辐射通量密度\n记作\n为立体角\n为投影面积\n为方向角度\n单位为\n遥感观测到的是辐射亮度\n\n\n\n\n电磁辐射源\n太阳\n太阳常数\n不受大气影响，在垂直于太阳辐射的方向，单位时间内单位面积的黑体接收到的太阳辐射辐照度总量。\n\n例题\n已知太阳常数和日地平均距离，求太阳的总辐射通量？\n以日地平均距离为半径，计算该距离上太阳辐射球面积为。\n乘以太阳常数，即为总辐射通量。\n\n\n\n\n太阳光谱\n太阳辐射与温度为的黑体辐射十分相似。\n\n\n\n\n地球辐射\n地球辐射的能量分布在近红外到微波的范围内，主要集中在。\n\n\n\n\n朗伯体与非朗伯体\n非朗伯体\n辐射源（包括辐射或反射）向外辐射电磁波时，一般随变化。\n各向异性\n\n\n朗伯体\n辐射源（包括辐射或反射）向外辐射电磁波时，与无关。即入射能量以入射点为中心，在整个半球空间内向四周各向同性的反射能量的现象，一个完全的漫射体称为朗伯体。\n各向同性\n\n\n朗伯余弦定律\n在理想情况下，朗伯体单位表面积向空间规定方向单位立体角内发射（或反射）的辐射通量和该方向与表面法线方向的夹角的余弦成正比。\n\n\n\n\n绝对黑体\n简称黑体，在任何温度对任何波长的电磁波都全部吸收而没有任何反射的物体。\n自然界不存在绝对黑体。\n黑体会对外辐射，辐射的电磁波的波长和能量只取决于黑体的温度；发出的辐射光谱连续。\n是典型的朗伯源，辐射亮度与角度无关。\n遵循黑体辐射定律。\n\n\n黑体辐射定律\n普朗克定律\n公式：。为光速；为普朗克常量；为玻尔兹曼常量；为物体温度。\n辐射出射度随波长连续变化，每条曲线只有一个最大值。\n温度越高，辐射出射度越大，不同温度的曲线不相交。\n随着温度的升高，辐射最大值所对应的波长向短波方向移动。\n\n\n斯特藩-玻尔兹曼定律\n公式：。其中为斯特藩-玻尔兹曼常数；为物体温度。\n黑体总辐射出射度随温度的增加而迅速增加。\n它与温度的四次方成正比。\n温度的微小变化，就会引起辐射通量密度很大的变化。\n是红外装置测定温度的理论基础。\n\n\n维恩位移定律\n公式：。其中为常数；为物体温度。\n\n\n\n\n反射率\n公式：。其中为反射的辐射能量；为入射总能量。\n镜面反射\n漫反射\n实际物体反射\n反射波谱是地物的反射率随入射波长变化的规律。\n地物反射波谱特征的差异是遥感识别地物性质的基本原理。\n\n\n典型地物的反射波谱特性曲线\n植被\n可见光波段有一个小的反射峰，位置在处，两侧（蓝）和（红）则有两个吸收带。这一特征是叶绿素的影响。\n在近红外波段（）有一反射的“陡坡”，至附近有一“峰值”，形成植被的独有特征。这一特征由于植被结构引起。\n在近红外波段（），反射率大大下降，特别以、和为中心是水的吸收带，形成低谷。\n\n\n水体\n水的浑浊成程度的影响\n在橙、红光段内，混浊水的反射率比清水的反射率高左右。在处，清水反射率降为零；含泥沙的水，在处的反射率还较高（左右），至附近，反射率才降为零。\n悬浮泥沙还导致反射率的峰值出现在之间，即可见光的橙、红光段。\n\n\n水中叶绿素含量的影响\n水中的叶绿素浓度对水的光谱反射率值的影响很明显。\n叶绿素的浓度增加会导致附近蓝光段的反射率显著下降。\n在附近绿光段的反射率则上升。\n\n\n水体污染的影响\n\n\n土壤\n土质越细反射率越高\n有机质和含水量越高反射率越低\n土壤质地\n土壤颜色\n土壤中铁氧化物的含量\n土壤矿物\n土壤结构\n\n\n岩石\n矿物成分\n矿物含量\n风化程度\n含水状况\n颗粒大小\n表面光滑度\n色泽\n\n\n雪\n在可见光波段雪高反射率，近。\n在红外波段反射率下降很快，在和处降至零。\n\n\n\n\n同物异谱和异物同谱\n同物异谱\n相同的地物由于周围环境、病虫害等影响，造成的相同的物种但是其光谱曲线不同。\n除利用光谱外，可利用对象的形状特性或其它辅助信息，即利用多类物体的特征。\n\n\n异物同谱\n不同的地物由于生长环境的影响光谱曲线相同。\n\n\n\n\n影响地物反射波谱的因素\n太阳位置\n传感器位置\n不同的地理位置\n地物本身性质差异\n时间、生长周期\n大气状况\n\n\n大气分层\n对流层\n平流层\n电离层\n外大气层\n\n\n大气成分\n不变成分\n氮\n氧\n氩\n二氧化碳\n氦\n甲烷\n氧化氮\n氢\n\n\n可变成分\n臭氧\n水\n盐粒\n尘烟\n\n\n\n\n大气对太阳辐射的影响\n吸收作用\n氧气：主要吸收小于的辐射；和处也有窄带吸收。这也是高空遥感很少使用紫外波段的原因。\n臭氧：数量极少，但吸收很强。、和处存在强吸收；对航空遥感影响不大。\n二氧化碳：量少；吸收作用主要在红外区内。可以忽略不计。\n水：吸收太阳辐射能量最强的介质。到处都是吸收带。主要的吸收带处在红外和可见光的红光部分。因此，水对红外遥感有极大的影响。\n大气的吸收作用具有选择性\n臭氧吸收紫外线\n水汽和二氧化碳吸收红外线\n\n\n\n\n散射作用\n实质是电磁波传输过程中产生的一种衍射现象。\n瑞利散射\n发生于大气中的微小颗粒半径比电磁波的波长小很多的情况。\n散射强度与波长的四次方成反比。\n对可见光的影响较大，对红外辐射的影响很小，对微波的影响可以不计。\n导致图像模糊的主要原因之一。\n使晴天天空呈现蓝色。\n使朝霞和夕阳偏橘红色。\n\n\n米氏散射\n发生于微粒的直径接近或大于辐射波长的情况。\n对红外线的影响作用不能忽视。\n\n\n非选择性散射\n使云雾看起来是白色。\n\n\n\n\n反射作用\n表现为云层以及大气中较大颗粒的尘埃对太阳辐射的反射。\n\n\n\n\n大气窗口\n通过大气而较少被反射、吸收或散射的透射率较高的电磁辐射波段。\n是选择遥感工作波段的重要依据。\n常见大气窗口\n：包括全部可见光（透射率），部分紫外光（），部分近红外光（）。摄影和扫描成像的方式在白天感测和记录目标电磁波辐射信息。\n：近红外窗口，透射率，扫描成像，白天记录。\n：中红外窗口，透射率，白天夜间，扫描成像记录。\n：热红外窗口，透射率超过，白天夜间扫描。\n：微波窗口，白天夜间，扫描记录。\n\n\n\n\n\n遥感平台\n遥感平台指搭载传感器的工具或设备。\n遥感平台类型\n地面平台\n地面或水上的装载传感器的固定或移动装置。\n\n\n航空平台\n高度在以内的遥感平台。\n飞机\n低空平台：\n中空平台：\n高空平台：\n\n\n气球\n低空气球：对流层\n高空气球：平流层\n\n\n无人机\n固定翼无人机\n无人驾驶直升机\n\n\n\n\n航空平台\n在超出大气层的地球附近空间或太阳系各行星间的飞行器。\n高空探测火箭\n人造地球卫星\n宇宙飞船\n航天飞机\n空间轨道站\n\n\n\n\n遥感平台的姿态\n指平台坐标系相对于地面坐标系的倾斜程度，常用三轴的旋转角度来表示。定义卫星质心为坐标原点沿轨道前进的切线方向为轴，垂直轨道面的方向为轴，垂直平面的为轴。\n侧滚：绕轴旋转的姿态角\n俯仰：绕轴旋转的姿态角\n偏航：绕轴旋转的姿态角\n振动：除滚动、俯仰与偏航以外的非系统性的不稳定振动现象。振动随机性强，难以消除。\n\n\n轨道参数\n轨道倾角：卫星轨道面与地球赤道面的夹角。\n重访周期/回归周期：卫星从某地上空开始运行，经过若干时间的运行后，回到该地上空时所需要的天数。\n轨道周期：卫星绕地一圈所需要的时间，一般以分为单位。可计算出每天卫星绕地球的圈数。\n星下点：卫星质心与地球中心连线在地球表面上的交点。\n星下点轨迹：星下点在卫星运行过程中在地面的轨迹。\n回归轨道：卫星星下点的轨迹每天通过同一地面的轨道。\n准回归轨道：星下点每天通过的情况称为准回归轨道。\n\n\n地球同步轨道\n卫星公转的角速度和地球的自转角速度相等。卫星轨道运行周期正好等于地球自转周期（），且卫星公转方向与地球自转方向相同，这样的卫星称地球同步轨道卫星。\n特点\n高度高（约）\n能长期大范围观测同一区域\n广泛应用于气象卫星和通讯卫星\n\n\n\n\n太阳同步轨道\n卫星轨道面绕地球的自转轴旋转，旋转方向及周期与地球的公转方向及周期相等。\n卫星轨道平面与太阳光之间的夹角称为太阳光照角，且始终保持一致。\n特点\n轨道高度约\n近圆轨道、轨道倾角接近（也称近极轨卫星）\n可获取包括南北极在内的覆盖全球的遥感影像\n每天在同一方向同一地方时通过同一纬度地面点且有利用长时间监测\n\n\n\n\n\n遥感传感器\n传感器\n是遥感技术系统的核心。\n传感器是收集、测量和记录从目标反射或发射来的电磁波的仪器。\n构造\n收集器：收集地物辐射来的能量\n探测器：将收集的辐射能转变成化学能或电能\n处理器：对收集的信号进行处理\n输出器：输出获取的数据\n\n\n分类\n按工作方式\n主动\n被动\n\n\n按信息记录方式\n成像\n非成像\n\n\n按成像原理与图像性质\n摄影成像\n扫描成像\n雷达成像\n\n\n按响应波段\n可见光及近红外\n热红外\n微波\n多光谱\n高光谱\n\n\n\n\n\n\n摄影型传感器\n传统摄影依靠光学镜头及放置在焦平面的感光胶片来记录物体影像。\n数字摄影通过放置在焦平面的光敏元件，经光电转换，以数字信号来记录物体的影像。\n摄影型传感器工作波段主要在可见近红外波段，较多用于航空遥感探测。\n类型\n单镜头框幅式摄影机\n缝隙式摄影机\n全景摄影机\n多光谱摄影机\n对同一地区、同一瞬间获取多个波段影像的摄影机。\n可同时直接获取可见光和近红外范围内若干个分波段影像，增加目标物的信息量，提高影像的判读与识别能力。\n类型\n多镜头组合型\n多相机组合型\n光束分离型\n\n\n\n\n\n\n几何特征\n垂直摄影与倾斜摄影\n中心投影与垂直投影（正射投影）\n投影：用一组假想的直线将物体形状向几何面投影成像\n中心投影：投影射线汇聚同一点的投影\n投影中心：中心投影射线的汇聚点\n摄影像片和航片是地面景物的中心投影。\n地形图是地面景物的正射投影。\n摄影测量的主要任务之一，即如何把记录在中心投影像片上的地面景物转换成按图比例尺的正射投影地图。\n航片是地面的中心投影正像。\n两者区别主要体现\n投影距离方面\n投影倾斜面方面\n地形起伏方面\n\n\n像点位移\n位移量与地物高程成正比\n凸起：背离像主点\n凹陷：朝向像主点\n\n\n位移量与像点距像主点的距离（）成正比（时无位移）\n与摄影高度成反比\n\n\n像片的比例尺\n像片上两点之间的距离与地面上相应两点实际距离之比，即。\n例题一\n已知某河流的宽度为，在像片上量得的宽度为，则该像片的比例尺为？\n\n\n\n例题二\n已知某地形图的比例尺为时，在地形图上量得两点的长度为，在像片上量得相应两点的长度为，则该像片的比例尺为？\n两点实际距离为\n比例尺为\n\n\n\n\n航向重叠与旁向重叠\n地物相互衔接及立体观察：航向重叠为\n多航线摄影：旁向重叠为\n\n\n\n\n\n\n\n\n扫描型传感器\n扫描成像：依靠探测原件和扫描镜对目标地物以瞬时视场为单位进行的逐点、逐行取样，以得到目标地物电磁辐射特性信息，形成一定谱段的图像。\n瞬时视场角（IFOV）：扫描镜在一瞬时时间可以视为静止状态，此时，接收到的目标物的电磁波辐射，限制在一个很小的角度之内，这个角度称为瞬时视场角。即扫描仪的空间分辨率。\n固有优势\n扫描成像光谱响应区间宽\n数据易存储与传输\n系统集成性好，数据可用性更高\n\n\n探测器性能指标\n瞬时视场角（IFOV）\n信噪比（SNO）\n光谱灵敏度\n\n\n常见扫描成像遥感器\n光机扫描仪\n又称光学机械扫描仪。借助遥感器本身沿着垂直遥感平台飞行方向的横向光学机械扫描，获取覆盖地面条带图像的成像装置。\n特点\n光机扫描为行扫描；每条扫描线/扫描线组均有一个投影中心，所得影像为多中心投影影像。\n飞行方向和扫描方向的不一致。\n在每条扫描线上，距离平台投影中心越远，像点变形越大。\n\n\n\n\nCCD固体自扫描成像仪\n光机扫描仪与CCD固体自扫描成像仪对比\n光机扫描仪（摆扫式）\n优点\nFOV大。\n像元配准好。\n探测元件定标方便，数据稳定性好。\n进入物镜后再分光，光谱波段范围可以做得很宽。\n\n\n缺点\n像元凝视时间短。\n提高光谱和空间分辨率以及信噪比相对困难。\n\n\n\n\nCCD固体自扫描成像仪（推扫式）\n优点\n像元凝视时间大大增加，有利于提高系统的空间分辨率和光谱分辨率。\n没有光机扫描结构，仪器的体积小。\n\n\n缺点\nFOV增大困难。\n面阵CCD器件标定困难。\n大面阵的短波和红外探测器研制仍是技术难点。\n\n\n\n\n\n\n成像光谱仪\n在获取大量目标窄波段连续光谱图像的同时，获得每一个像元几乎连续的光谱数据。\n类型\n线阵列探测器加光机扫描仪的成像光谱仪\n面阵探测器加推扫式扫描仪的成像光谱仪\n\n\n\n\n\n\n\n\n微波遥感\n指通过传感器获取从目标地物发射或反射的微波辐射，经过判读处理来认识地物的技术。\n\n\n微波遥感特点\n能全天候、全天时工作\n对某些地物具有特殊的波谱特征\n对冰、雪、森林、土壤等具有一定穿透力\n对海洋遥感具有特殊意义\n\n\n微波遥感方式\n主动\n雷达（侧视雷达）：成像\n微波高度计：不成像\n微波散射计：不成像\n\n\n被动\n微波辐射计：成像\n微波散射计：不成像\n\n\n\n\n雷达与侧视雷达\n用于测定目标的位置、方向、距离和运动目标的速度。\n成像基本条件\n发射的波束照在目标的不同部位要有时间先后差异。\n\n\n距离分辨率\n物理含义：脉冲宽度设为，光速为，两个不同距离的目标产生两个回波，要使两个回波不完全重叠，才能分清是哪一个回来的信号，必须有。\n具体公式：。\n距离分辨率与距离无关。\n俯角越大，距离分辨率越低；俯角越小，距离分辨率越大（与被动成像的差别）。\n\n\n方位分辨率\n公式为。其中天线长为；雷达波长为；视角为；雷达到地面目标斜距长。\n\n\n侧视雷达会出现的图形变形\n前坡缩短\n顶底倒置\n阴影\n\n\n合成孔径雷达\n基本原理：利用短的天线，通过修改数据记录和处理技术产生很长孔径天线的效果，等于通过加长天线孔径来提高观测精度。即小天线+信号处理=大天线。\n分辨率与天线长度有关，为。\n\n\n\n\n\n遥感图像及其特征\n空间分辨率\n空间分辨率：指遥感图像上能够详细区分的最小单元的尺寸或大小；或指遥感器区分两个目标的最小角度或线性距离的度量。\n地面分辨率：指可以识别的最小地面距离或最小目标物的大小。\n表示方法\n像元大小\n单个像元所对应的地面面积大小\n空间尺度转换\n降尺度：粗（低）分辨率→高分辨率\n升尺度：高分辨率→粗（低）分辨率\n\n\n\n\n线对数\n对摄影系统而言，影像的最小单元常通过间隔内包括的线对数（Line Pairs，LP）确定，单位为。\n线对数指一对同等大小的明暗条纹或规则间隔的明暗条对。\n\n\n瞬时视场角（IFOV）\n指遥感器内单个探测元件的受光角度或观测视野。\nIFOV越小，最小可分辨单元（可分像素）越小，空间分辨率越高。\n\n\n视场角（FOV）\n指遥感器对地扫描或成像的总角度，它决定了一幅图像对地面的覆盖范围。\n\n\n基高比\n指航空摄影时，摄影基线与相对航高的比值。\n视场角越大，基高比就越大，高程测量精度就越高。\n基高比越大，影像航向重叠越小，反之越大。\n\n\n\n\n\n\n波谱分辨率\n指传感器在接收目标辐射的波谱时能分辨的最小波长间隔。\n通常情况，光谱分辨率越高，则对地物特征的识别能力越强。\n不同波谱分辨率的传感器对同一地物探测效果有很大区别。间隔愈小，分辨率愈高。\n波段并非简单的越多越好。\n传感器的波段设计必须考虑目标地物的光谱特征值。\n\n\n辐射分辨率\n指传感器接收波谱信号时，能分辨的最小辐射度差。\n在遥感图像上表现为每一像元的辐射量化级，或遥感器对光谱信号强弱的敏感程度区分能力。\n\n\n时间分辨率\n指对同一地点进行采样（观测）的时间间隔，即采样的时间频率。\n\n\n陆地卫星\nLandsat卫星系列（美国）\n概况\n至今共三代，颗卫星。\nLandsat-1于1972年发射。\nLandsat-5于1984年发射，2011年停止接收数据，在轨工作27年。\nLandsat-6发射失败。\n最新在轨工作的Landsat-8于2013年发射。\n\n\n轨道特征\n高度：\n近极地、准圆形、太阳同步、准回归轨道\n\n\n传感器\n多光谱扫描仪（MSS）\n专题制图仪（TM）\n陆地成像仪和热红外传感器\n\n\n数据产品\n原始数据产品（Level 0）\n辐射校正产品（Level 1）\n系统几何校正产品（Level 2）\n几何精校正产品（Level 3）\n高程校正产品（Level 4）\n\n\n\n\nSPOT卫星系列（法国主导、欧盟相关国家参与）\n概况\n至今共颗卫星。\nSPOT-1于1986年发射。\n\n\n轨道特征\n高度：（北纬附近）\n倾角：\n周期：\n重访周期：\n近极地、准圆形、太阳同步、准回归轨道\n\n\n传感器\n线阵列推帚式扫描仪HRV\n\n\n\n\n高空间分辨率陆地卫星\nGeoEye-1（地球之眼-1）：美国\nQuickBird（快鸟）：美国\nWorldView-1和WorldView-2：美国\nEROS-B：以色列\n高分一、二、三号：中国；太阳同步回归轨道\n高分四号：中国；地球同步轨道\n\n\n中国地球资源卫星\n概况\n至今共颗卫星。\nZY-1发射于1999年，为中国与巴西共同投资。\n\n\n轨道特征\n高度：\n倾角：\n回归周期：\n太阳同步回归轨道\n\n\n传感器\nCCD相机\n红外扫描仪\n宽视场成像仪\n\n\n\n\n\n\n气象卫星\n类型\n地球静止轨道气象卫星\n轨道高度：近\n轨道倾角：\n绕地球一周需\n卫星公转角速度与地球自转角速度相等\n\n\n太阳同步轨道（极地轨道）气象卫星\n轨道高度：\n轨道倾角：约\n每天定时飞经同一地区上空两次\n\n\n\n\n特点\n高时间分辨率。\n成像面积大，有利于获得宏观同步信息，减少数据处理量。\n资料来源连续及一致性。\n\n\n美国NOAA卫星\n中国气象卫星\n风云一号：极轨轨道气象卫星\n风云二号：静止轨道气象卫星\n风云三号：极轨轨道气象卫星\n风云四号：静止轨道气象卫星\n\n\n\n\n海洋卫星\n海洋水色卫星\n海洋地形卫星\n海洋动力环境卫星\n\n\n\n遥感图像处理\n定义\n对遥感图像进行辐射校正和几何校正、图像整饰、投影变换、镶嵌、特征提取、分类以及各种专题处理等一系列操作，以求达到预期目的的技术。\n\n\n数字图像\n定义：能在计算机里存储、运算、显示和输出的图像。\n数字化：包括对模拟图像的空间离散化运算（采样）和亮度值的离散化处理（量化）。\n优点\n便于计算机处理和分析\n图像信息损失低\n抽象性强\n\n\n\n\n遥感数字图像校正\n几何校正\n目的\n纠正内外部因素引起的变形，从而实现与标准图像或者地图的几何整合，使之能与地理信息系统和空间决策支持系统中的其他空间数据信息一起使用。\n\n\n一些术语\n配准：同一区域内两幅图像之间的相互对准，一般以一幅标准图像去校正另一幅图像，以使两幅图像中的同名像元几何位置匹配。\n校正：图像对地图的对准，使图像像地图一样平面化，也成为地理参考过程。\n地理编码：是校正的一个特例，还包括比例尺的归一化和像元尺寸和坐标的标准化，以使来自不同传感器的图像或地图能够方便地进行不同图层间的互操作。\n正射校正：对图像的逐个像元进行地形校正，使图像符合正射投影的要求。\n\n\n主要过程\n地面控制点的选取：注意数目和采集要求\n多项式校正的模型：多项式模型、共线模型\n重采样：最近邻方法、双线性内插法、三次卷积内插方法（辛克函数）\n\n\n\n\n辐射校正\n目的\n消除图像数据中依附在辐射亮度中各种由于传感器自身条件、薄雾等大气条件、太阳位置和角度条件及某些不可避免的噪声引起的辐射失真。\n\n\n主要过程\n传感器校正：对光学系统特性引起的失真校正、对光电转换系统特性引起的失真校正\n大气校正：野外波谱测试回归分析法、辐射传输方程计算法、波段对比法\n太阳高度和地形校正\n\n\n\n\n去除噪声\n全局噪声\n局部噪声\n周期噪声\n探测器条纹\n\n\n\n\n数字图像增强\n空间域增强\n在图像平面上直接针对每个像元点进行处理，处理后的像元位置不变，包括点运算和邻域运算。\n\n\n频率域增强\n空间频率：图像像元的灰度值随位置变化的频繁程度可以用频率来表示，这是一种随位置变化的空间频率。\n平滑：保留低频部分，抑制高频部分。\n锐化：保留高频部分，抑制低频部分。\n\n\n彩色增强\n伪彩色增强：把一幅黑白图像的不同灰度按一定的函数关系变换成彩色，得到另一幅彩色图像。\n假彩色增强：对于多波段遥感图像，选择其中的某三个波段，分别赋予红、绿、蓝三种原色。\nHLS变换\n\n\n图像运算\n加法运算\n差值运算\n比值运算\n植被指数\n根据地物光谱反射率的差异作比值运算可以突出图像中植被的特征、提取植被类别或估算绿色生物量，通常把能够提取植被的算法称为植被指数。\n设表示红光波段的反射值，表示近红外波段的反射值。\n比值植被指数：\n归一化植被指数：\n\n\n\n\n\n\n\n遥感图像目视解译\n遥感图像分类\n定义\n对地球表面及其环境在遥感图像上的信息进行识别和分类，从而达到识别图像信息所对应的实际地物、提取所需地物信息的目的。\n\n\n目的\n将图像中每个像元根据其在不同波段的光谱亮度、空间结构特征或者其他信息，按照某种规则或算法划分为不同的类别。\n\n\n\n\n遥感图像解译\n定义\n从遥感图像中获取目标地物信息的过程。\n\n\n目视解译\n指专业人员通过直接观察或借助判读仪器在遥感图像上获取特定目标地物信息的过程。\n\n\n计算机解译\n以计算机系统为支撑环境，利用模式识别技术与人工智能技术相结合，根据遥感图像中目标地物的各种影像特征，结合专家知识库中目标地物的解译经验和成像规律等知识进行分析和推理，实现对遥感图像的理解，完成对遥感图像的解译。\n\n\n\n\n目标地物特征\n色\n色调\n颜色\n阴影\n\n\n形\n形状\n纹理\n大小\n图形\n\n\n位\n空间位置\n相关布局\n\n\n\n\n目视解译标志\n定义\n又称判读标志，指能够反映和表现目标地物信息的遥感影像各种特征，这些特征能够帮助解译者识别遥感图像上目标地物或现象。\n\n\n直接解译标志\n色调和色彩\n阴影\n位置和布局\n大小\n形状\n图案\n纹理\n\n\n间接解译标志\n地形地貌\n土壤、土质\n植被\n气候\n水系\n人类活动\n\n\n\n\n目视解译原则\n遥感图像目视解译要基于影像特征。\n遥感解译分类体系要基于影像解译的可能性。\n先图外、后图内，先整体、后局部。\n充分利用影像的信息特征和处理技术。\n多信息、多方法综合分析。\n室内解译与室外判读相结合。\n严格遵循目视解译程序。\n\n\n目视解译方法\n直接判定法\n对比分析法\n信息复合法\n综合推理法\n地理相关分析法\n\n\n目视解译的步骤\n准备工作\n初步解译与解译区的野外考察\n室内详细解译\n野外验证与补判\n成果整理\n\n\n影响地物特征及其解译的因素\n地物本身的复杂性\n传感器特性的影响\n目视能力的影响\n\n\n目视解译优缺点\n优点\n能够充分的利用先验知识、专家知识库，一般目视解译精度较高。\n可以作为计算机自动分类的地表真实参考值。\n\n\n缺点\n效率低、费时费力，需要较大的人力成本。\n需要具有专业知识的判断专家。\n\n\n\n\n\n遥感数字图像计算机解译\n模式\n指某种具有空间或几何特征的某种事物的标准形式。\n\n\n模式识别\n对被识别的模式作一系列的测量，然后将测量结果与“模式字典”中一组“典型的”测量值相比较，得出所需要的分类结果的过程。\n\n\n光谱特征向量\n同名地物点在不同波段图像中亮度的观测量构成一个多维的随机向量。\n\n\n光谱特征空间\n指所有波段的亮度轴构成的直角坐标空间，同类地物具有聚类的效应。\n\n\n特征变换\n概念\n将原始图像通过一定的数学变换生成一组新的特征图像，这一组新图像信息集中在少数几个特征图像上。\n\n\n目的\n数据量有所减少，去相关，有助于分类。\n\n\n常用特征变换\n主成分变换\n基本思想\n一种线性变换，均方误差最小的最佳正交变换\n是在统计特征基础上的线性变换\n\n\n目的\n数据压缩\n新的特征图像之间互不相关\n增加类别的可分性\n\n\n几何意义\n把原始特征空间的特征轴旋转到平行于混合集群结构轴的方向上\n\n\n\n\n穗帽变换\n哈达玛变换\n\n\n\n\n计算机分类\n分类的核心是确定判别函数和判别准则。\n判别规则：判读特征矢量属于某类所需的判断依据。\n判别函数：各个类别的判别区域确定后，某个特征矢量属于哪个类别可用一些函数来表示和鉴别，这些函数称为判别函数。\n\n\n监督分类\n定义\n以建立统计识别函数为理论基础，依据典型样本训练方法进行分类的技术。\n\n\n训练（学习）\n利用一定数量的已知类别函数求解待定参数的过程。\n\n\n思想和基本过程\n根据对研究区域的了解（先验知识），从遥感数据中选择能代表各分类的训练样区（样本）。\n对样本数据依据选用的分类器进行统计分析，提出各类别的特征数据，并建立适用的判别准则。\n使用判别准则对每个像元归属类别进行判定。\n输出分类结果。\n\n\n主要步骤\n确定分类体系和感兴趣的类别数。\n特征变换和特征选择。\n选择训练样区。\n确定判决函数和判决规则。\n根据判决函数和判决规则对非训练样区的图像区域进行分类，并对类别进行编码。\n分类效果评估。\n\n\n常见方法\n最小距离分类法\n最大似然分类法\n\n\n优点\n可以控制适用于研究需要以及区域地理特征的信息类别，即可以有选择性地决定分类类别，避免出现不必要的类别。\n可以控制训练样区和训练样本的选择。\n光谱类别与信息类别的匹配。\n通过检验训练样本数据可以确定分类的准确性，估算分类误差。\n避免了非监督分类对光谱集群类别的重新归类。\n\n\n缺点\n主观性\n由于图像中间类别的光谱差异，使得训练样本没有很好的代表性。\n训练样本的获取和评估花费较多人力时间。\n只能识别训练中定义的类别。\n\n\n\n\n非监督分类\n定义\n人们事先对分类过程不施加任何先验知识，而仅凭遥感影像数据的光谱特征分布规律，即自然聚类的特性，进行“盲目”的分类。\n\n\n主要步骤\n确定分类数量。\n选择集群类别中心。\n类别中心的处理。\n像元初始归类。\n重分类。\n\n\n常见方法\n分级集群法\nK-均值算法\nISODATA聚类法\n\n\n优点\n不需要预先对所要分类的区域进行广泛了解。\n人为误差的几率较小。\n面积很小的独立地物均能被识别。\n\n\n缺点\n形成的光谱类别与信息类别并不完全一一对应，需要通过目视判读建立两者之间的对应关系。\n分析人员很难控制分类产生的类别并对其进行识别。\n光谱类别的解译识别工作量大而复杂。\n\n\n\n\n计算机解译的其他方法\n模糊聚类法\n人工神经网络分类法\n专家系统分类法\n支持向量机\n\n\n分类精度的评价\n通常用分类图与标准数据进行比较，以正确分类的百分比来表示分类精度。\nKappa系数\nKappa系数是一个测定两幅图之间吻合度或精度的指标。\n\n为误差矩阵中的总列数（总的类别数）\n为混淆矩阵中第行第列上像素数量（正确分类的数目）\n为第行的总像素数量\n为第列的总像素数量\n为用于精度评估的总像素数量\nKappa系数值的意义\n：评价者间的意见完全一致\n：评价者间意见一致程度是依据偶然的\n：评价者间的意见程序还不如偶然的\n：说明有意义\n：说明已经取得了相当满意的一致程度\n：说明一致程度不够理想\n\n\n\n\n\n\n\n遥感专题制图\n遥感影像地图\n是一种以遥感影像和一定的地图符号来表现制图对象地理空间分布和环境状况的地图。\n\n\n制图步骤\n遥感影像信息选取与数字化\n地理基础底图的选取与数字化\n遥感影像几何纠正与图像处理\n遥感影像镶嵌与地理基础底图拼接\n地理基础底图与遥感影像复合\n符号注记图层生成\n影像地图图面配置\n遥感影像地图制作与印刷\n\n\n\n","categories":["学科笔记"]},{"title":"《数字高程模型》笔记","url":"/posts/92d9ab23/","content":"概论\nDEM概念\n总述：DEM是对地球表面地形地貌的离散的数字表达，是定义在二维平面区域上点的高程的集合。\n狭义：DEM是区域地表面海拔高程的数字化表达。\n广义：DEM是地理空间中地理对象表面海拔高度的数字化表达。\n数学：DEM是定义在二维空间上的连续函数。\n\n\nDEM研究内容\n地形数据采样\n地形建模与内插\n数据组织与管理\n地形分析与地学应用\nDEM可视化\n不确定性分析和表达\n\n\nDEM含义\n地理空间是三维的，但DEM是叠加在二维地理空间上的一维特征（高程）的向量空间，其本质是地理空间定位和数字描述。DEM是维的。\n\n\nDEM类型\n按结构分类\n基于点的DEM\n散点DEM\n\n\n基于线的DEM\n断面DEM\n等高线DEM\n\n\n基于面的DEM\n格网DEM\n三角网DEM\n\n\n\n\n按范围分类\n局部DEM\n地区DEM\n全局DEM\n\n\n按连续性分类\n不连续DEM\n连续不光滑DEM\n光滑DEM\n\n\n\n\nDEM特点\n精度的恒定性\n表达的多样性\n更新的实时性\n尺度的综合性\n\n\nDEM系统结构与功能\n数据采集\nDEM建立\n\n\n数据处理\nDEM操作\nDEM分析\nDEM可视化\n\n\n应用\nDEM应用\n\n\n\n\nDEM与GIS的关系\nDEM作为地表地形信息的集合，是GIS空间数据库的核心和各种地学分析的基础数据，也成为GIS的基本空间分析方法。\nDEM对GIS数据采集、组织、分析、可视化方面贡献巨大，DEM已不再是简单的数据集合，而是一种地理信息数据处理的技术方法。\n\n\nDEM应用范畴\n科学研究\n区域、全区气候变化研究\n水资源、野生动植物分布\n地质、水文模型建立\n地理信息系统\n地形地貌分析\n土地分类、土地利用、土地覆盖变化检测\n\n\n商业\n电信\n空中交通管理与导航\n资源规划管理与建设\n地质勘探\n水文和气象服务\n遥感、测绘\n多媒体应用和电子游戏\n\n\n工业、工程\n管理\n军事\n数字地球\n\n\nDEM发展\nDEM最早由Miller（1956年）提出，用于解决高速公路的自动设计。\n其研究可分为以下五个时期\n50年代末形成概念。\n60-70年代主要进行插值问题的研究。\n70年代中后期主要进行采样问题的研究。\n80-90年代研究涉及到DTM的很多方面，包括其精度、地形分类、质量控制、数据压缩、 DTM应用等。\n90年代以后主要着重于DTM的特征提取及分析研究。\n\n\n\n\n\n\nDEM数据组织与管理\nDEM数据组织的目的\n将所有相关的DEM数据通过数据库有效地管理起来，并根据其地理分布建立统一的空间索引，进而可以快速调度数据库中任意范围的数据，实现对整个区域的无缝漫游。\n\n\nDEM数据模型\n镶嵌数据模型\n思想：空间对象可用相互连接在一起的网络来覆盖和逼近。\n适用于三维离散空间数据的表达，以及连续变化的空间对象的模拟。\n特征参数：网格尺寸、形状、方位等\n分类\n规则镶嵌数据模型：栅格DEM\n不规则镶嵌数据模：TIN\n\n\n\n\n规则镶嵌数据模型\n含义：用规则的小面块集合来逼近不规则分布的地形曲面。\n构造方法：用数学手段将研究区域进行网格划分，把连续的地理空间离散为互不覆盖的网格，然后对网格单元附加相应的属性信息。\n特点\n数据结构简单\n隐式的坐标存储\n高效的访问效率\n有数据冗余\n\n\n对格网单元数值的两种观点\n格网栅格观点：该格网单元的数值是其中所有点的高程值，即格网单元内部是同质的，格网单元对应的实地单元区域内的高程是均一的高程，任何落在该格网的点与格网单元的值是想用的。这种DEM表达的是一个不连续的表面。\n点栅格观点：格网单元的数值是网络中心点的高程值。这种DEM是连续的，在这种DEM上任意点的高程都要通过内插方式确定。\n\n\n\n\n不规则镶嵌数据模型\n含义：用来进行镶嵌的小面块具有不规则的形状和边界。\n优点\n不需要维护模型的规则性\n能灵活地随地形的复杂程度而改变格网单元大小\n避免平坦地区数据冗余\n能按地形特征点线等来表示地形特征\n\n\n\n\n特征嵌入式数据模型\n含义：把特征要素嵌入规则或不规则镶嵌数据模型中。\n特点\n克服了格网DEM难以精确描述地形结构和突变地形的缺憾\n维护了DEM地形描述与处理的高效、简便优势\n\n\n\n\n\n\n规则格网DEM数据结构\n简单矩阵结构\n含义：按行（或列）逐一记录每个格网单元的高程值。\n数据文件\n数据头\n行列数\n西南角坐标\n格网间距\n无效数据区域值\n\n\n数据体\n\n\n\n\n行程编码结构\n块状编码结构\n四叉树编码结构\n线性四叉树\n含义：通过编码四叉树的叶节点来表示数据块的层次和空间关系。叶节点具有反映位置的关键字，即位置码。\n\n\n\n\nTIN数据结构\n基本结构元素：三角形的顶点、边和面\n\n\n规则格网DEM与TIN的对比\n\n\n\n\n\n规则格网DEM\nTIN\n\n\n\n\n优点\n优点\n\n\n简单的数据存储结构\n较少的点可获取较高的精度\n\n\n与遥感影像数据的结合性好\n可变分辨率\n\n\n良好的表面分析功能\n良好的拓扑结构\n\n\n缺点\n缺点\n\n\n计算效率较低\n表面分析能力较差\n\n\n数据冗余\n构建比较费时\n\n\n格网结构规则\n算法设计比较复杂\n\n\n\n\n\n我国已建立的DEM数据库\n\n\n\n\n\n比例尺\n分辨率（米）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDEM数据库实现的两种方式\n基于文件系统和空间索引的方式\nESRI公司的空间数据引擎SDE\n\n\n基于关系型数据库的方式\n\n\nDEM数据库结构\n实质：DEM数据结构\n\n\nDEM数据库组织\n含义：DEM数据的管理和调度方式，实际上是可视范围（即工作区）的数据管理，可以为用户提供宏观、中观、微观等方式的信息服务。\n“工程-工作区-图幅”层次结构索引模式\n工程：一个区域内的全部DEM数据\n工作区：当前感兴趣的研究区域\n图幅：按照一定规则对研究区域进行二维划分\n对于TIN的注意点\n相邻图幅之间要有一定重叠\n有必要在图幅内建TIN的空间索引以快速定位点所在三角形\n\n\nLOD细节层次模型\n含义：一个工程含有不同分辨率的DEM\n实现方案\n静态建立\n动态实时简化\n\n\n\n\n\n\n\n\nDEM数据库系统功能\n数据显示与浏览\n数据库查询\n基本DEM分析与应用示范功能\n数据分发与提取\n空间索引建立\n数据通信功能\n数据库更新\n数据维护管理\n\n\nDEM元数据\n含义：关于数据的数据，描述数据的内容、质量、状况和其他特征，帮助人们定位和理解数据。元数据是实现空间数据共享的重要基础。\n目的：促进数据体的高效利用，并为计算机辅助软件工程服务。\n基本作用：\n可用性：用以确定是否存在某个地理位置的一组数据\n适用性：用以评估这组数据是否适用\n存取：用以确定获得验证过的数据的手段\n变换：用以成功地处理和使用这组数据\n\n\n内容\n基本标识信息\n质量信息\n数据组织信息\n空间参考信息\n实体与属性信息\n发行信息\n元数据参考信息\n\n\n\n\nDEM元数据库管理系统主要功能\n元数据编辑（增、删、改）\n元数据查询和显示\n元数据库报表输出和打印\n\n\n\nDEM数据获取方法\nDEM数据源\n地形图\n覆盖范围广\n比例尺系列齐全\n获取较为经济\n现势性较差\n存储介质易变形\n精度与比例尺、等高线密度、成图方式有关\n\n\n摄影测量/遥感影像\n覆盖范围广\n获取速度快\n现势性好\n\n\n地面测量\n小范围的数据采集与数据更新\n精度高\n周期长\n成本较高\n适用于精度要求较高的工程项目\n\n\n既有DEM数据\n\n\n地形曲面的几何要素\n特征要素\n特征点\n坡度变换点\n方向变换点\n山顶点\n山谷点\n鞍部点\n山脚点\n洼地\n\n\n特征线\n山脊线\n山谷线\n断裂线\n陡坎\n海岸线\n水涯线 \n\n\n\n\n\n\n非特征要素\n随机点\n随机线\n\n\n\n\n地形复杂度表达方法\n坡度\n含义：地形表面上高度的一阶差分，表达了地形表面高度随距离变化的比率。坡度变率同样反映了地面的复杂程度。\n根据坡度角便可以完整地形成地形曲面。\n区域DEM高程精度与平均坡度之间存在强相关性。\n坡度表达了地形曲面局部单元的倾斜程度（即地表陡峭方向和大小）。\n公式：。其中为测区的面积；为测区等高线的长度；为等高距。前提是测区内等高距相等。\n\n\n曲率\n含义：地形曲面在各个截面方向上的形状、凹凸变化的反映。\n\n\n光谱频率\n分数维\n\n\nDEM数据源的属性\n数据分布\n数据位置\n数据分布图案\n\n\n数据密度\n相邻两点之间的距离（采样间隔、采样距离），表示规则格网分布的采样点。\n单位面积内的点数，描述随机分布的采样点。\n单位线段上的采样点数，描述沿线状分布的采样点。\n截止频率，表示采样数据所能表示的最高频率。\n\n\n数据精度\n与数据源、数据的采集方法、采集仪器密切相关。\n\n\n\n\n采样布点原则\n沿等高线采样\n在地形复杂及陡峭地区，可采用沿等高线跟踪的方式进行数据采集，而在平坦地区，则不宜采用。\n\n\n规则格网采样\n适于自动或半自动的数据采集；能确保所采集的数据具有规则的格网形式。\n\n\n剖面采样\n与格网法区别是在格网法中量测点在格网的两个方向上都均匀采样，而在剖面法中，只是在一个方向即剖面方向上均匀采样。\n优点\n效率高。\n\n\n缺点\n精度低。\n\n\n\n\n渐进采样\n为使采样点分布合理，可采用此方法。小区域的格网间距逐渐改变，采样由粗到精地逐渐进行。\n优点\n渐进采样能解决规则格网采样方法所固有的数据冗余问题。\n\n\n缺点\n在地表突变邻近区域内的采样数据仍有较高的冗余度。\n有些相关特性在第一轮粗略采样中有可能丢失，并且不能在其后的任一轮采样中恢复。\n跟踪路径太长，导致时间效率降低。\n\n\n\n\n选择性采样\n为了准确反映地形，可根据地形特征进行选择性的采样。\n优点\n只需以少量的点便能使其所代表的地面具有足够的可信度。\n\n\n缺点\n需要受到专业训练的观测者对立体模型进行大量内插，所以并非一种高效的采样方法。\n\n\n\n\n混合采样\n选择性采样与规则格网采样结合或选择采样与渐进采样结合；在地形突变处以选择采样的方式进行，然后这些特征线和另外一些特征点如山顶点，被加入规则格网数据中。\n优点\n可建立附加地形特征的规则矩形格网DEM，也可建立沿特征附加三角网混合形式的DEM。\n\n\n缺点\n数据的存贮管理与应用均较复杂。\n\n\n\n\n\n\n合成孔径雷达\n通过对从不同空间位置获取的同一地区的两个雷达图像利用杨氏双狭缝光干涉原理进行处理，从而获得该地区的地形信息。\n具有SAR的全天候、大范围、有一定穿透能力等优点。\n具有对目标三维地貌进行高精度成像、对目标地面的慢速动目标和地壳微小移动作高精度检测等的能力。\n\n\n机载激光扫描数据采集\n工作原理主要是利用主动遥感的原理，机载激光扫描系统发射出激光信号，经由地面反射后到系统的接收器，通过计算发射信号和反射信号之间的相位差或时间差，来得到地面的地形信息。\n很少受气候条件影响，测量精度高，成为测绘困难地区（密集城区和森林地区）和物体（电力线等）的新兴技术。\n\n\nDEM数据的质量控制\nDEM数据质量\n指DEM数据在表达空间位置、高程和时间信息这三个基本要素时所能达到的准确性、一致性、完整性以及它们三者之间统一性的程度。\n\n\n质量控制\n减少数据采集时的误差引入\n对采集到的数据作误差处理以提高可靠性\n减少表面建模时的误差引入\n\n\n数据误差分类\n偶然误差\n系统误差\n粗差\n\n\n原始数据粗差检测与剔除\n基于趋势面的粗差探测与处理\n确定趋势面函数\n阈值问题（一般取三倍中误差为极限值）\n\n\n三维可视化粗差检测技术\n建立三维表面（一般为TIN）\n人机交互方式检测\n\n\n基于坡度信息的规则格网分布数据粗差探测技术\n坡度差计算（窗口）\n通过相邻两个网格之间的坡度差确定衡量坡度是否变化一致的阈值\n怀疑一点\n粗差剔除与数据点改正\n\n\n基于高程信息的不规则分布数据粗差探测方法\n窗口确定（规则、不规则包含个点）\n一致性标准确定\n\n\n基于等高线采样数据的粗差探测方法\n将所有等高线上的点作为离散点并用上述任何一种方法进行粗差剔除\n按等高线的拓扑关系进行粗差探测与剔除\n可视化检查\n\n\n等高线回放检查\n对原始采样数据点建立DEM\n在此DEM上提取等高线（保持等高距一致）\n将两等高线套合\n\n\n\n\n\n\nDEM数据共享和利用\n一些DEM数据的分辨率\n我国比例尺DEM\n七大江河区域：\n其他部分区域：\n\n\n我国比例尺DEM\n\n\n\n我国比例尺DEM\n\n\n\n\n我国比例尺DEM\n\n\n\n\n美国SRTM数据\nSRTM1：\nSRTM3：（可免费获取的中国境内的数据）\n\n\n美日ASTER GDEM数据\n\n\n\n\n\n\n\n\n格网DEM建立\n地形空间分布的特征\n各向异性\n自相关性\n\n\nDEM质量评价标准\n保凸性\n逼近面与实际曲面的波动次数相等或接近，而且两者对应的脊线、谷线位置和走向基本一致，则保凸性好，反之保凸性差。\n\n\n逼真性\n逼近面和实际地形曲面对应点之间满足关系式：。其中为实际地形曲面；为逼近面；为逼近的容许误差。\n在DEM中常常采用中误差的形式来衡量逼真性。\n\n\n光滑性\n光滑性：曲线上切线方向变化的连续性。将光滑曲线任意截成两段，两曲线在连接点处的斜率和曲率都相等。\n平顺性：曲线上没有太多的拐点，且不出现震荡。\n\n\n\n\nDEM建立的一般步骤\n采用合适的空间模型构造空间结构。\n采用合适的属性域函数。\n在空间结构中进行采样，构造空间域函数。\n利用空间域函数进行分析。\n\n\nDEM内插数学模型\n整体内插\n含义\n由研究区域内的所有采样点的观测值建立一个数学函数，来表达整个研究区域的地形。\n\n\n优点\n整个区域上函数唯一\n能得到全局光滑连续的DEM\n充分反映宏观地形特征\n\n\n缺点\n保凸性差\n不容易得到稳定的数值解\n高次多项式系数物理意义不明显\n解算速度慢且对计算机容量有较高要求\n不能提供内插区域的局部地形特征\n\n\n应用\n常用于揭示整个区域内地形宏观起伏态势\n与局部内插法配合使用\n地形采样数据的粗差检测\n\n\n\n\n局部分块内插\n基本思想\n将地形区域按一定的方法进行分块，对每一块根据地形曲面特征单独进行曲面拟合和高程内插，即DEM分块内插。\n\n\n典型方法\n线性内插\n基本思想\n将分块单元内的地形曲面视为平面。首先使用最靠近插值点的三个已知数据点确定一个平面，继而求出内插点的高程值的方法。基于TIN的内插广泛使用这种简便的方法。\n\n\n设所求函数形式为Z=a_0+a_1 x+a_2 y\n参数解算\\begin{bmatrix}a_0\\\\a_1\\\\a_2\\end{bmatrix}=\\begin{bmatrix}1&x_1&y_1\\\\1&x_2&y_2\\\\1&x_3&y_3\\end{bmatrix}^{-1}\\begin{bmatrix}z_1\\\\z_2\\\\z_3\\end{bmatrix}\n\n\n双线性多项式内插\n基本思想\n使用最靠近内插点的四个已知数据点组成一个四边形，进而确定一个双线性多项式来内插待插点的高程。基于格网的内插广泛采用该方法。\n\n\n设所求函数形式为\n\n\n\n参数解算\n\n\n\n\n\n\n\n\n\n逐点内插\n含义\n以内插点为中心，确定一个邻域范围，用落在邻域范围内的采样点计算内插点的高程值。又称移动曲面法。\n\n\n基本步骤\n定义内插点的邻域范围\n确定落在邻域内的采样点\n选定内插数学模型\n通过邻域内的采样点和内插数学模型计算内插点的高程\n\n\n\n\n规则格网DEM建立过程\n基于不规则分布采样点的DEM建立\n直接法\n邻域和邻域内点的确定\n搜索圆\n利用公式。其中为搜索圆初始半径；为包括所有采数据的区域面积；为采样点数据总个数；为数据量的平均值，一般为。\n\n\n搜索正方形\n利用公式。其中为搜索正方形初始边长；为区域面积；为采样点总数；为模型要求数据量的平均值，一般为。\n\n\n\n\n权值计算\n一般利用公式。其中为当前内插点；为采样点；为采样点的权值；为内插点和采样点之间的距离；一般取。\n\n\n内插函数模型\n设内插点坐标为；为邻域内采样点的个数；邻域内的采样点坐标分别为，其中；为采样点和内插点的距离；为采样点的权值。\n\n\n\n\n\n间接法\n线性内插\n精确拟合内插\n连续双5次多项式\n磨光内插\n\n\n\n\n基于规则格网分布采样点的DEM建立\n线性内插\n双线性内插\n三次样条函数\n\n\n基于等高线分布采样点的DEM建立\n等高线离散化法\n等高线内插法\n等高线构建TIN法\n\n\n\n\n不规则三角网（TIN）\n概念\n由空间中离散分布的不均匀点组成的三角网络模型。\n基于TIN的DEM就是用一系列互不交叉、互不重叠的连接在一起的三角形来表示地形表面。\n\n\n基本元素\n节点\n边\n面\n\n\n基本要求\nTIN是唯一的。\n力求最佳的三角形几何形状，每个三角形尽量接近等边形状。\n保证最邻近的点构成三角形，即三角形的边长之和最小。\n\n\n\n\nTIN三角剖分准则\n空外接圆准则\n过每个三角形的外接圆均不包含点集的其余任何点。\n\n\n最大最小角准则\n两相邻三角形形成的凸四边形中，这两个三角形中的最小内角一定大于交换凸四边形对角线后所形成的两三角形的最小内角。\n\n\n张角最大准则\n一点到基边的张角为最大。以上三者相互等价。\n\n\n最短距离和准则\n一点到基边的两端的距离和为最小。\n\n\n面积比准则\n三角形内切圆面积与三角形面积比或三角形面积与周长平方之比最小。\n\n\n对角线准则\n两三角形组成的凸四边形的两条对角线之比，这一准则的比值限定值须给定。即当计算值超过限定值才进行优化。\n\n\n\n\nDelaunay三角网（DT）\n概念\n通常将在空外接圆准则、最大最小角准则下进行的三角剖分称为Delaunay三角剖分。\n\n\n特性\n可最大限度得避免狭长三角形的出现。\n不管从何处开始构网都能保持三角形网络的唯一性。\n\n\nDelaunay法则\n也称空圆法则，即空外接圆准则。\n\n\nLOP法则\nLocal Optimal Procedure，局部优化过程。\n利用Delaunay法则（空外接圆准则）交换凸四边形的对角线，可获得等角性最好的三角网。\n\n\n\n\nTIN的建立算法\n不规则采样数据\n无约束数据\n三角网生长算法\n首三角形确定\n第一个点：任选接近几何中心的点\n第二个点：与距离最近的点\n第三个点：与连线中点距离最近的点、位于连线右侧、不在连线上\n\n\n从边寻找可能的扩展点\n利用直线方程及其正负区判别\n\n\n判断扩展点\n张角最大原则\n余弦定理\n\n\n检查重复边\n继续扩展三角形\n\n\n分割-合并算法\n以横坐标为第一关键字、纵坐标为第二关键字升序排列\n对数据点进行排序，目的是使子三角网不相互重叠和交叉。\n排序的方法可采用以递归方式进行的分割快速排序方法。\n\n\n计算每个子集的凸包（壳）\n凸包概念\n包含二维平面上的点集中所有点的最小凸多边形。\n\n\n格雷厄姆凸包生成算法\n找出点集中纵坐标最小的点。\n将和点集中其他各点用线段连接，并计算这些线段与水平线的夹角。\n按夹角为第一关键字，距离为第二关键字排序对数据点进行升序排序，设得到的序列为。\n依次连接所有点，得到一多边形。\n删除所有非多边形顶点的点，即得到凸包点集。\n\n\n\n\n子集的三角剖分及LOP优化\n查找连接凸包的底线和顶线\n由底线到顶线合并子三角网\n\n\n数据渐次插入算法\n基本思想\n将未处理的点加入到已经存在的Delaunay三角网中，每次插入一点，重新定义Delaunay三角网。\n\n\n主要方法\n从数据中取出一点加入到三角网中。\n搜寻包含该点的三角形，将该点与所在三角形三个顶点相连，形成三个三角形。\n由里到外应用Lawson LOP优化整个三角网。\n重复以上过程直到所有点处理完毕。\n删除所有包含一个或多个超三角形（包含所有数据点的初始三角形）顶点的三角形。\n\n\n\n\n\n\n约束数据\n带约束条件的Delaunay三角网\n无约束TIN\n有约束TIN\n边界约束\n内部约束\n\n\n特性\n可见性：保证线段为两三角形所共有\n空外接圆性质\n最大最小角性质\n局部优化性质：保证三角形为Delaunay三角形\n\n\n\n\n\n\n\n\n等高线采样数据\n基于等高线的三角网生成算法\n\n\n规则采样数据\n基于栅格的三角网生成算法\n\n\n\n\n激光测距技术（LiDAR）\n组成\n激光测距系统\n全球定位系统（GPS）\n惯性测量装置（IMU）\n\n\n\n\n\n\n\nDEM可视化表达\n地形一维可视化\n地形剖面\n\n\n地形二维可视化\n等高线法\n明暗等高线法\n分层设色法\n地形晕渲法\n\n\n地形三维可视化\n立体等高线模型\n三维线框透视模型\n地形三维表面模型\n\n\n地形三维景观模型\n地形场景漫游与动画\n\nDEM精度分析\n误差\n定义\n观测数据与其真值之间的差异。\n\n\n分类\n系统误差：由数据采集设备引起，一般表现为常数或函数特征。\n随机误差：由数据采集过程中的不确定性因素引起的，表现上无规律但服从统计学规律。\n粗差：操作过程中的粗心或不遵守规定引起的必须剔除的一种错误。\n\n\n\n\nDEM误差源\n地形表面特征\n数据源误差\n采点设备误差\n人为误差\n采样点密度和分布\n内插方法\nDEM数据结构\n\n\nDEM精度\n定义\n精度：误差分布的密集或离散程度。\nDEM精度：所建立的DEM对真实地面描述的准确程度。\n\n\n影响因素\n\n为DEM的精度\n为DEM表面的特征\n为DEM表面建模的方法\n为DEM表面自身的特征（粗糙度）\n、、为DEM原始数据的三个属性（精度、分布和密度）\n为其他要素\n\n\n精度指标\n误差；其中为真值，为观测值或计算值。\n平均误差。\n中误差。\n标准差。\nMoran指数；其中为相邻格网单元的权重，可按反距离关系定权，即（为相邻格网单元的距离，为任意实数）。，表示误差严格正相关，表示误差呈随机分布，表示误差严格负相关。\n\n\n\n\nDEM精度评定方法和精度模型\n检查点法和DEM中误差模型\n逼近分析和地形描述误差\n等高线套合分析和DEM定性评价模型\n实验方法和DEM经验模型\nDEM经验模型建立两个基本环节\n原始数据精确度评价\nDEM精度评定\n\n\n\n\n理论分析与理论模型\n\n\n\n坡面地形因子提取\n坡面因子的分类\n按空间区域范围分类\n微观\n坡度\n坡向\n坡度变率\n坡向变率\n平面曲率\n剖面曲率\n坡长\n\n\n宏观\n坡形因子\n地形粗糙度\n地形起伏度\n高程变异系数\n地表切割深度\n\n\n\n\n按提取算法分类\n一阶\n坡度\n坡向\n\n\n二阶\n坡度变率\n坡向变率\n平面曲率\n剖面曲率\n\n\n复合\n坡长\n坡形因子\n地形粗糙度\n地形起伏度\n高程变异系数\n地表切割深度\n\n\n\n\n\n\n坡面因子提取基本方法\n明确各个坡面因子的数学特征\n建立解译模型\n研究基于DEM的提取方法\n\n\n窗口分析\n基本原理\n对栅格数据系统中的一个、多个栅格点或全部数据，开辟一个固有分析半径的分析窗口，并在该窗口内进行诸如极值、均值、标准差等一系列统计运算，或进行差分及与其他层面信息的复合分析等。\n\n\n常见窗口\n矩形窗口\n圆形窗口\n环形窗口\n扇形窗口\n\n\n\n\nDEM格网数据的空间矢量表达\n格网的标准矢量\n\n\n\n高程变化率（表示DEM栅格大小）\n方向（正北方向）\n二阶差分\n\n\n\n三阶反距离平方权差分\n\n\n\n\n\n方向（正东方向）\n二阶差分\n\n\n\n三阶反距离平方权差分\n\n\n\n\n\n\n\n标准矢量的基本矢量\n平行于平面\n\n\n\n平行于平面\n\n\n\n\n\n微分地表单元法矢量\n\n\n\n\n\n\n坡面因子\n坡度\n定义：通过该点的切平面与水平地面的夹角。\n数学表达\n\n\n\n\n表示方式\n坡度：水平面与地形面之间的夹角，。\n坡度百分比：高程增量（rise）与水平增量（run）之比的百分数，。\n\n\n\n\n坡向\n定义：通过该点的切平面的法向量在水平面的投影与过该点的正北方向的夹角（从正北方向起按顺时针方向计算）。\n数学表达：\n\n\n坡形：局部地表坡面的曲折状态\n地面曲率因子\n定义：对地形表面一点扭曲变化程度的定量化度量因子。\n平面曲率（水平方向）：用过地形表面一点的水平面沿水平方向切地形表面所得的曲线在该点的曲率值。\n剖面曲率（垂直方向）：对地面坡度的沿最大坡降方向地面高程变化率的度量。\n\n\n地面变率因子\n坡度变率\n求原始DEM的坡度，得到坡度栅格。\n求的坡度，得到坡度变率栅格。\n\n\n坡向变率\n求原始DEM的坡向，得到坡向栅格。\n求的坡度，得到坡度变率栅格。\n用原始DEM的最大高程值减去原始DEM数据，得到反地形DEM。\n求反地形DEM的坡向，得到坡向栅格。\n求的坡度，得到坡度变率栅格。\n坡向变率计算公式。\n\n\n\n\n坡长\n定义：地面上一点沿水流方向到其流向起点间的最大地面距离在水平面上的投影长度。\n数学表达：；其中为坡长，为地表面沿流向的水流长度，为水流地区的地面坡度值。\n\n\n坡位：坡面所处的地貌部位\n地形起伏度：在指定区域内最大高程与最小高程之差\n地表粗糙度\n定义：地表单元的曲面面积与其水平面上的投影面积之比，是反映地表的起伏和侵蚀程度的指标。\n数学表达：曲面水平\n实际应用：选取分析的窗口，则。\n\n\n地表切割深度：某点的邻域范围的平均高程与该邻域范围内最小高程之差\n高程变异系数：反映分析区域内地表单元格网各顶点高程变化的指标\n\n\n\n特征地形要素的提取\n地形特征点\n山顶点：在各方向上都为凸起。\n凹陷点：在各方向上都为凹陷。\n脊点：在两个相互正交的方向上，一个凸起，一个没有凹凸性变化。\n谷点：在两个相互正交的方向上，一个凹陷，一个没有凹凸性变化。\n鞍点：在两个相互正交的方向上，一个凸起，一个凹陷。\n平地点：在各方向上都没有凹凸性变化。\n\n\n基于规则格网DEM数据提取山脊、谷线的典型算法\n基于图像处理技术的原理的算法\n基本思路\n提取地形特征点并将特征点连成特征线。\n\n\n主要过程\n设计一个的窗口。\n第一次扫描中将窗口中具有最低高程值的点进行标记，始终未被标记的点即为山脊线上的点。\n第二次扫描中将窗口中具有最高高程值的点进行标记，始终未被标记的点即为山谷线上的点。\n\n\n\n\n基于地形表面几何形态分析原理的算法\n基本思想\n地形断面曲线上高程的极大值点是分水点。\n地形断面曲线上高程的极小值点是汇水点。\n\n\n主要过程\n找出DEM的纵向与横向的两个断面上的极大值点、极小值点，作为地形特征线上的备选点。\n根据一定的条件或准则将这些备选点划归各自所属的地形特征线。\n\n\n\n\n基于地形表面流水物理模型分析原理的算法\n主要过程\n按照流水从高至低的自然规律，顺序计算每一栅格点上的汇水量。\n按汇水量单调增加的顺序，由高到低找出区域中的每一条汇水线。\n根据得到的汇水线，通过计算找出各自汇水区域的边界线，就得到了分水线。\n\n\n\n\n基于地形表面几何形态分析和流水物理模拟分析相结合的算法\n主要过程\n首先采用较稀疏的DEM格网数据，按流水物理模拟算法提取区域内概略的地形特征线。\n然后用其引导，在其周围邻近区域对地形进行几何分析，来精确地确定区域的地形特征线。\n\n\n\n\n平面曲率与坡位组合法\n主要过程\n利用DEM数据提取地面的平面曲率及地面的正负地形。\n取正地形上平面曲率的大值即为山脊线。\n取负地形上平面曲率的大值即为山谷线。\n\n\n\n\n\n\n沟沿线的提取\n水系的提取\n相关概念\n集水流域：水流及其他物质流向出口的过程中所流经的区域。\n集水出口：水流离开集水流域的点，这一点是集水流域边界上的最低点。\n子流域：较大的集水流域结构中的一部分。\n分水岭：两集水流域的边界。\n水流网络：水流到达积水出口所流经的网络结构。\n\n\n基于地表径流漫流模型的水系提取算法\n洼地的处理：种子算法\n确定洼地单元格。\n确定洼地单元格的集水区域。\n探测每一洼地集水区域的潜在出流点。\n\n\n平地的处理：高程叠加算法\n扫描经过洼地填充的DEM数据，搜寻八个邻域栅格高程都不低于该栅格点高程的栅格点，标记为平地单元。\n给搜索到的每一个平地栅格点都增加一个微小的增量（如栅格高程采样精度的十分之一、千分之一或万分之一）。\n重复上述过程，直到再也搜索不到平地单元。\n\n\n水流方向矩阵的计算：D8算法（单流向算法）\n将格网的八个邻域格编码，规定一个方向为后，顺时针定义水流方向的值为。\n计算中心栅格与邻域格网之间的距离权落差（中心格网与邻域格网的高程差值与两格网之间距离的比值），对角线方向上取倍格网间距，其他方向取倍格网间距。\n确定具有最大距离权落差值的方向。\n\n\n水流累积量矩阵的计算：迭代算法\n根据水流方向矩阵，对于当前单元格，跟踪其水流方向。\n除当前单元格外，路径上的所有单元格水流累积量加。\nPython实现如下dir = {    32: (-1, -1), 64: (-1, 0), 128: (-1, 1),    16: ( 0, -1),  0: ( 0, 0),   1: ( 0, 1),     8: ( 1, -1),  4: ( 1, 0),   2: ( 1, 1)}flowdir = [    [   2,   2,   2,   4,   4,   8],    [   2,   2,   2,   4,   4,   8],    [   1,   1,   2,   4,   8,   4],    [ 128, 128,   1,   2,   4,   8],    [   2,   2,   1,   4,   4,   4],    [   1,   1,   1,   1,   4,  16]]n = len(flowdir)    # Rowm = len(flowdir[0]) # Columnflowacc = [[0] * m for i in range(n)]for i in range(n):    for j in range(m):        x, y = i, j        while True:            tx = x + dir[flowdir[x][y]][0]            ty = y + dir[flowdir[x][y]][1]            if 0 &lt;= tx &lt; n and 0 &lt;= ty &lt; m:                flowacc[tx][ty] += 1                x, y = tx, ty            else:                breakfor i in range(n):    print(flowacc[i])\n\n\n水道起始位置的确定：最小水道给养面积阈值\n\n\n\n\n流域的提取\n根据DEM栅格单元和八个相邻的单元格之间的最大坡度来确定水流方向。\n计算每个单元格的上游汇流能力。\n确定一个汇流能力阈值，不低于该阈值的单元格标记为水系的组成部分。\n\n\n可视性分析\n判断两点之间可视性的算法\n确定过观察点和目标点所在线段与平面垂直的平面。\n求出地形模型中与平面所有相交的边。\n判断相交的边是否位于观察点和目标点所在的线段上，如果有一条边在其上，则观察点和目标点不可视。\n也可使用“射线追踪法”。\n\n\n计算可视域的算法\n基于规则格网DEM的可视域计算：并行处理\n基于TIN地形模型的可视域计算：类似于计算与三维场景中隐藏面消去问题\n\n\n可视性分析最基本的用途\n可视查询\n地形可视结构（可视域）计算\n水平可视计算\n\n\n\n\n\n","categories":["学科笔记"]},{"title":"2020年“美团杯”程序设计挑战赛 - 部分题解","url":"/posts/5749f38c/","content":"正赛N - 热身题原题面描述本次比赛的热身题是一道数独。作为热身题，欢迎大家在赛前讨论、并尝试用各种方式解决它。规则\n\n数字至在每行每列以及每个九宫格内部都必须出现恰好一次。\n对于每一条曲线，从带有圆球的一端开始，这条曲线严格经过（不包括角）的数字必须严格递增。\n\n在正式比赛开始后，热身题的提交将会开放：提交格式是一个行列空格隔开的数字矩阵，表示这个数独的一种填法。\n链接http://uoj.ac/contest/53/problem/532\n题解题意带特殊要求的标准数独。\n思路\n先从有递增要求的单元格开始枚举，所有特殊单元格枚举之后再从左上角填充至右下角。\n数独剪枝量很大，不必担心出不了结果。\n\n时间复杂度\nNPC问题\ndfs()共被调用次\n\n代码#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;utility&gt;using namespace std;int map[9][9] = {    0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 0, 0, 0, 1, 0, 0, 0, 0,    0, 0, 0, 0, 0, 8, 0, 0, 0,    0, 0, 0, 0, 0, 0, 9, 0, 0,    0, 0, 0, 0, 0, 0, 0, 8, 0,    0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 0, 0, 0, 0, 0, 0, 0, 0,    5, 0, 4, 0, 0, 0, 0, 0, 0};int pathID[9][9] = {0};bool vis[9][9] = {false};int zeros[81][2];vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; paths(8, vector&lt;pair&lt;int, int&gt; &gt;());int zeroCount, pathCount;void addZero(int x, int y) {    zeros[zeroCount][0] = x;    zeros[zeroCount][1] = y;    ++zeroCount;}void addPath(int x, int y) {    paths[pathCount].push_back(make_pair(x, y));    addZero(x, y);    vis[x][y] = true;}bool walk(int x, int y) {    int path = pathID[x][y];    if (!path)        return true;    --path;    if (!map[paths[path][0].first][paths[path][0].second])        return true;    for (int i = 1; i &lt; paths[path].size(); ++i) {        if (map[paths[path][i].first][paths[path][i].second]) {            if (map[paths[path][i].first][paths[path][i].second] &lt;= map[paths[path][i - 1].first][paths[path][i - 1].second])                return false;        } else            break;    }    return true;}bool dfs(int depth) {    if (depth == zeroCount) {        for (int i = 0; i &lt; 9; ++i) {            for (int j = 0; j &lt; 8; ++j)                printf(\"%d \", map[i][j]);            printf(\"%d\\n\", map[i][8]);        }        printf(\"\\n\");        return true;    }    int mask = 0, x = zeros[depth][0], y = zeros[depth][1];    for (int j = 0; j &lt; 9; ++j)        mask |= 1 &lt;&lt; map[x][j];    for (int i = 0; i &lt; 9; ++i)        mask |= 1 &lt;&lt; map[i][y];    for (int i = x / 3 * 3; i &lt;= x / 3 * 3 + 2; ++i)        for (int j = y / 3 * 3; j &lt;= y / 3 * 3 + 2; ++j)            mask |= 1 &lt;&lt; map[i][j];    for (int i = 1; i &lt;= 9; ++i)        if (!(mask &amp; 1 &lt;&lt; i)) {            map[x][y] = i;            if (walk(x, y) &amp;&amp; dfs(depth + 1))                return true;            map[x][y] = 0;        }    return false;}int main() {    zeroCount = pathCount = 0;    addPath(6, 0);    addPath(5, 0);    addPath(4, 0);    addPath(3, 0);    addPath(3, 1);    addPath(4, 2);    addPath(5, 1);    ++pathCount;    addPath(7, 3);    addPath(6, 3);    addPath(5, 3);    addPath(4, 3);    ++pathCount;    addPath(4, 5);    addPath(5, 4);    addPath(6, 5);    addPath(7, 5);    ++pathCount;    addPath(8, 7);    addPath(8, 6);    addPath(7, 6);    addPath(6, 6);    addPath(5, 6);    ++pathCount;    addPath(5, 8);    addPath(6, 8);    addPath(7, 8);    addPath(8, 8);    ++pathCount;    addPath(2, 3);    addPath(1, 3);    addPath(0, 3);    addPath(1, 4);    addPath(0, 5);    addPath(1, 5);    addPath(2, 5);    ++pathCount;    addPath(1, 8);    addPath(1, 7);    addPath(1, 6);    ++pathCount;    addPath(3, 7);    addPath(2, 7);    for (int i = 0; i &lt; 9; ++i)        for (int j = 0; j &lt; 9; ++j)            if (!vis[i][j] &amp;&amp; !map[i][j])                addZero(i, j);    for (int i = 0; i &lt;= pathCount; ++i)        for (int j = 0; j &lt; paths[i].size(); ++j)            pathID[paths[i][j].first][paths[i][j].second] = i + 1;    dfs(0);    return 0;}\n答案7 1 3 4 8 6 2 9 52 4 9 3 5 7 8 6 18 5 6 2 1 9 4 7 36 7 5 9 4 8 1 3 24 2 8 7 3 1 9 5 63 9 1 6 2 5 7 8 41 8 2 5 9 3 6 4 79 3 7 1 6 4 5 2 85 6 4 8 7 2 3 1 9\n正赛B - 图片解密原题面描述众所周知，有些时候需要进行一些花样才能把一张图片发出去。今天，蒜斜在网上冲浪的时候，突然发现了两个神秘的文件small.csv和large.csv。通过浏览相关的信息，他发现这两个文件是由两张图片分别用两种不同的方式加密而来的，但是具体的加密方法已经遗失在了时间的长河之中。因此，蒜斜希望你能帮他还原这两张图片，并告诉他这两张图片里蕴含的信息。两张图的信息都是只包含数字和大写字母的字符串。\nSmall Task提示：《大局观》。提交文件：picture1.out。\nLarge Task提示：新加坡樟宜机场大厅的时钟墙。提交文件：picture2.out。\n下载加密后的文件下载\n链接http://uoj.ac/contest/53/problem/520\n题解题意将两个csv文件里的数据通过一定方式转化成图片，从中读出显示的大写字母与数字。\nsmall.csv的解密\nsmall.csv里的数据虽然都以浮点数的形式显示，但不难发现只有0.000000000000000000e+00和1.000000000000000000e+00两种数值。\n用Excel打开small.csv，全选所有单元格，点击“条件格式”中的“突出显示单元格规则”，选择一种规则，如“大于”，文本框中输入0.5后点击“确定”。\n考虑到提示是“《大局观》”，但书名号是迷惑性的提示。“大局观”指要看事物的全部，将缩放调整为最小，即可看到大致的字符轮廓。\n也可以利用Python的matplotlib库绘制图像，参考代码如下：import matplotlib.pyplot as plta = list()with open(\"small.csv\") as f:    for line in f:        a.append([1 if x[0] == \"1\" else 0 for x in line.strip().split(\",\")])a.reverse()plt.pcolormesh(a, cmap=\"binary\")plt.axis(\"off\")plt.show()\n运行结果如下（白边已裁剪）：\n\nSmall Task答案JZ4WC3TPIFYGK\nlarge.csv的解密\n考虑到提示是“新加坡樟宜机场大厅的时钟墙”，百度搜索之，了解到这是用一个个时钟组成的字符画。\n观察large.csv中的数据，发现有一部分都是86400，结合提示，猜测这是一天的秒数。\n猜测large.csv中的每一个数据都是一天中的某一个秒数，将其用钟面表示出来即可拼接成一幅画。\n考虑到现实中时钟墙上没有秒针，猜测此处也无需绘制秒针。\n还是利用Python的matplotlib库绘制图像，规定时针为个单位长度，分针为个单位长度，参考代码如下：import mathimport matplotlib.pyplot as pltdef draw(x, y, minute):    m = minute % 60    h = minute // 60    am = math.radians(90 - m * 6)    ah = math.radians(90 - (h + m / 60) * 30)    plt.plot([x, x + math.cos(ah) * 2.5], [y, y + math.sin(ah) * 2.5], \"black\")    plt.plot([x, x + math.cos(am) * 5], [y, y + math.sin(am) * 5], \"black\")x = 5y = -5with open(\"large.csv\") as f:    for line in f:        for minutestr in line.strip().split(\",\"):            draw(x, y, int(minutestr) % 43200 // 60)            x += 10        y -= 10        x = 5plt.axis(\"off\")plt.show()\n运行结果如下（白边已裁剪）：\n\nLarge Task答案LZYYJFQHJZJT\n正赛C - 魔塔原题面背景蒜斜是个不折不扣的游戏狂魔。他的电脑上有款他最喜欢的游戏。每天早上起来，他会随机抽取两个到之间的整数，第一个数表示他今天要玩的游戏，第二个数表示他要通关的次数。运气最差的一次是他抽到了“点一下玩一年”的传奇霸业，所幸的是第二个数只有，不然他这辈子都通关不了。今天蒜斜抽到的游戏是魔塔，这是一款很经典的游戏，但是他玩了半天连第层都还没有通过。因此他求助北大算协的朋友把这个游戏放到了UOJ上——不知道此时此刻的你能否帮他一把？\n描述这个魔塔游戏有层，每一层地图的结构都完全一样，如下图所示：###################### Bb?Gr########### ############?RbR GgR?B??######### ############?GrG BGR?????######## ############?BgB G?G???Rb######## ############   R RrG?B???Bg## ? G ############P  B?RRRGGGBBB@##################每一个字符都代表了地图中的一个元素，其中：\n\nP字符表示玩家的位置，每一层开始的时候，玩家都处在左下角的位置。\n#表示墙壁，玩家移动的时候无法跨过墙壁。\nRGB分别表示红色，绿色，蓝色的门，玩家必须要消耗相同颜色的钥匙才能打开对应的门。门被打开之后将会从地图上消失。\nrgb分别表示红色，绿色，蓝色的钥匙，在到达钥匙所处在的格子后，玩家会自动捡起这把钥匙。钥匙被捡起后将会从地图上消失。\n?是一把随机的钥匙，在到达?所处在的格子之后，玩家将会获得一把随机颜色的钥匙，之后?会从地图上消失。\n@是终点，当玩家碰到终点的时候就会进入下一层。\n\n在每一层游戏开始的时候，你身上没有任何钥匙。你的目标是到达字符@的位置从而进入下一层。Small Task: 你需要达到游戏的第层。Large Task: 你需要达到游戏的第层。\n游戏文件在本题最下方的下载链接中，你可以下载到魔塔游戏的可执行文件。请根据你电脑的系统挑选对应的可执行文件运行。游戏开始时，你需要输入我们下发给你们队伍的随机种子，来表明解题人身份。如果你使用了别的随机种子，将会导致答案被判错或者比赛被判作弊。UPD: 比赛结束了，你可以使用随机种子99565380来做这个题。在输入随机种子之后，游戏正式开始。游戏的界面如下图所示：Level: 1Answer to the small task: Unlock after reaching level 2.Answer to the large task: Unlock after reaching level 100.###################### Bb?Gr########### ############?RbR GgR?B??######### ############?GrG BGR?????######## ############?BgB G?G???Rb######## ############   R RrG?B???Bg## ? G ############P  B?RRRGGGBBB@##################You keep 0 red keys, 0 blue keys, 0 green keysPlease enter your choice (move: WASD, restart: R):每一步，你可以使用的操作有：\n\n输入WSAD来上下左右移动玩家。移动的时候可能会发生的情况有\n移动的目标位置是空地，则字符P会移动到目标位置。\n移动的目标位置是一把钥匙，则钥匙会被捡起，同时P会移动到目标位置。\n移动的目标位置是一扇门且你有对应颜色的钥匙，则门会被打开，你会消耗一把对应的颜色的钥匙且P会移动到目标位置。\n移动的目标位置是墙壁或者一扇你没有对应颜色钥匙的门，则不会发生任何变化，P也不会发生改变。\n移动的目标位置是@，则地图会被重置成初始的样子，且地图上方的Level数会增加一。\n\n\n输入R来重置当前层。此时地图会被重置成最开始样子，?钥匙也会被重新随机。按R不会重置楼层数，即在Level: 10时按下R重置之后玩家仍然处在Level: 10。\n\n在玩家第一次到达Level: 2的时候，游戏会在相同目录下自动生成文件small.ans；在玩家第一次达到Level: 100的时候，会自动生成文件large.ans。提交small.ans可以获得分，提交large.ans可以获得分。注意，在提交的时候需要把对应的文件改名为tower1.out。在游戏过程中，你最多只能进行步操作：即，向游戏输入的WASDR字符的总数不能超过。操作数大于这个上界的提交将会被视为错误，并无法得分。\n其他补充信息small.ans和large.ans是在到达对应楼层的时刻生成的，且之后不会进行更新。因此在到达对应楼层之后强制让游戏退出并不会影响答案文件的生成。游戏流程不会进行保存，因此如果游戏过程中断了，下一次运行的时候将从Level: 1重新开始。在某些系统上下发的程序可能不具有可执行权限，你可能需要用chmod指令来给出对应的权限。请使用MacOS的同学尽量使用命令行来打开可执行文件，而不要双击打开。如果你的电脑系统比较小众导致下发的所有可执行文件都无法正常运行，我们深表遗憾。在这种情况下，你可以使用阿里云等云服务器来获得可以运行这些可执行文件的环境。\n下载游戏下载\n链接http://uoj.ac/contest/53/problem/521https://h5mota.com/games/MTCup2020C/\n题解题意一个命令行魔塔游戏，相较于一般魔塔这个不存在战斗内容，而是收集钥匙开门，但有些钥匙是不确定颜色的。\n思路\n我们队的随机种子是55004073，输入种子发现一直在获得蓝色钥匙，连第一层都过不了。\n重开游戏后反复输入DWR（右、上、重置）次，得到前次的随机钥匙为bbbbbgbbbgrbbrgbrbrg。\n重复上一个步骤，发现不管获得哪把随机钥匙，其序列的前位始终为bbbbbgbbbgrbbrgbrbrg。\n由此猜测，每获取一把随机钥匙，其颜色是由刚开始输入的随机种子决定的。\n至此，每一把钥匙的颜色都是确定的了，用搜索算法即可寻找一种通关的方法。\n唯一的难点是如何与命令行程序进行交互。这里用Python的subprocess库中的Popen函数。\n\n命令行程序交互\nPython提供了subprocess库，可以方便地创建子进程以及与其进行交互。\nsubprocess库的引入from subprocess import PIPE, Popen\n运行命令f = Popen(\"tower_win32.exe\", shell=True, stdin=PIPE, stdout=PIPE)\n\n\"tower_win32.exe\"为要打开的命令行程序的文件名，也可以是其他命令如ping。\nshell=True为在命令行中执行前面的命令。\nstdin=PIPE与stdout=PIPE为分别创建一个新的管道并接入标准输入和标准输出，用于输入和读出。\n\n\n读出def read():    return f.stdout.readline().decode(\"utf-8\").strip()\n\nf.stdout.readline()返回类型为bytes，将其以UTF-8方式解码则可以得到命令输出的字符串。\nstrip()函数用于去除字符串头尾的空字符（空格、回车、换行符等）。\n\n\n输入def write(s):    f.stdin.write((str(s) + \"\\r\\n\").encode(\"utf-8\"))    f.stdin.flush()\n\n输入的字符串需要在结尾加入回车\\r与换行符\\n（Windows系统）以避免错误。\nf.stdin.write()接受的参数也为bytes类型，编码方式与读出的保持一致即可。\nf.stdin.flush()用于刷新输入缓存区。\n\n\n结束进程f.terminate()f.wait()\n\nf.terminate()用于发送SIGTERM信号给子进程。\nf.wait()用于等待子进程结束。\n以上两行一起使用可以防止产生僵尸进程。\n\n\n\n代码import copy, refrom subprocess import PIPE, PopenN = 13M = 17DIR = {\"D\": [0, 1], \"A\": [0, -1], \"S\": [1, 0], \"W\": [-1, 0]}MAP = [    list(\"#################\"),    list(\"##### Bb?Gr######\"),    list(\"##### ###########\"),    list(\"#?RbR GgR?B??####\"),    list(\"##### ###########\"),    list(\"#?GrG BGR?????###\"),    list(\"##### ###########\"),    list(\"#?BgB G?G???Rb###\"),    list(\"##### ###########\"),    list(\"#   R RrG?B???Bg#\"),    list(\"# ? G ###########\"),    list(\"#P  B?RRRGGGBBB@#\"),    list(\"#################\")]SX = 11SY = 1EX = 11EY = 15SEED = 99565380MAX_KEYS = 5000MAX_LEVEL = 100f = Noneditu = copy.deepcopy(MAP)keys = \"\"finalrandcnt = 0finalpath = \"\"vis = set()def read():    return f.stdout.readline().decode(\"utf-8\").strip()def write(s):    f.stdin.write((str(s) + \"\\r\\n\").encode(\"utf-8\"))    f.stdin.flush()def getKeys(count):    global f, keys    f = Popen(\"tower_win32.exe\", shell=True, stdin=PIPE, stdout=PIPE)    read()    write(SEED)    for _ in range(count):        for __ in range(22):            read()        write(\"D\")        for __ in range(21):            read()        write(\"W\")        for __ in range(19):            read()        match = re.match(r\"You keep (\\d) red keys, (\\d) blue keys, (\\d) green keys\", read())        if match.group(1) == \"1\":            keys += \"r\"        elif match.group(2) == \"1\":            keys += \"b\"        elif match.group(3) == \"1\":            keys += \"g\"        else:            keys += \"?\" # Something went wrong...        read()        write(\"R\")    f.terminate()    f.wait()def dfs(x, y, randcnt, r, g, b, R, G, B, path):    global vis, finalrandcnt, finalpath, ditu    curStatus = chr(x) + chr(y) + chr(r) + chr(g) + chr(b) + chr(R) + chr(G) + chr(B)    if curStatus in vis:        return False    vis.add(curStatus)    if x == EX and y == EY:        finalpath = path        finalrandcnt = randcnt        return True    for k, v in DIR.items():        tx = x + v[0]; ty = y + v[1]        if tx &gt;= 0 and tx &lt; N and ty &gt;= 0 and ty &lt; M and ditu[tx][ty] != \"#\":            if ditu[tx][ty] == \" \" or ditu[tx][ty] == \"@\":                if dfs(tx, ty, randcnt, r, g, b, R, G, B, path + k):                    return True            elif ditu[tx][ty] == \"?\":                ditu[tx][ty] = \" \"                if dfs(tx, ty, randcnt + 1, r + int(keys[randcnt] == \"r\"), g + int(keys[randcnt] == \"g\"), b + int(keys[randcnt] == \"b\"), R, G, B, path + k):                    return True                ditu[tx][ty] = \"?\"            elif ditu[tx][ty] == \"r\":                ditu[tx][ty] = \" \"                if dfs(tx, ty, randcnt, r + 1, g, b, R, G, B, path + k):                    return True                ditu[tx][ty] = \"r\"            elif ditu[tx][ty] == \"g\":                ditu[tx][ty] = \" \"                if dfs(tx, ty, randcnt, r, g + 1, b, R, G, B, path + k):                    return True                ditu[tx][ty] = \"g\"            elif ditu[tx][ty] == \"b\":                ditu[tx][ty] = \" \"                if dfs(tx, ty, randcnt, r, g, b + 1, R, G, B, path + k):                    return True                ditu[tx][ty] = \"b\"            elif ditu[tx][ty] == \"R\" and r &gt; 0:                ditu[tx][ty] = \" \"                if dfs(tx, ty, randcnt, r - 1, g, b, R - 1, G, B, path + k):                    return True                ditu[tx][ty] = \"R\"            elif ditu[tx][ty] == \"G\" and g &gt; 0:                ditu[tx][ty] = \" \"                if dfs(tx, ty, randcnt, r, g - 1, b, R, G - 1, B, path + k):                    return True                ditu[tx][ty] = \"G\"            elif ditu[tx][ty] == \"B\" and b &gt; 0:                ditu[tx][ty] = \" \"                if dfs(tx, ty, randcnt, r, g, b - 1, R, G, B - 1, path + k):                    return True                ditu[tx][ty] = \"B\"    return Falsedef main():    getKeys(MAX_KEYS)    global keys, ditu, finalrandcnt, f    f = Popen(\"tower_win32.exe\", shell=True, stdin=PIPE, stdout=PIPE)    read()    write(SEED)    for lv in range(MAX_LEVEL):        ditu = copy.deepcopy(MAP)        print(\"level = {}, finalrandcnt = {}\".format(lv + 1, finalrandcnt))        for i in range(finalrandcnt, len(keys) - 22):            print(i)            vis.clear()            if dfs(SX, SY, i, 0, 0, 0, 10, 12, 11, \"\"):                read()                print(finalpath)                for c in finalpath:                    for _ in range(21):                        read()                    write(c)                break            for _ in range(22):                read()            write(\"D\")            for _ in range(21):                read()            write(\"W\")            for _ in range(21):                read()            write(\"R\")    f.terminate()    f.wait()if __name__ == \"__main__\":    main()\n正赛F - 程序解密原题面描述今天晚上有程序设计课的DDL，但是蒜斜的程设作业还一个空格都没有打过——因为他的魔塔还没有通关……于是蒜斜打算向他的好朋友镁团求助。镁团很愿意帮忙，所以他将自己的两个程序small.cpp和large.cpp用以下方式加密后发给了蒜斜：\n\n读入原程序中的所有字符，包括空格与换行。这样就得到了一个字符串。\n把中的每一个字符都替换成它的ASCII码，这样就得到了一个数字序列。\n随机生成一个的排列，并把所有的替换成，这样就得到了数字数列。\n把输出到密文文件中。\n\n现在给出这两个程序的加密结果small.encode、large.encode。你需要帮助蒜斜还原出这两个程序原本的功能，以帮助他完成作业。为了帮助你解密，蒜斜还额外提供了作业里的样例输入输出small.in、small.out、large.in、large.out：\n\n已知small.cpp在输入small.in的时候会输出small.out。\n已知large.cpp在输入large.in的时候会输出large.out。\n\n提交方式你提交的程序需要把small.cpp与large.cpp合并到一起：输入的第一行包含一个整数，当的时候，你的程序需要执行small.cpp的功能；当的时候，你的程序需要执行large.cpp的功能。\n时空限制\n时间限制：\n空间限制：\n\n下载加密后的程序以及运行样例下载\n链接http://uoj.ac/contest/53/problem/524\n题解题意一个可以正常运行的cpp代码文件中的每个字符的ASCII码与中的某一个数存在唯一对应关系，即同一个ASCII码只对应一个中的一个数。给出映射后的序列，要求将其翻译成可以正常运行的cpp代码。\nsmall.cpp的翻译\n源文件内容：189 169 118 191 220 109 223 140 82 45 169 112 93 145 33 140 49 252 113 255 109 93 169 118 84 82 118 49 252 140 93 155 49 191 140 82 93 145 223 99 255 189 223 140 224 169 118 140 82 154 82 166 102 102 102 255 169 118 145 82 36 11 154 198 99 255 169 118 145 82 118 99 255 169 118 145 82 252 49 169 118 174 208 82 203 255 219 191 169 118 82 113 113 82 118 99 255 219 224 112 33 82 174 169 118 145 82 169 82 244 82 166 99 82 169 82 45 244 82 118 99 82 162 162 169 208 82 203 255 219 219 191 169 118 82 113 113 82 36 11 169 198 99 255 219 7 255 219 169 118 145 82 33 140 93 109 220 145 82 244 82 102 99 255 219 224 112 33 82 174 169 118 145 82 169 82 244 82 166 99 82 169 82 45 244 82 118 99 82 162 162 169 208 82 203 255 219 219 224 112 33 82 174 169 118 145 82 141 82 244 82 169 82 162 82 166 99 82 141 82 45 244 82 118 99 82 162 162 141 208 82 203 255 219 219 219 169 224 82 174 36 11 169 198 82 113 82 36 11 141 198 208 82 203 255 219 219 219 219 33 140 93 109 220 145 82 162 244 82 174 169 82 77 82 141 208 99 255 219 219 219 7 255 219 219 7 255 219 7 255 219 191 112 109 145 82 45 45 82 33 140 93 109 220 145 82 45 45 82 140 118 223 220 99 255 7 \n猜测最后的7为}，255为\\n（换行符）。替换结果为：189 169 118 191 220 109 223 140 82 45 169 112 93 145 33 140 49 252 113 109 93 169 118 84 82 118 49 252 140 93 155 49 191 140 82 93 145 223 99 189 223 140 224 169 118 140 82 154 82 166 102 102 102 169 118 145 82 36 11 154 198 99 169 118 145 82 118 99 169 118 145 82 252 49 169 118 174 208 82 203 219 191 169 118 82 113 113 82 118 99 219 224 112 33 82 174 169 118 145 82 169 82 244 82 166 99 82 169 82 45 244 82 118 99 82 162 162 169 208 82 203 219 219 191 169 118 82 113 113 82 36 11 169 198 99 219 }219 169 118 145 82 33 140 93 109 220 145 82 244 82 102 99219 224 112 33 82 174 169 118 145 82 169 82 244 82 166 99 82 169 82 45 244 82 118 99 82 162 162 169 208 82 203219 219 224 112 33 82 174 169 118 145 82 141 82 244 82 169 82 162 82 166 99 82 141 82 45 244 82 118 99 82 162 162 141 208 82 203219 219 219 169 224 82 174 36 11 169 198 82 113 82 36 11 141 198 208 82 203219 219 219 219 33 140 93 109 220 145 82 162 244 82 174 169 82 77 82 141 208 99219 219 219 }219 219 }219 }219 191 112 109 145 82 45 45 82 33 140 93 109 220 145 82 45 45 82 140 118 223 220 99}\n还是很有C++程序的样子的。观察到第16至18行右大括号的前面的219存在递减规律，猜测为\\t（制表符Tab）。替换结果为：189 169 118 191 220 109 223 140 82 45 169 112 93 145 33 140 49 252 113 109 93 169 118 84 82 118 49 252 140 93 155 49 191 140 82 93 145 223 99 189 223 140 224 169 118 140 82 154 82 166 102 102 102 169 118 145 82 36 11 154 198 99 169 118 145 82 118 99 169 118 145 82 252 49 169 118 174 208 82 203 \t191 169 118 82 113 113 82 118 99 \t224 112 33 82 174 169 118 145 82 169 82 244 82 166 99 82 169 82 45 244 82 118 99 82 162 162 169 208 82 203 \t\t191 169 118 82 113 113 82 36 11 169 198 99 \t}\t169 118 145 82 33 140 93 109 220 145 82 244 82 102 99 \t224 112 33 82 174 169 118 145 82 169 82 244 82 166 99 82 169 82 45 244 82 118 99 82 162 162 169 208 82 203 \t\t224 112 33 82 174 169 118 145 82 141 82 244 82 169 82 162 82 166 99 82 141 82 45 244 82 118 99 82 162 162 141 208 82 203 \t\t\t169 224 82 174 36 11 169 198 82 113 82 36 11 141 198 208 82 203 \t\t\t\t33 140 93 109 220 145 82 162 244 82 174 169 82 77 82 141 208 99 \t\t\t}\t\t}\t}\t191 112 109 145 82 45 45 82 33 140 93 109 220 145 82 45 45 82 140 118 223 220 99 }\n第19行像一个语句，猜测结尾的99为;。替换结果为：189 169 118 191 220 109 223 140 82 45 169 112 93 145 33 140 49 252 113 109 93 169 118 84 82 118 49 252 140 93 155 49 191 140 82 93 145 223 ;189 223 140 224 169 118 140 82 154 82 166 102 102 102 169 118 145 82 36 11 154 198 ;169 118 145 82 118 ;169 118 145 82 252 49 169 118 174 208 82 203 \t191 169 118 82 113 113 82 118 ;\t224 112 33 82 174 169 118 145 82 169 82 244 82 166 ;82 169 82 45 244 82 118 ;82 162 162 169 208 82 203 \t\t191 169 118 82 113 113 82 36 11 169 198 ;\t}\t169 118 145 82 33 140 93 109 220 145 82 244 82 102 ;\t224 112 33 82 174 169 118 145 82 169 82 244 82 166 ;82 169 82 45 244 82 118 ;82 162 162 169 208 82 203 \t\t224 112 33 82 174 169 118 145 82 141 82 244 82 169 82 162 82 166 ;82 141 82 45 244 82 118 ;82 162 162 141 208 82 203 \t\t\t169 224 82 174 36 11 169 198 82 113 82 36 11 141 198 208 82 203 \t\t\t\t33 140 93 109 220 145 82 162 244 82 174 169 82 77 82 141 208 ;\t\t\t}\t\t}\t}\t191 112 109 145 82 45 45 82 33 140 93 109 220 145 82 45 45 82 140 118 223 220 ;}\n观察到部分语句结尾没有分号，猜测结尾的203为{。替换结果为：189 169 118 191 220 109 223 140 82 45 169 112 93 145 33 140 49 252 113 109 93 169 118 84 82 118 49 252 140 93 155 49 191 140 82 93 145 223 ;189 223 140 224 169 118 140 82 154 82 166 102 102 102 169 118 145 82 36 11 154 198 ;169 118 145 82 118 ;169 118 145 82 252 49 169 118 174 208 82 {\t191 169 118 82 113 113 82 118 ;\t224 112 33 82 174 169 118 145 82 169 82 244 82 166 ;82 169 82 45 244 82 118 ;82 162 162 169 208 82 {\t\t191 169 118 82 113 113 82 36 11 169 198 ;\t}\t169 118 145 82 33 140 93 109 220 145 82 244 82 102 ;\t224 112 33 82 174 169 118 145 82 169 82 244 82 166 ;82 169 82 45 244 82 118 ;82 162 162 169 208 82 {\t\t224 112 33 82 174 169 118 145 82 141 82 244 82 169 82 162 82 166 ;82 141 82 45 244 82 118 ;82 162 162 141 208 82 {\t\t\t169 224 82 174 36 11 169 198 82 113 82 36 11 141 198 208 82 {\t\t\t\t33 140 93 109 220 145 82 162 244 82 174 169 82 77 82 141 208 ;\t\t\t}\t\t}\t}\t191 112 109 145 82 45 45 82 33 140 93 109 220 145 82 45 45 82 140 118 223 220 ;}\n猜测第6行为main函数，并且169 118 145 82在多处出现，猜测为int（82为空格）。替换结果为：189 in191 220 109 223 140  45 i112 93 t33 140 49 252 113 109 93 in84  n49 252 140 93 155 49 191 140  93 t223 ;189 223 140 224 in140  154  166 102 102 102 int 36 11 154 198 ;int n;int 252 49 in174 208  {\t191 in 113 113  n;\t224 112 33  174 int i 244  166 ; i 45 244  n; 162 162 i208  {\t\t191 in 113 113  36 11 i198 ;\t}\tint 33 140 93 109 220 t 244  102 ;\t224 112 33  174 int i 244  166 ; i 45 244  n; 162 162 i208  {\t\t224 112 33  174 int 141  244  i 162  166 ; 141  45 244  n; 162 162 141 208  {\t\t\ti224  174 36 11 i198  113  36 11 141 198 208  {\t\t\t\t33 140 93 109 220 t 162 244  174 i 77  141 208 ;\t\t\t}\t\t}\t}\t191 112 109 t 45 45  33 140 93 109 220 t 45 45  140 n223 220 ;}\n补齐第6行，252为m，49为a，174为(，208为)。替换结果为：189 in191 220 109 223 140  45 i112 93 t33 140 am113 109 93 in84  nam140 93 155 a191 140  93 t223 ;189 223 140 224 in140  154  166 102 102 102 int 36 11 154 198 ;int n;int main() {\t191 in 113 113  n;\t224 112 33  (int i 244  166 ; i 45 244  n; 162 162 i) {\t\t191 in 113 113  36 11 i198 ;\t}\tint 33 140 93 109 220 t 244  102 ;\t224 112 33  (int i 244  166 ; i 45 244  n; 162 162 i) {\t\t224 112 33  (int 141  244  i 162  166 ; 141  45 244  n; 162 162 141 ) {\t\t\ti224  (36 11 i198  113  36 11 141 198 ) {\t\t\t\t33 140 93 109 220 t 162 244  (i 77  141 );\t\t\t}\t\t}\t}\t191 112 109 t 45 45  33 140 93 109 220 t 45 45  140 n223 220 ;}\n观察到第8行与第12行在括号内存在两个;，猜测为for循环语句，224 112 33为for，并猜测244为=。替换结果为：189 in191 220 109 223 140  45 io93 tr140 am113 109 93 in84  nam140 93 155 a191 140  93 t223 ;189 223 140 fin140  154  166 102 102 102 int 36 11 154 198 ;int n;int main() {\t191 in 113 113  n;\tfor (int i = 166 ; i 45 = n; 162 162 i) {\t\t191 in 113 113  36 11 i198 ;\t}\tint r140 93 109 220 t = 102 ;\tfor (int i = 166 ; i 45 = n; 162 162 i) {\t\tfor (int 141  = i 162  166 ; 141  45 = n; 162 162 141 ) {\t\t\tif (36 11 i198  113  36 11 141 198 ) {\t\t\t\tr140 93 109 220 t 162 = (i 77  141 );\t\t\t}\t\t}\t}\t191 o109 t 45 45  r140 93 109 220 t 45 45  140 n223 220 ;}\n猜测第1行为头文件引用，补齐#include。替换结果为：#include 45 io93 tream113 u93 in84  name93 155 ace 93 td;#define 154  166 102 102 102 int 36 11 154 198 ;int n;int main() {\tcin 113 113  n;\tfor (int i = 166 ; i 45 = n; 162 162 i) {\t\tcin 113 113  36 11 i198 ;\t}\tint re93 ult = 102 ;\tfor (int i = 166 ; i 45 = n; 162 162 i) {\t\tfor (int 141  = i 162  166 ; 141  45 = n; 162 162 141 ) {\t\t\tif (36 11 i198  113  36 11 141 198 ) {\t\t\t\tre93 ult 162 = (i 77  141 );\t\t\t}\t\t}\t}\tcout 45 45  re93 ult 45 45  endl;}\n第7行与第19行分别为cin输入与cout输出，后面跟着的两个相同的字符应该是&gt;&gt;与&lt;&lt;。替换结果为：#include &lt;io93 tream&gt;u93 in84  name93 155 ace 93 td;#define 154  166 102 102 102 int 36 11 154 198 ;int n;int main() {\tcin &gt;&gt; n;\tfor (int i = 166 ; i &lt;= n; 162 162 i) {\t\tcin &gt;&gt; 36 11 i198 ;\t}\tint re93 ult = 102 ;\tfor (int i = 166 ; i &lt;= n; 162 162 i) {\t\tfor (int 141  = i 162  166 ; 141  &lt;= n; 162 162 141 ) {\t\t\tif (36 11 i198  &gt; 36 11 141 198 ) {\t\t\t\tre93 ult 162 = (i 77  141 );\t\t\t}\t\t}\t}\tcout &lt;&lt; re93 ult &lt;&lt; endl;}\n至此可以看出第1行的头文件为iostream，第2行为using namespace std;，补齐。替换结果为：#include &lt;iostream&gt;using namespace std;#define 154  166 102 102 102 int 36 11 154 198 ;int n;int main() {\tcin &gt;&gt; n;\tfor (int i = 166 ; i &lt;= n; 162 162 i) {\t\tcin &gt;&gt; 36 11 i198 ;\t}\tint result = 102 ;\tfor (int i = 166 ; i &lt;= n; 162 162 i) {\t\tfor (int 141  = i 162  166 ; 141  &lt;= n; 162 162 141 ) {\t\t\tif (36 11 i198  &gt; 36 11 141 198 ) {\t\t\t\tresult 162 = (i 77  141 );\t\t\t}\t\t}\t}\tcout &lt;&lt; result &lt;&lt; endl;}\n观察第3至4行，猜测第3行为将一个字母宏定义为一个数，字母可以任意，假设为N；第4行为一个数组的定义，数组名可以任意，假设为x。替换结果为：#include &lt;iostream&gt;using namespace std;#define N 166 102 102 102 int x[N];int n;int main() {\tcin &gt;&gt; n;\tfor (int i = 166 ; i &lt;= n; 162 162 i) {\t\tcin &gt;&gt; x[i];\t}\tint result = 102 ;\tfor (int i = 166 ; i &lt;= n; 162 162 i) {\t\tfor (int 141  = i 162  166 ; 141  &lt;= n; 162 162 141 ) {\t\t\tif (x[i] &gt; x[141 ]) {\t\t\t\tresult 162 = (i 77  141 );\t\t\t}\t\t}\t}\tcout &lt;&lt; result &lt;&lt; endl;}\n观察small.in文件，开头的10会被读入至n中，猜测接下来一行个数会全部被依次读入x数组内。猜测166为1，162为+。替换结果为：#include &lt;iostream&gt;using namespace std;#define N 1102 102 102 int x[N];int n;int main() {\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; ++i) {\t\tcin &gt;&gt; x[i];\t}\tint result = 102 ;\tfor (int i = 1; i &lt;= n; ++i) {\t\tfor (int 141  = i + 1; 141  &lt;= n; ++141 ) {\t\t\tif (x[i] &gt; x[141 ]) {\t\t\t\tresult += (i 77  141 );\t\t\t}\t\t}\t}\tcout &lt;&lt; result &lt;&lt; endl;}\n猜测第3至4行中141表示一个循环计数变量，变量名可以任意，假设j。替换结果为：#include &lt;iostream&gt;using namespace std;#define N 1102 102 102 int x[N];int n;int main() {\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; ++i) {\t\tcin &gt;&gt; x[i];\t}\tint result = 102 ;\tfor (int i = 1; i &lt;= n; ++i) {\t\tfor (int j = i + 1; j &lt;= n; ++j) {\t\t\tif (x[i] &gt; x[j]) {\t\t\t\tresult += (i 77  j);\t\t\t}\t\t}\t}\tcout &lt;&lt; result &lt;&lt; endl;}\n剩下的102与77未知，但可以确定的是前者为数字，后者为双目运算符。由于N的展开值不影响代码运行，此处设为10。枚举两者所有可能情况即可。枚举代码如下：#include &lt;iostream&gt;using namespace std;#define N 10int a[N], n;char const op[] = \"%&amp;*-/^|\"; // 所有未出现过的单字符双目运算符int ans;int calc(int a, int b, char op) {    if (b == 0 &amp;&amp; (op == '%' || op == '/'))        return 0;    switch (op) {        case '%': return a % b;        case '&amp;': return a &amp; b;        case '*': return a * b;        case '-': return a - b;        case '/': return a / b;        case '^': return a ^ b;        case '|': return a | b;    }    return 0;}void read() {    freopen(\"small.in\", \"r\", stdin);    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++i) {        cin &gt;&gt; a[i];    }    freopen(\"small.out\", \"r\", stdin);    cin &gt;&gt; ans;}void work() {    for (int numi = 0; numi &lt;= 9; ++numi)        for (int opi = 0; opi &lt; 10; ++opi) {            int result = numi;            for (int i = 1; i &lt;= n; ++i) {                for (int j = i + 1; j &lt;= n; ++j) {                    if (a[i] &gt; a[j]) {                        result += calc(i, j, op[opi]);                    }                }            }            if (result == ans) {                printf(\"102=%d 77=%c\\n\", numi, op[opi]);                return;            }        }}int main() {    read();    work();    return 0;}\n以上代码运行结果为102=0 77=^，翻译完成。\n\nsmall.cpp代码#include &lt;iostream&gt;using namespace std;#define N 1000int x[N];int n;int main() {\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; ++i) {\t\tcin &gt;&gt; x[i];\t}\tint result = 0;\tfor (int i = 1; i &lt;= n; ++i) {\t\tfor (int j = i + 1; j &lt;= n; ++j) {\t\t\tif (x[i] &gt; x[j]) {\t\t\t\tresult += (i ^ j);\t\t\t}\t\t}\t}\tcout &lt;&lt; result &lt;&lt; endl;}\nlarge.cpp的翻译\n大致流程与small.cpp的翻译一样，目视解译成果如下：/* This is a comment*/int weight[]={7 175 146 146 241 175 241 89 7 ,175 89 198 241 252 198 242 175 ,89 175 242 175 252 89 242 123 198 ,146 198 252 85 175 252 7 241 146 ,242 85 241 175 241 146 146 242 85 ,175 146 89 242 198 241 175 198 85 ,146 89 241 241 146 89 146 89 85 ,85 175 89 241 252 175 85 146 89 ,146 89 7 123 198 241 252 7 241 ,175 198 123 7 175 175 85 123 198 ,198 7 89 252 85 242 85 146 ,89 198 198 7 252 85 242 198 123 ,7 175 198 7 252 123 241 242 175 ,7 175 89 198 175 85 241 7 242 ,198 241 146 7 241 89 89 252 242 ,252 252 198 146 252 241 7 146 146 ,7 242 146 252 241 89 242 123 123 ,146 241 146 252 252 146 123 241 7 ,89 241 7 242 85 175 85 146 241 ,252 85 252 175 7 85 252 241 85 ,242 198 252 123 146 242 85 7 ,85 175 241 123 252 7 241 7 252 ,123 123 89 175 175 85 241 242 7 ,175 89 198 175 242 146 89 242 198 ,252 241 242 241 7 242 175 252 241 242 ,123 241 7 146 7 241 198 241 252 ,85 85 242 7 241 7 252 175 242 ,123 146 175 89 175 198 85 252 175 ,89 241 198 242 252 85 85 198 7 ,198 198 241 241 252 241 175 175 146 ,};#include&lt;iostream&gt;int getans(int pos,int w){\tif (w==241 ) return 241 ;\tif (w192 252 ) return getans(pos44 252 ,w&gt;&gt;252 )91 weight[pos];\treturn getans(pos44 252 ,w&gt;&gt;252 );}int main(){\tint t,w;\tstd::cin&gt;&gt;t;\tfor (;t;t--){\t\tstd::cin&gt;&gt;w;\t\tstd::cout&lt;&lt;getans(241 ,w)&lt;&lt;std::endl;\t}}\n第2至16行存在大量数字与getans()函数内有处双目运算符需要被翻译。但观察到第2至16行中只有241未作为最高位数字出现过，猜测241为0。其余数字和运算符可以枚举得到，枚举程序如下：#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int weight[30];int t, W[40], ans[40], res[40];void weightFill(int A, int B, int C, int D, int E, int F, int G, int H, int I) {    weight[0] = D + H * 10 + C * 1000 + E * 100000 + E * 1000000 + C * 10000000 + D * 100000000;    weight[1] = C + G * 10 + I * 100 + B * 1000 + I * 100000 + H * 1000000 + C * 10000000;    weight[2] = I + F * 10 + G * 100 + H * 1000 + B * 10000 + C * 100000 + G * 1000000 + C * 10000000 + H * 100000000;    weight[3] = E + D * 100 + B * 1000 + C * 10000 + A * 100000 + B * 1000000 + I * 10000000 + E * 100000000;    weight[4] = A + G * 10 + E * 100 + E * 1000 + C * 100000 + A * 10000000 + G * 100000000;    weight[5] = A + I * 10 + C * 100 + I * 10000 + G * 100000 + H * 1000000 + E * 10000000 + C * 100000000;    weight[6] = A + H * 10 + E * 100 + H * 1000 + E * 10000 + H * 10000000 + E * 100000000;    weight[7] = H + E * 10 + A * 100 + C * 1000 + B * 10000 + H * 1000000 + C * 10000000 + A * 100000000;    weight[8] = D * 10 + B * 100 + I * 10000 + F * 100000 + D * 1000000 + H * 10000000 + E * 100000000;    weight[9] = I + F * 10 + A * 100 + C * 1000 + C * 10000 + D * 100000 + F * 1000000 + I * 10000000 + C * 100000000;    weight[10] = E + A * 10 + G * 100 + A * 1000 + B * 10000 + H * 100000 + D * 1000000 + I * 10000000;    weight[11] = F + I * 10 + G * 100 + A * 1000 + B * 10000 + D * 100000 + I * 1000000 + I * 10000000 + H * 100000000;    weight[12] = C + G * 10 + F * 1000 + B * 10000 + D * 100000 + I * 1000000 + C * 10000000 + D * 100000000;    weight[13] = G + D * 10 + A * 1000 + C * 10000 + I * 100000 + H * 1000000 + C * 10000000 + D * 100000000;    weight[14] = G + B * 10 + H * 100 + H * 1000 + D * 100000 + E * 1000000 + I * 100000000;    weight[15] = E + E * 10 + D * 100 + B * 10000 + E * 100000 + I * 1000000 + B * 10000000 + B * 100000000;    weight[16] = F + F * 10 + G * 100 + H * 1000 + B * 100000 + E * 1000000 + G * 10000000 + D * 100000000;    weight[17] = D + F * 100 + E * 1000 + B * 10000 + B * 100000 + E * 1000000 + E * 100000000;    weight[18] = E * 10 + A * 100 + C * 1000 + A * 10000 + G * 100000 + D * 1000000 + H * 100000000;    weight[19] = A + B * 100 + A * 1000 + D * 10000 + C * 100000 + B * 1000000 + A * 10000000 + B * 100000000;    weight[20] = D + A * 10 + G * 100 + E * 1000 + F * 10000 + B * 100000 + I * 1000000 + G * 10000000;    weight[21] = B + D * 10 + D * 1000 + B * 10000 + F * 100000 + C * 10000000 + A * 100000000;    weight[22] = D + G * 10 + A * 1000 + C * 10000 + C * 100000 + H * 1000000 + F * 10000000 + F * 100000000;    weight[23] = I + G * 10 + H * 100 + E * 1000 + G * 10000 + C * 100000 + I * 1000000 + H * 10000000 + C * 100000000;    weight[24] = G + B * 100 + C * 1000 + G * 10000 + D * 100000 + G * 10000000 + B * 1000000000;    weight[25] = B + I * 100 + D * 10000 + E * 100000 + D * 1000000 + F * 100000000;    weight[26] = G + C * 10 + B * 100 + D * 1000 + D * 100000 + G * 1000000 + A * 10000000 + A * 100000000;    weight[27] = C + B * 10 + A * 100 + I * 1000 + C * 10000 + H * 100000 + C * 1000000 + E * 10000000 + F * 100000000;    weight[28] = D + I * 10 + A * 100 + A * 1000 + B * 10000 + G * 100000 + I * 1000000 + H * 100000000;    weight[29] = E + C * 10 + C * 100 + B * 10000 + I * 10000000 + I * 100000000;}char const op[] = \"%&amp;+/^|\"; // 所有未出现过的单字符双目运算符int calc(int a, int b, char op) {    if (b == 0 &amp;&amp; (op == '%' || op == '/'))        return 0;    switch (op) {        case '%': return a % b;        case '&amp;': return a &amp; b;        case '+': return a + b;        case '/': return a / b;        case '^': return a ^ b;        case '|': return a | b;    }    return 0;}int getans(int pos, int w, int B, int opi, int opj, int opk) {    if (w == 0)        return 0;    if (calc(w, B, op[opi]))        return calc(getans(calc(pos, B, op[opj]), w &gt;&gt; B, B, opi, opj, opk), weight[pos], op[opk]);    return getans(calc(pos, B, op[opj]), w &gt;&gt; B, B, opi, opj, opk);}void read() {    freopen(\"large.in\", \"r\", stdin);    cin &gt;&gt; t;    for (int i = 0; i &lt; t; ++i)        cin &gt;&gt; W[i];    freopen(\"large.out\", \"r\", stdin);    for (int i = 0; i &lt; t; ++i)        cin &gt;&gt; ans[i];}bool check() {    for (int i = 0; i &lt; t; ++i)        if (res[i] != ans[i])            return false;    return true;}void work() {    int num[9] = {1, 2, 3, 4, 5, 6, 7, 8, 9};    do {        weightFill(num[0], num[1], num[2], num[3], num[4], num[5], num[6], num[7], num[8]);        // printf(\"%d %d %d %d %d %d %d %d %d\\n\", num[0], num[1], num[2], num[3], num[4], num[5], num[6], num[7], num[8]);        for (int opi = 0; opi &lt; 6; ++opi)            for (int opj = 0; opj &lt; 6; ++opj)                for (int opk = 0; opk &lt; 6; ++opk)                    if (opi != opj &amp;&amp; opj != opk &amp;&amp; opi != opk) {                        for (int i = 0; i &lt; t; ++i)                            res[i] = getans(0, W[i], num[1], opi, opj, opk);                        if (check()) {                            printf(\"85=%d 252=%d 175=%d 7=%d 146=%d 123=%d 242=%d 89=%d 198=%d\\n\", num[0], num[1], num[2], num[3], num[4], num[5], num[6], num[7], num[8]);                            printf(\"192=%c 44=%c 91=%c\\n\", op[opi], op[opj], op[opk]);                            printf(\"int weight[]={%d,%d,\\n\", weight[0], weight[1]);                            for (int i = 2; i &lt; 30; i += 2)                                printf(\"%d,%d,\\n\", weight[i], weight[i + 1]);                            printf(\"};\\n\");                            return;                        }                    }    } while (next_permutation(num, num + 9));}int main(){    read();    work();    return 0;}\n以上代码运行结果如下，翻译完成。85=5 252=1 175=9 7=2 146=3 123=8 242=4 89=6 198=7192=&amp; 44=+ 91=^int weight[]={293309062,96701749,694916487,371591203,450903345,936470975,360036365,596019536,362870120,978299587,72615453,677215478,297218049,296795024,703206614,117310233,243106488,303113802,602459530,151925105,47183452,590812021,886995042,967943647,1040249104,802320701,554202194,839697519,607415572,770010993,};\nlarge.cpp代码/* This is a comment*/int weight[]={293309062,96701749,694916487,371591203,450903345,936470975,360036365,596019536,362870120,978299587,72615453,677215478,297218049,296795024,703206614,117310233,243106488,303113802,602459530,151925105,47183452,590812021,886995042,967943647,1040249104,802320701,554202194,839697519,607415572,770010993,};#include&lt;iostream&gt;int getans(int pos,int w){\tif (w==0) return 0;\tif (w&amp;1) return getans(pos+1,w&gt;&gt;1)^weight[pos];\treturn getans(pos+1,w&gt;&gt;1);}int main(){\tint t,w;\tstd::cin&gt;&gt;t;\tfor (;t;t--){\t\tstd::cin&gt;&gt;w;\t\tstd::cout&lt;&lt;getans(0,w)&lt;&lt;std::endl;\t}}\n代码#include &lt;iostream&gt;using namespace std;int const N = 1000;int t;void small() {    int x[N], n;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; ++i) {        cin &gt;&gt; x[i];    }    int result = 0;    for (int i = 1; i &lt;= n; ++i) {        for (int j = i + 1; j &lt;= n; ++j) {            if (x[i] &gt; x[j]) {                result += (i ^ j);            }        }    }    cout &lt;&lt; result &lt;&lt; endl;}int weight[] = {    293309062, 96701749, 694916487, 371591203, 450903345,    936470975, 360036365, 596019536, 362870120, 978299587,    72615453, 677215478, 297218049, 296795024, 703206614,    117310233, 243106488, 303113802, 602459530, 151925105,    47183452, 590812021, 886995042, 967943647, 1040249104,    802320701, 554202194, 839697519, 607415572, 770010993,};int getans(int pos, int w) {    if (w == 0)        return 0;    if (w &amp; 1)          return getans(pos + 1, w &gt;&gt; 1) ^ weight[pos];    return getans(pos + 1, w &gt;&gt; 1);}void large() {    int t, w;    cin &gt;&gt; t;    for ( ; t; t--) {        cin &gt;&gt; w;        cout &lt;&lt; getans(0, w) &lt;&lt; endl;    }}int main() {    cin &gt;&gt; t;    if (t == 1)        small();    else        large();    return 0;}\n\n\n正赛M - 最长公共子序列原题面背景蒜斜和镁团在玩一个叫做“你问你猜”的游戏（可怜去哪了？）。规则如下：镁团手中有个数，且恰好是的排列。每次询问，蒜斜需要给出一个长度不超过，且每个元素都在之间的数列（不需要是排列）；之后镁团会告诉蒜斜这两个数列的最长公共子序列长度。蒜斜需要在不超过次询问内猜出镁团手中的排列。这对于蒜斜来说实在太困难了，因此他找到了玉树临风文质彬彬英俊潇洒神采奕奕温文尔雅风度翩翩的你，你能帮助他吗？\n任务你需要编写一个函数find_permutation，以确定镁团手中的排列是什么。\n\nfind_permutation(n, res)\nn: 镁团手中排列的长度。\nres：返回数组，你需要把你确定的排列存储到res中。\n\n\n你可以调用函数get_lcs以帮助你确定镁团手中的排列。我们会根据你调用这个函数的次数评分。\n\nget_lcs(len, A)接受整数len和一个长度为len的数组A，并会返回数组A与目标排列的最长公共子序列长度。在一组测试数据中，find_permutation只会被调用一次。\n实现细节本题只支持C++。你只能提交一个源文件实现如上所述的find_permutation函数，并且遵循下面的命名和接口。你需要包含头文件lcs.h。void find_permutation(int n, int res[]);你需要把答案排列存储在res[0]至res[n-1]中。函数get_lcs的接口信息如下。int get_lcs(int len, int A[]);你需要把询问的数组存储在A[0]至A[len-1]中，数组A中的元素必须是区间中的整数。请保证你的所有询问都满足这个要求，不然的话可能会出现包括但不限于Wrong Answer、Dangerous Syscalls的评测错误。如果有不清楚的地方，见样例及测评库下载，内附了样例程序。\n评测方式评测系统将读入如下格式的输入数据：\n\n第1行：，表示镁团手中的排列长度。\n第2行：个空格隔开的整数，表示镁团手中的排列。\n\n在find_permutation返回后，评测系统将输出你的答案以及get_lcs的调用次数。\n数据范围Small Task: Large Task: find_permutation只能进行不超过次询问。如果超过了这个询问数量，你的程序将无法得分。本题严禁任何形式的攻击交互库的行为，一旦发现，将取消相关选手的参赛资格。\n时空限制\n时间限制：\n空间限制：\n\n样例\n\n\n输入\n输出\n\n\n\n\n51 5 2 4 3\n1 5 2 4 310\n\n\n\n\n样例解释样例输出的含义为find_permuation在次询问之后，确定了镁团手中的排列为。\n下载样例交互库下载\n链接http://uoj.ac/contest/53/problem/531\n题解题意实现一个函数，在询问至多次任意指定数列与评测机确定的数列之间的最长公共子序列长度后，给出评测机确定的数列。\n思路\n考虑长度为的数列，其中且，在传入get_lcs后的返回值只可能为或。\n表示评测机确定的数列中在的前面，表示评测机确定的数列中在的前面。\n若用$a","categories":["ACM"],"tags":["Python","C/C++"]},{"title":"《计量地理学》笔记","url":"/posts/af5b8159/","content":"描述统计\n众数\n一组数据中出现次数最多的变量值。\n一组数据中出现次数最多的变量值。\n适合于数据量较多时使用。\n不受极端值的影响。\n一组数据可能没有众数或有几个众数。\n主要用于分类数据，也可用于顺序数据和数值型数据。\n\n\n中位数\n排序后处于中间位置上的值。\n不受极端值的影响。\n主要用于顺序数据，也可用数值型数据，但不能用于分类数据。\n位置确定：\n\n\n四分位数\n排序后处于和位置上的值。\n不受极端值的影响。\n主要用于顺序数据，也可用于数值型数据，但不能用于分类数据。\n位置确定：\n\n\n平均数\n集中趋势的最常用测度值。\n一组数据的均衡点所在。\n体现了数据的必然性特征。\n易受极端值的影响。\n用于数值型数据，不能用于分类数据和顺序数据。\n算术平均数：\n几何平均数：。\n几何平均数适用于比率数据的平均，主要用于计算平均增长率。\n\n\n样本均值的估计标准误差\n本部分内容参考文献：维基百科编者. 标准误差[G/OL]. 维基百科, 2020(20201231)[2020-12-31]. https://zh.wikipedia.org/w/index.php?title=%E6%A0%87%E5%87%86%E8%AF%AF%E5%B7%AE&amp;oldid=63513250.，请注意甄别。\n简称平均值（数）标准误差，注意在简称的背后总是意指“样本的”。\n是描述对应的样本平均数抽样分布的离散程度及衡量对应样本平均数抽样误差大小的尺度。\n如果已知总体的标准差为，那么抽取无限多份大小为的样本，每个样本各有一个平均值，所有这个大小的样本之平均值的标准差可证明为。称为样本平均值的标准“差”。\n但由于通常为未知，此时可以用研究中取得样本的标准差来估计：，其中为样本的标准差，为样本数量（大小）。称为样本平均值的标准“误”。\n\n\n异众比率\n对分类数据离散程度的测度\n非众数组的频数占总频数的比例\n用于衡量众数的代表性\n\n\n极差\n一组数据的最大值与最小值之差\n离散程度的最简单测度值\n易受极端值影响\n未考虑数据的分布\n计算公式：\n\n\n平均差\n各变量值与其平均数离差绝对值的平均数\n能全面反映一组数据的离散程度\n数学性质较差，实际中应用较少\n计算公式：\n\n\n方差\n总体：\n样本：\n\n\n标准差\n总体：\n样本：\n\n\n标准分数\n也称标准化值\n对某一个值在一组数据中相对位置的度量\n可用于判断一组数据是否有离群点\n用于对变量的标准化处理\n计算公式：\n\n\n离散系数\n也叫变异系数\n标准差与其相应的均值之比\n对数据相对离散程度的测度\n消除了数据水平高低和计量单位的影响\n用于对不同组别数据离散程度的比较\n计算公式：\n\n\n偏态系数\n数据分布偏斜程度的测度\n计算公式：\n为对称分布\n为右偏分布\n为左偏分布\n偏度的标准误计算公式：\n偏度标准得分计算公式：\n\n\n峰态系数\n数据分布扁平程度的测度\n计算公式：\n扁平峰度适中\n为扁平分布\n为尖峰分布\n峰度的标准误计算公式：\n峰度标准得分计算公式：\n取显著性水平为，若偏、峰度标准得分绝对值均小于，则可认为此分布服从正态分布。其中可在Excel中利用公式=NORM.S.INV(1-alpha/2)计算。\n\n\nSPSS操作\n步骤\n选择主菜单【分析】→【描述统计】→【描述】。\n点击【统计量】，在弹出的对话框中选择需要的统计量。\n\n\n解读\n【描述统计量】\n表内包含了所选择的统计量信息。\n\n\n\n\n\n\n\n推断统计\n总体均值的区间估计（以小样本为例）\n检验量：\n统计量：\n置信区间：\n大样本：\nSPSS操作\n步骤\n选择主菜单【分析】→【比较均值】→【单样本T检验】。\n选择【检验变量】，保持下方【检验值】为0（或改变该值以检验总体均值是否等于该值）。\n点击【选项】，在弹出的对话框中设置需要的【置信区间百分比】。\n\n\n解读\n【单个样本检验】\n若【Sig.(双侧)】小于设定的显著性水平则表示拒绝总体均值等于【检验值】的假设，否则接受该假设。\n当设定的【检验值】为时，【下限】和【上限】构成总体均值的估计区间。\n\n\n\n\n\n\n\n\n总体方差的区间估计（总体均值已知）\n检验量：\n统计量：\n置信区间 ：\n\n\n总体方差的区间估计（总体均值未知）\n检验量：\n统计量：\n置信区间 ：\n\n\n两个总体均值之差的区间估计（总体方差已知）\n检验量：\n统计量：\n置信区间 ：\n\n\n两个总体均值之差的区间估计（总体方差未知但相等）\n检验量：\n总体方差的合并估计量：\n总体均值之差估计量的抽样标准差：\n统计量：\n置信区间：\nSPSS操作\n步骤\n选择主菜单【分析】→【比较均值】→【独立样本T检验】。\n选择【检验变量】和【分组变量】。\n点击选定的【分组变量】，点击【定义组】，在弹出的对话框中选择分组方式（【割点】方式下右侧符号为大于等于）。\n点击【选项】，在弹出的对话框中设置需要的【置信区间百分比】。\n\n\n解读\n【独立样本检验】\n若【Sig.】小于设定的显著性水平则表示拒绝两总体方差相等的假设，否则接受该假设，并据此进行后续检验。\n若【Sig.(双侧)】小于设定的显著性水平则表示拒绝两总体均值相等的假设，否则接受该假设。\n\n\n\n\n\n\n\n\n两个总体均值之差的区间估计（总体方差未知且不相等）\n检验量：\n自由度：\n统计量：\n置信区间：。\n\n\n两个总体均值之差的区间估计（匹配样本、以小样本为例）\n符号说明：为样本对应差值的均值；为样本对应差值的标准差。\n检验量：\n统计量：\n置信区间：\n大样本：\nSPSS操作\n步骤\n选择主菜单【分析】→【比较均值】→【配对样本T检验】。\n依次选择两个【成对变量】。\n点击【选项】，在弹出的对话框中设置需要的【置信区间百分比】。\n\n\n解读\n【成对样本检验】\n若【Sig.(双侧)】小于设定的显著性水平则表示拒绝两总体均值之差为零（两总体均值相等）的假设，否则接受该假设。\n\n\n\n\n\n\n\n\n两个总体方差之比的区间估计（总体均值已知）\n统计量：\n置信区间：。\n\n\n两个总体方差之比的区间估计（总体均值未知）\n统计量：\n置信区间：\n\n\n\n方差分析\n引论\n术语\n因素（因子）：所要检验的对象称为因素，是影响因变量变化的客观条件，用分类变量表示，取有限的离散值。\n水平（处理）：因素的不同等级或表现称作水平。水平值取有限的离散值。\n观测值：每个因子水平下得到的样本数据称为观测值。\n\n\n两类误差\n组内误差：来自水平内部的数据误差。组内差异只含有随机误差。\n组间误差：来自不同水平之间的数据误差。组间误差既包含随机误差，也包含系统误差。\n\n\n误差平方和\n组内平方和：也称误差项平方和，反映组内误差大小的平方和。组内平方和只包含随机误差。\n组间平方和：也称水平项平方和，反映组间误差大小的平方和。组间平方和既包括随机误差，也包括系统误差。\n总误差平方和：反映全部数据误差大小的平方和。\n三者关系：\n\n\n基本思想与原理\n比较两类误差，以检验均值是否相等，比较的基础是方差之比F=\\dfrac{\\mathrm{MSA}}{\\mathrm{MSE}}=\\dfrac{\\dfrac1{k-1}\\sum\\limits_{i=1}^kn_i\\left(\\bar x_i-\\bar{\\bar x}\\right)^2}{\\dfrac1{n-k}\\sum\\limits_{i=1}^k\\sum\\limits_{j=1}^{n_i}\\left(x_{i,j}-\\bar x_i\\right)^2}\\sim F\\left(k-1,n-k\\right)\n若样本均值相等，则组间平方和与组内平方和经过平均后的数值（称为均方或方差）就应该很接近，它们的比值就会接近。\n若样本均值不全相等，则组间平方和平均后的数值就会大于组内平方和平均后的数值，它们之间的比值就会大于。\n当这个比值大到某种程度时，就认为不同水平之间存在着显著差异，也就是自变量对因变量有影响。\n\n\n基本假定\n每个总体都应服从正态分布：对于因素的每一个水平，其观察值是来自服从正态分布总体的简单随机样本。\n各个总体的方差必须相同：各组观察数据是从具有相同方差的总体中抽取的。\n观察值是独立的\n\n\n提出假设\n原假设：各均相等，即自变量对因变量没有显著影响。\n备择假设：各不全相等，即自变量对因变量有显著影响。\n\n\n\n\n单因素方差分析\n数据结构描述\n共有个水平\n第个水平下有个观察值\n第个水平下的第个观察值记为\n\n\n统计量\n水平的均值：\n各观察值的总均值：\n总误差平方和（自由度为）：\n组间平方和（自由度为）：\n组内平方和（自由度为）：\n组间方差（组间平方和的均方）：\n组内方差（组内平方和的均方）：\n检验统计量：\n\n\n统计决策（显著性水平取）\n若，则拒绝原假设，表明均值之间的差异是显著的，所检验的因素对观察值有显著影响。\n若，则不拒绝原假设，无证据表明所检验的因素对观察值有显著影响。\n\n\n关系强度\n变量间关系的强度用组内平方和占总误差平方和的比例大小来反映，记为，即。\n其算术平方根就可以用来测量两个变量之间的关系强度。\n自变量对因变量的影响效应占总效应的百分比（能解释的差异比例）为，残差效应占。\n\n\nSPSS操作\n步骤\n选择主菜单【分析】→【比较均值】→【单因素ANOVA】。\n选择【因变量列表】和【因子】。\n点击【两两比较】，在弹出的对话框中设置需要的【假定方差齐性】（一般勾选【LSD】）以及【显著性水平】。\n点击【选项】，在弹出的对话框中设置需要的【描述性】统计。\n\n\n解读\n【单因素方差分析】\n若【显著性】小于设定的显著性水平则表示拒绝因子对因变量没有显著影响的假设，否则接受该假设。\n\n\n【多重比较】\n【均值差 (I-J)】打星号（同行【显著性】小于设定的显著性水平）的表示两者之间存在显著差异。\n\n\n\n\n\n\n\n\n双因素方差分析\nSPSS操作\n步骤\n选择主菜单【分析】→【一般线性模型】→【单变量】。\n选择【因变量】和【固定因子】。\n点击【模型】，在弹出的对话框中选择【指定模型】。\n点击【选项】，在弹出的对话框中设置需要的【置信区间百分比】。\n\n\n解读\n【主体间效应的检验】\n若【Sig.】小于设定的显著性水平则表示拒绝因子及其交互作用对因变量没有显著影响的假设，否则接受该假设。\n\n\n\n\n\n\n\n\n\n相关与回归分析\n相关系数\n分类\n若相关系数是根据总体全部数据计算的，称为总体相关系数，记为。\n若是根据样本数据计算的，则称为样本相关系数，记为。\n\n\n计算r=\\dfrac{\\sum\\limits_{i=1}^n\\left(x_i-\\bar x\\right)\\left(y_i-\\bar y\\right)}{\\sqrt{\\sum\\limits_{i=1}^n\\left(x_i-\\bar x\\right)^2\\cdot\\sum\\limits_{i=1}^n\\left(y_i-\\bar y\\right)^2}}=\\dfrac{n\\sum\\limits_{i=1}^nx_iy_i-\\sum\\limits_{i=1}^nx\\sum\\limits_{i=1}^ny}{\\sqrt{n\\sum\\limits_{i=1}^nx^2-\\left(\\sum\\limits_{i=1}^nx\\right)^2}\\cdot\\sqrt{n\\sum\\limits_{i=1}^ny^2-\\left(\\sum\\limits_{i=1}^ny\\right)^2}}\n取值与意义\n取值范围：\n经验分级\n：高度相关\n：中度相关\n：低度相关\n：极弱或不相关\n\n\n\n\n显著性检验\n目的：检验两个变量之间是否存在线性相关关系\n提出假设：\n计算统计量：\n作出决策：若则拒绝原假设，否则不能拒绝原假设。\nSPSS操作\n步骤\n选择主菜单【分析】→【相关】→【双变量】。\n选择【变量】和【相关系统】。\n\n\n解读\n【相关性】\n【Pearson 相关性】表示相关系数。\n若【显著性（双侧）】小于设定的显著性水平则表示拒绝该对变量之间不存在线性相关关系的假设，否则接受该假设。\n\n\n\n\n\n\n\n\n\n\n一元线性回归\n模型\n表达式：\n参数：\n误差项是随机变量，反应除之间的线性关系之外的随机因素对的影响（不能由线性关系所解释的变异性）。\n\n\n基本假定\n因变量与自变量之间具有线性关系。\n误差项是一个期望值为的随机变量，即；对于一个给定的值，的期望值为。\n对于所有的值，的方差都相同。\n误差项是一个服从正态分布的随机变量，且相互独立，即。\n\n\n回归方程\n表达式：\n是描述的期望值如何依赖于的方程。\n方程的图示是一条直线，也称为直线回归方程。\n是回归直线在轴上的截距，是当时的期望值。\n是直线的斜率，称为回归系数，表示当每变动一个单位时，的平均变动值。\n\n\n估计的回归方程\n用样本统计量和代替回归方程中的未知参数和，就得到了估计的回归方程。\n一元线性回归中估计的回归方程为。\n是估计的回归直线在轴上的截距。\n是直线的斜率，它表示每变动一个单位时，的平均变动值。\n\n\n最小二乘估计\n是使因变量的观察值与估计值之间的离差平方和达到最小来求得和的方法，即。\n用最小二乘法拟合的直线来代表x与y之间的关系与实际数据的误差比其他任何直线都小。\n参数求解\n\n\n\n\n\n\n拟合优度\n因变量的取值是不同的，这种取值的波动称为变差。\n变差来源于两个方面：由于自变量的取值不同造成的；除以外的其他因素（如对的非线性影响、测量误差等）的影响。\n对一个具体的观测值来说，变差的大小可以通过该实际观测值与其均值之差来表示。\n离差平方和的分解\n总平方和：\n回归平方和：\n残差平方和：\n三者关系：\n判定系数：\n\n\n度量拟合优度的统计量可以用判定系数。\n在数值上等于相关系数的平方，即在数值上等于相关系数。\n\n\n线性关系检验\n目的：检验自变量与因变量之间的线性关系是否显著。\n提出假设：\n计算统计量：\n作出决策：若则拒绝原假设，否则不能拒绝原假设。\n\n\n回归系数的检验\n目的：检验自变量对因变量的影响是否显著。\n提出假设：\n计算统计量：\n作出决策：若则拒绝原假设，否则不能拒绝原假设。\n\n\n点估计\n对于自变量的一个给定值，根据回归方程得到因变量的一个估计值。\n直接将代入拟合的方程即可。\n\n\n置信区间估计\n利用估计的回归方程，对于自变量的一个给定值，求出因变量的平均值的估计区间 ，这一估计区间称为置信区间。\n的置信区间：\n为估计标准误差\n\n\n预测区间估计\n利用估计的回归方程，对于自变量的一个给定值，求出因变量的一个个别值的估计区间 ，这一估计区间称为预测区间。\n的预测区间：\n为估计标准误差\n\n\n对于两个区间的理解\n构建一个回归方程，其公式为。其中为误差，指的是的变异之中不可以由解释的部分。而实际上该模型能做到的仅仅是估计的值，而非对应的值，因为误差是不可测量的、未知的。\n因此，这里引出了置信区间和预测区间的区别：置信区间指的是在某个信度下的可能范围，而预测区间指的是在某个信度下的可能范围。\n在同样的信度下，预测区间的上下值大于置信区间，即预测区间的范围大于置信区间，因为预测时多了不可消除的误差项。\n更具体来说，当需要根据一个值去预测一个点的值时，使用预测区间；当需要预测模型在该点处的期望值时（多次抽样后的理论均值），则是对的估计，使用置信区间。\n\n\nSPSS操作\n步骤\n选择主菜单【分析】→【回归】→【线性】。\n选择【因变量】和【自变量】。\n点击【统计量】，在弹出的对话框中需要的统计量，一般勾选【置信区间】并设置相应的【水平】。\n若需要区间估计，在数据末尾加上对应的自变量的值（因变量留空），点击【保存】，勾选【预测值】中的【未标准化】，按需勾选【预测区间】中的内容（【均值】：置信区间、【单值】：预测区间）并设置相应的【置信区间】。\n\n\n解读\n【模型汇总】\n【R方】表示判定系数，【R】为【R方】的算术平方根。\n【调整R方】的计算公式参考修正多重判定系数，公式为。\n\n\n【ANOVA】\n若【Sig.】小于设定的显著性水平则表示拒绝的自变量与因变量之间的线性关系不显著的假设，否则接受该假设。\n\n\n【系数】\n【B】表示回归系数（或常数）。\n若【Sig.】小于设定的显著性水平则表示拒绝的自变量对因变量的影响不显著的假设，否则接受该假设。\n【下限】和【上限】构成该项系数的置信区间。\n\n\n数据视图\n若进行了区间估计，则【PRE_1】变量表示该值的点估计，【LI CI_1】和【UI CI_1】构成该值的置信（或预测）区间。\n\n\n\n\n\n\n\n\n多元线性回归\n模型\n表达式：\n参数：\n是被称为误差项的随机变量。\n是的线性函数加上误差项。\n包含在里面但不能被k个自变量的线性关系所解释的变异性。\n\n\n基本假定\n误差项是一个期望值为的随机变量，即。\n对于自变量的所有值，的方差都相同。\n误差项是一个服从正态分布的随机变量，即，且相互独立。\n\n\n多元回归方程\n表达式：\n是描述因变量的平均值或期望值如何依赖于自变量的方程。\n称为偏回归系数，其每个都表示假定其他偏回归系数不变，当对应的自变量每变动一个单位时，的平均变动值。\n\n\n估计的多元回的方程\n用样本统计量估计回归方程中的参数时得到的方程。\n一般形式：\n\n\n多重判定系数\n计算公式：\n是回归平方和占总平方和的比例\n表示因变量取值的变差中能被估计的多元回归方程所解释的比例\n\n\n修正多重判定系数\n计算公式：\n避免增加自变量而高估\n意义与类似但数值上小于\n\n\n线性关系检验（总体的显著性检验）\n目的：检验因变量与所有自变量之间的线性关系是否显著。\n提出假设：\n计算统计量：\n作出决策：若则拒绝原假设，否则不能拒绝原假设。\n\n\n回归系数的检验\n目的：检验因变量与某个自变量之间的线性关系是否显著。\n提出假设：\n计算统计量：\n作出决策：若则拒绝原假设，否则不能拒绝原假设。\n\n\n多重共线性\n概念：回归模型中两个或两个以上的自变量彼此相关。\n问题：可能会使回归的结果造成混乱，甚至会把分析引入歧途；可能对参数估计值的正负号产生影响，特别是各回归系数的正负号有可能同预期的正负号相反。\n识别：检测多重共线性的最简单的一种办法是计算模型中各对自变量之间的相关系数，并对各相关系数进行显著性检验。若有一个或多个相关系数显著，就表示模型中所用的自变量之间相关，存在着多重共线性。\n暗示：模型中各对自变量之间显著相关；当模型的线性关系检验（检验）显著时，几乎所有回归系数的检验却不显著；回归系数的正负号与预期的相反。\n处理：将一个或多个相关的自变量从模型中剔除，使保留的自变量尽可能不相关；如果要在模型中保留所有的自变量，则应避免根据统计量对单个参数进行检验，并对因变量值的推断（估计或预测）限定在自变量样本值的范围内。\n\n\n变量选择\n选择过程\n在建立回归模型时，对自变量进行筛选。\n选择自变量的原则是对统计量进行显著性检验。\n将一个或一个以上的自变量引入到回归模型中时，是否使得残差平方和有显著减少。如果增加一个自变量使的减少是显著的，则说明有必要将这个自变量引入回归模型，否则，就没有必要将这个自变量引入回归模型。\n确定引入自变量是否使有显著减少的方法，就是使用F统计量的值作为一个标准，以此来确定是在模型中增加一个自变量，还是从模型中剔除一个自变量。\n\n\n变量选择的方法主要有：向前选择、向后剔除、逐步回归、最优子集等。\n\n\n向前选择\n从模型中没有自变量开始。\n对个自变量分别拟合对因变量的一元线性回归模型，共有个，然后找出统计量的值最高的模型及其自变量，并将其首先引入模型。\n分别拟合引入模型外的个自变量的线性回归模型。\n如此反复进行，直至模型外的自变量均无统计显著性为止。\n\n\n向后剔除\n先对因变量拟合包括所有个自变量的回归模型。然后考察（）个去掉一个自变量的模型（这些模型中每一个都有个自变量），使模型的值减小最少的自变量被挑选出来并从模型中剔除。\n考察个再去掉一个自变量的模型（这些模型中每一个都有个的自变量），使模型的值减小最少的自变量被挑选出来并从模型中剔除\n如此反复进行，一直将自变量从模型中剔除，直至剔除一个自变量不会使显著减小为止。\n\n\n逐步回归\n将向前选择和向后剔除两种方法结合起来筛选自变量。\n在增加了一个自变量后，它会对模型中所有的变量进行考察，看看有没有可能剔除某个自变量。如果在增加了一个自变量后，前面增加的某个自变量对模型的贡献变得不显著，这个变量就会被剔除。\n按照以上方法不停地增加变量并考虑剔除以前增加的变量的可能性，直至增加变量已经不能导致显著减少。\n在前面步骤中增加的自变量在后面的步骤中有可能被剔除，而在前面步骤中剔除的自变量在后面的步骤中也可能重新进入到模型中。\n\n\n\n\nSPSS操作\n步骤\n选择主菜单【分析】→【回归】→【线性】。\n选择【因变量】和【自变量】，以及逐步回归的【方法】（【进入】：不进行逐步回归、【逐步】：逐步回归、【删除】：不常用、【向前】：向前选择、【向后】：向后剔除）。\n点击【统计量】，在弹出的对话框中需要的统计量，一般勾选【置信区间】并设置相应的【水平】，以及【共线性诊断】。\n若设定了非进入的变量选择方法，点击【选项】，在弹出的对话框中设置相应的【步进方法标准】。\n若需要区间估计，在数据末尾加上对应的自变量的值（因变量留空），点击【保存】，勾选【预测值】中的【非标准化】，按需勾选【预测区间】中的内容（置信区间勾选【均值】、预测区间勾选【单值】）并设置相应的【置信区间】。\n\n\n解读\n【模型汇总】\n【R方】表示判定系数，【R】为【R方】的算术平方根。\n【调整R方】的计算公式参考修正多重判定系数，公式为。\n\n\n【ANOVA】\n若【Sig.】小于设定的显著性水平则表示拒绝的自变量与因变量之间的线性关系不显著的假设，否则接受该假设。\n\n\n【系数】\n【B】表示回归系数（或常数）。\n若【Sig.】小于设定的显著性水平则表示拒绝的自变量对因变量的影响不显著的假设，否则接受该假设。\n【下限】和【上限】构成该项系数的置信区间。\n\n\n【已排除的变量】\n【模型】下方列出了根据设置的规则所排除的变量。\n\n\n数据视图\n若进行了区间估计，则【PRE_1】变量表示该值的点估计，【LI CI_1】和【UI CI_1】构成该值的置信（或预测）区间。\n\n\n\n\n\n\n\n\n\n聚类与判别分析\n聚类分析\n理论\n概念：是根据事物本身的特性研究个体分类的方法，是研究“物以类聚”的一种多元统计分析方法。\n基本思想：根据对象间的相关程度进行类别的聚合。\n原则：同一类中的个体有较大的相似性，不同类中的个差异很大。\n分类\n样本聚类：根据每个样本的各种特征，对观测量（Case）进行聚类。又称Q型聚类。\n变量聚类：对变量（Variable）进行聚类。又称R型聚类。\n\n\n\n\n数据结构描述\n共有个样本\n每个样本测得项指标（变量）\n第个样本的第项指标记为\n\n\n数据变换处理\n标准差标准化：\n极大值标准化：\n极差的标准化：\n\n\n统计量\n距离\n将一个样本看作维空间的一个点，并在空间定义距离，距离越近的点归为一类，距离较远的点归为不同的类。通常用于样本聚类分析。\n明氏（Minkowski）距离：样本之间的距离\n\n\n相似系数\n性质越接近的变量，它们的相似系数的绝对值越接近，而彼此无关的变量，它们的相似系数的绝对值越接近于。比较相似的变量归为一类，不怎么相似的变量归为不同的类。通常用于变量聚类分析。\n夹角余弦：样本之间的夹角余弦\n相关系数：样本之间的相关系数\n\n\n\n\n方法\n直接距离法\n把各个分类对象单独视为一类。\n根据距离最小的原则，依次选出一对分类对象，并成新类。\n如果其中一个分类对象已归于一类，则把另一个也归入该类；如果一对分类对象正好属于已归的两类，则把这两类并为一类；每一次归并，都划去该对象所在的列与列序相同的行。\n那么，经过次就可以把全部分类对象归为一类，这样就可以根据归并的先后顺序作出聚类谱系图。\n\n\n最短距离聚类法\n在原来的距离矩阵的非对角元素中找出，把分类对象和归并为一新类。\n则其余类与新类的距离计算公式，并组成新的的距离矩阵。\n再找非对角线最小元素的两类并类，直至所有的样本全归为一类为止。 \n\n\n最远距离聚类法\n与最短距离聚类法类似，但。\n\n\n\n\nSPSS操作\n步骤\n选择主菜单【分析】→【分类】→【系统聚类】。\n选择【变量】和【标注个案】，选择【聚类】方式（【个案】：一行一个样本、【变量】：一列一个样本）。\n点击【统计量】，在弹出的对话框中按需选择【聚类成员】方法与数量。\n点击【绘制】，在弹出的对话框中勾选【树状图】。\n点击【方法】，在弹出的对话框中选择【标准化】方法以及下方的方式（【按照变量】：一行一个样本、【按个案】：一列一个样本）。\n\n\n解读\n【聚类表】\n【群集组合】依次列出了进行合并的类别号。\n\n\n【使用某聚类方法的树状图】\n聚类谱系图。\n\n\n\n\n\n\n\n\n判别分析\n理论\n定义\n是根据表明事物特点的变量值和它们所属的类，求出判别函数，并根据判别函数对未知所属类别的事物进行分类的一种分析方法。\n是一种利用已知类别的样本训练模型，为未知样本进行判类的统计方法。\n\n\n特点\n根据已掌握的、历史上每个类别的若干样本的数据信息，总结出客观事物分类的规律性，建立判别公式和判别准则。\n当遇到新的样本点时，只要根据总结出来的判别公式和判别准则，就能判别该样本点所属的类别。、\n\n\n\n\n方法\nFisher判别法\n数据结构描述\n有两类已分类的样本集和且分别包含了和个样本\n样本集中的每个样本都具有个指标\n第个样本集中第个样本的第个指标记为\n待测样本构成与任一样本集中任一样本相同\n\n\n基本思想\n根据方差分析的思想建立起来的一种能较好区分各个总体的线性判别法，该判别方法对总体的分布不做任何要求。\n从两个总体中抽取具有个指标的样本观测数据，借助于方差分析的思想构造一个线性判别函数：。\n当建立了判别式以后，将一个新样本值的个指标值代入判别式中求出值，然后与某个临界值比较，就可以将该样本归某类。\n判别式系数确定的原则：使两组间的组间离差最大，而每个组的组内离差最小。\n\n\n实现步骤\n计算平均数：\n计算两类样本特征的平均数的差：\n计算两类样本的矩阵系数：\n构造矩阵求解判别式系数：\n代入平均值：\n定义临界点：\n判别准则：若，则属于第一类；否则属于第二类。\n\n\n\n\n距离判别法（以马氏距离为例）\n数据结构描述\n样本集包含了个样本\n样本集中的每个样本都具有个指标\n第个样本的第个指标记为\n待测样本构成与样本集中任一样本相同\n样本集类别总数为\n\n\n基本思想\n某点离哪个中心距离最近，就属于哪一类。\n\n\n实现步骤\n对每个指标计算样本集特征平均数：\n计算样本集的协方差矩阵：\n待测样本与样本集的马氏距离：\n判别准则：\n\n\n\n\n贝叶斯方法\n把数据分成几类或几组\n算出未知类归属于各已知类的概率\n把它划归于概率值最大的类中\n\n\n\n\nSPSS操作\n步骤\n选择主菜单【分析】→【分类】→【判别】。\n选择【分组变量】和【自变量】。\n点击选定的【分组变量】，点击【定义范围】，在弹出的对话框中选择分组编号的范围。\n点击【统计量】，在弹出的对话框中需要的统计量，一般勾选【Fisher】和【非标准化】。\n点击【分类】，在弹出的对话框中按需勾选【个案结果】。\n若需要将判别结果输出到表中，点击【保存】，在弹出的对话框中勾选【预测组成员】以及其他输出内容。\n\n\n解读\n【分类函数系数】\n表示Fisher的线性判别式函数的系数。\n\n\n【按照案例顺序的统计量】\n【预测组】表示判别结果。\n\n\n数据视图\n【Dis_1】表示判别结果。\n\n\n\n\n\n\n\n\n\n主成分分析\n基本原理\n正交变换\n假设有个样本，每个样品有两个指标，即在二维空间中讨论主成分的几何意义。设个样品在二维空间的分布大致为一个椭圆。\n当坐标轴和椭圆的长短轴平行，那么长轴的变量就描述了数据的主要变化，而代表短轴的变量就描述了数据的次要变化。\n而坐标轴通常并不和椭圆的长短轴平行，需要进行变换。\n如果长轴代表了数据包含的大部分信息，就用该变量代替原先的两个变量，降维就完成了。\n考虑多维的情况：与二维相似，也有高维的椭球。\n找出高维椭球的主轴，再用代表大多数数据信息的最长的几个轴作为新变量，这样主成分分析就完成了。\n高维椭球的主轴也是相互垂直的。相互正交的新变量是原先变量的线性组合，叫做主成分。\n如二维椭圆有两个主轴，三维椭球有三个主轴一样，有几个变量就有几个主成分。\n选择的主成分越少，降维就越好。\n\n\n形式化表述\n设有个样本，每个样本有个变量，构成一个阶的数据矩阵，第个样本的第个变量记为。\n记为原变量指标，（）为新变量指标。\n主成分分析通常的做法，是寻求原指标的线性组合。\n该线性组合满足下列条件：\n每个主成分的系数平方和为（否则其方差可能为无穷大），即。\n主成分之间相互无关（无重叠的信息），即。\n主成分的方差依次递减（重要性依次递减），即。\n\n\n则新变量指标分别称为原变量指标的第主成分。\n\n\n\n\n推导\n线性代数的引论\n若是阶实对称矩阵，则一定存在正交阵，使下式成立，其中为的特征根。U^{-1}AU=\\begin{bmatrix}\\lambda_1&0&\\cdots&0\\\\0&\\lambda_2&\\cdots&0\\\\\\vdots&\\vdots&\\ddots&\\vdots\\\\0&0&\\cdots&\\lambda_p\\end{bmatrix}\n记上述矩阵的特征根所对应的单位特征向量为，如下构造矩阵，则为正交矩阵，即有。U=\\begin{bmatrix}u_1&u_2&\\cdots&u_p\\end{bmatrix}=\\begin{bmatrix}u_{1,1}&u_{1,2}&\\cdots&u_{1,p}\\\\u_{2,1}&u_{2,2}&\\cdots&u_{2,p}\\\\\\vdots&\\vdots&\\ddots&\\vdots\\\\u_{p,1}&u_{p,2}&\\cdots&u_{p,p}\\end{bmatrix}\n\n\n第一主成分\n设的协方差矩阵如下：\\Sigma_x=\\begin{bmatrix}\\sigma_1^2&\\sigma_{1,2}&\\cdots&\\sigma_{1,p}\\\\\\sigma_{2,1}&\\sigma_2^2&\\cdots&\\sigma_{2,p}\\\\\\vdots&\\vdots&\\ddots&\\vdots\\\\\\sigma_{p,1}&\\sigma_{p,2}&\\cdots&\\sigma_p^2\\end{bmatrix}\n由于为非负定的对称阵，所以存在正交矩阵，使下式成立。其中为的特征根，不妨设；是由特征根相对应的特征向量所组成的正交阵。U^T\\Sigma_xU=\\begin{bmatrix}\\lambda_1&0&\\cdots&0\\\\0&\\lambda_2&\\cdots&0\\\\\\vdots&\\vdots&\\ddots&\\vdots\\\\0&0&\\cdots&\\lambda_p\\end{bmatrix},U=\\begin{bmatrix}u_1\\\\u_2\\\\\\vdots\\\\u_p\\end{bmatrix}^T=\\begin{bmatrix}u_{1,1}&u_{1,2}&\\cdots&u_{1,p}\\\\u_{2,1}&u_{2,2}&\\cdots&u_{2,p}\\\\\\vdots&\\vdots&\\ddots&\\vdots\\\\u_{p,1}&u_{p,2}&\\cdots&u_{p,p}\\end{bmatrix}\n下面证明，由的第一列元素所构成的原始变量的线性组合有最大的方差。\n设有维单位向量，，则有：D\\left(y_1\\right)=\\sum\\limits_{i=1}^p\\lambda_ia_1^Tu_iu_i^Ta_1\\leq\\lambda_1\\sum\\limits_{i=1}^pa_1^Tu_iu_i^Ta_1=\\lambda_1a_1^TUU^Ta_1=\\lambda_1a_1^Ta_1=\\lambda_1\n当且仅当时，有最大方差。\n\n\n第二主成分\n增加约束条件，即\n\n\n\n\n性质\n的均值为。\n原总体的总方差（或称为总惯量）等于不相关的主成分的方差之和，即\n主成分与原始变量之间的相关系数称为因子负荷量（因子负荷量），且。\n贡献率指第个主成分的方差在全部方差中所占比重，即。\n累积贡献率指前个主成分的方差和在全部方差中所占比重，即。\n前个主成分对原始变量的贡献率为与之间的相关系数的平方，即。\n标准化后的随机变量的协方差矩阵就是原随机向量的相关矩阵。\n\n\n计算步骤\n主成分计算\n对样本进行标准化处理，得到标准化矩阵：X=\\left(x_{i,j}\\right)_{n\\times p}\n计算标准化后的每两个指标间的相关关系，得到相关系数矩阵，即个指标的协方差矩阵：R=\\dfrac1{n-1}X^TX=\\left(r_{i,j}\\right)_{p\\times p}=\\left(\\dfrac1{n-1}\\sum\\limits_{k=1}^nx_{i,k}x_{j,k}\\right)_{n\\times p}\n计算矩阵的特征根及相应的特征向量：\\begin{vmatrix}R-\\lambda E\\end{vmatrix}=\\begin{vmatrix}r_{1,1}-\\lambda_1&r_{1,2}&\\cdots&r_{1,p}\\\\r_{2,1}&r_{2,2}-\\lambda_2&\\cdots&r_{2,p}\\\\\\vdots&\\vdots&\\ddots&\\vdots\\\\r_{p,1}&r_{p,2}&\\cdots&r_{p,p}-\\lambda_p\\end{vmatrix}=0\n得到个非负特征根：\\lambda_1\\geq\\lambda_2\\geq\\cdots\\geq\\lambda_n\\geq0\n将这些特征根对应的单位化特征向量构成一个正交矩阵：a=\\left(a_{i,j}\\right)_{p\\times p}\n第个样本的主成分为：\\begin{bmatrix}z_{k,1}\\\\z_{k,2}\\\\\\vdots\\\\z_{k,n}\\end{bmatrix}=a\\begin{bmatrix}x_{k,1}\\\\x_{k,2}\\\\\\vdots\\\\x_{k,n}\\end{bmatrix}\n全部个样本的主成分为：Z^T=\\left(z_{j,i}\\right)_{p\\times n}=\\begin{bmatrix}z_{1,1}&z_{2,1}&\\cdots&z_{n,1}\\\\z_{1,2}&z_{2,2}&\\cdots&z_{n,2}\\\\\\vdots&\\vdots&\\ddots&\\vdots\\\\z_{1,p}&z_{2,p}&\\cdots&z_{n,p}\\end{bmatrix}=aX^T\n上式整理得：Z=Xa^T\n\n\n样本主成分选择\n第个主成分的贡献率：\\dfrac{\\lambda_k}{\\sum\\limits_{i=1}^p\\lambda_i}\n前个主成分的累计贡献率：\\dfrac{\\sum\\limits_{i=1}^k\\lambda_i}{\\sum\\limits_{i=1}^p\\lambda_i}\n\n\n原指标对主成分的回归B=a^T\n\n\nSPSS操作\n步骤\n选择主菜单【分析】→【描述统计】→【描述】。\n勾选【将标准化得分另存为变量】。\n选择主菜单【分析】→【降维】→【因子分析】。\n选择标准化后的【变量】。\n点击【描述】，在弹出的对话框中选择需要的描述统计量，一般勾选【系数】。\n点击【抽取】，在弹出的对话框中选择【方法】为【主成分】，选择【相关性矩阵】，勾选【碎石图】，选择【抽取】的方法。\n\n\n解读\n【相关矩阵】\n表示两两变量之间的相关系数。\n\n\n【解释的总方差】\n【合计】表示该主成分解释的方差。\n【方差的 %】表示该主成分解释的方差的占比。\n【累积 %】表示该主成分及其前面的主成分总共解释的方差的占比。\n【合计】下的数值表示按设定的抽取方法所提取的特征根。\n\n\n【碎石图】\n该图描述了不同主成分对应的特征根的大小。\n\n\n【成分矩阵】\n【成分】下每一列表示一个主成分的各个因子载荷，因子载荷除以对应特征值的算术平方根可以得到相应的主成分系数。\n\n\n\n\n\n\n\n时间序列分析与预测\nSPSS操作\n步骤\n季节性\n选择主菜单【数据】→【定义日期】。\n选择【年份、季度】，在右侧输入起始【年】和【季度】。\n选择主菜单【分析】→【预测】→【季节性分解】。\n选择待季节分解的【变量】，并设置【模型类型】（以【乘法】模型为例）。\n\n\n长期趋势\n选择主菜单【转换】→【计算变量】。\n【目标变量】输入TCI，【数字表达式】输入TSD / SAF_1，其中TSD表示原始序列数据的变量。\n选择主菜单【数据】→【定义日期】。\n选择【年份】，在右侧输入起始【年】为1。\n选择主菜单【分析】→【回归】→【线性】。\n【因变量】选择原始序列数据的变量，【自变量】选择定义的年份变量。\n选择主菜单【转换】→【计算变量】。\n【目标变量】输入T，并按回归模型输入【数字表达式】。\n\n\n周期性\n选择主菜单【转换】→【计算变量】。\n【目标变量】输入CI，【数字表达式】输入TCI / T。\n选择主菜单【转换】→【创建时间序列】。\n选择变量【CI】，【名称】输入C，【函数】选择【中心移动平均】，【跨度】输入3，点击【更改】。\n\n\n随机性\n选择主菜单【转换】→【计算变量】。\n【目标变量】输入I，【数字表达式】输入CI / C。\n\n\n预测\n在原始数据的末尾添加待预测的时间编号。\n按【长期趋势】中的方法计算待预测时间的【T】值。\n选择主菜单【转换】→【计算变量】。\n【目标变量】输入PRE，【数字表达式】输入T * SAF_1，其中PRE表示预测结果。\n\n\n\n\n解读\n【季节性因素】\n【季节性因素】下给出了四个季度（节）的季节性指数的百分比形式。\n\n\n\n\n\n\n\nAHP决策分析\n概念\n美国运筹学家A.L.Saaty于本世纪70年代提出的层次分析法（Analytical Hierar-chy Process，简称AHP方法)，是一种定性与定量相结合的决策分析方法。它是一种将决策者对复杂系统的决策思维过程模型化、数量化的过程。\n应用这种方法，决策者通过将复杂问题分解为若干层次和若干因素，在各因素之间进行简单的比较和计算，就可以得出不同方案的权重，为最佳方案的选择提供依据。\n\n\n基本原理\nAHP法首先把问题层次化，按问题性质和总目标将此问题分解成不同层次，构成一个多层次的分析结构模型，分为最低层（供决策的方案、措施等），相对于最高层（总目标）的相对重要性权值的确定或相对优劣次序的排序问题。\n\n\n特点\n分析思路清楚，可将系统分析人员的思维过程系统化、数学化和模型化。\n分析时需要的定量数据不多，但要求对问题所包含的因素及其关系具体而明确。\n这种方法适用于多准则、多目标的复杂问题的决策分析，广泛用于地区经济发展方案比较、科学技术成果评比、资源规划和分析以及企业人员素质测评。\n\n\n具体步骤\n明确问题\n在分析社会、经济的以及科学管理等领域的问题时，首先要对问题有明确的认识，弄清问题的范围，了解问题所包含的因素，确定出因素之间的关联关系和隶属关系。\n\n\n递阶层次结构的建立\n根据对问题分析和了解，将问题所包含的因素，按照是否共有某些特征进行归纳成组，并把它们之间的共同特性看成是系统中新的层次中的一些因素，而这些因素本身也按照另外的特性组合起来，形成更高层次的因素，直到最终形成单一的最高层次因素。\n最高层是目标层，中间层是准则层，最低层是方案层或措施层。\n\n\n建立两两比较的判断矩阵\n判断矩阵表示针对上一层次某单元（元素），本层次与它有关单元之间相对重要性的比较。该判断矩阵记为，且。\n在层次分析法中，为了使判断定量化，关键在于设法使任意两个方案对于某一准则的相对优越程度得到定量描述。一般对单一准则来说，两个方案进行比较总能判断出优劣，层次分析法采用到标度方法，对不同情况的评比给出数量标度。\n判断矩阵中的是根据资料数据、专家的意见和系统分析人员的经验经过反复研究后确定。应用层次分析法保持判断思维的一致性是非常重要的，只要矩阵中的各元素满足上述两条关系式时，就说明判断矩阵具有完全的一致性。\n判断矩阵一致性指标为。\n一致性指标的值越大，表明判断矩阵偏离完全一致性的程度越大，值越小，表明判断矩阵越接近于完全一致性。一般判断矩阵的阶数越大，人为造成的偏离完全一致性指标的值便越大；越小，值便越小。\n对于多阶判断矩阵，引入平均随机一致性指标。该值可以通过查表得到。\n当时，判断矩阵永远具有完全一致性。判断矩阵一致性指标与同阶平均随机一致性指标之比称为随机一致性比率，即。\n当时，便认为判断矩阵具有可以接受的一致性。当时，就需要调整和修正判断矩阵，使其满足，从而具有满意的一致性。\n\n\n层次单排序\n层次单排序就是把本层所有各元素对上一层来说，排出评比顺序，这就要计算判断矩阵的最大特征向量，最常用的方法是和积法和方根法。\n和积法具体计算步骤\n将判断矩阵的每一列元素作归一化处理，其元素的一般项为。\n将每一列经归一化处理后的判断矩阵按行相加为。\n对向量归一化处理：。\n向量即为所求的特征向量的近似解。\n计算判断矩阵最大特征根：。\n\n\n方根法具体计算步骤\n将判断矩阵的每一行元素相乘：。\n计算的次方根：。\n向量即为所求的特征向量的近似解。\n计算判断矩阵最大特征根：。\n\n\n\n\n层次综合排序\n利用层次单排序的计算结果，进一步综合出对更上一层次的优劣顺序，就是层次总排序的任务。\n\n\n\n\n\n","categories":["学科笔记"]},{"title":"《地统计学》笔记","url":"/posts/f0b52463/","content":"概论\n地统计学概念\n定义\n地统计学（又称地质统计学）是以区域化变量理论为基础，以变异函数为主要工具，研究在空间分布上既有随机性又有结构性，或空间相关和依赖性的自然现象的科学。\n\n\n具体方面\n理论基础：区域化变量理论\n主要工具：协方差函数和变异函数\n主要内容：克里金插值法\n\n\n\n\n研究内容\n空间估值\n局部不确定性预测\n随机模拟\n多点地统计学\n\n\n发展史\n国外\n20世纪50年代前：在其它非地质领域有应用，但没引起注意。\n20世纪50年代：D. J. Krige和H. S. Sichel的新矿藏评价方法的提出标志着地统计学雏形的形成。\n20世纪60、70年代：1962年 法国著名统计学家G. Matheron创立地统计学，地统计学理论和方法的进一步完善和改进。\n20世纪70年代末到90年代：大批地统计学研究理论和应用的专著出版。\n20世纪90年代之后：地统计学理论、方法及应用发展成熟并拓展，软件出现。\n\n\n国内\n起步阶段（1977年至1989年11月）\n1977年，地统计学由美国H. M. Parker博士传入我国。\n宣传普及、学习研讨、发表论文、有关工业部门和个别矿山企业根据自己的需要，独立进行开发研究，构成了该阶段的主要内容。\n\n\n第二阶段（1989年11月至1995年10月）\n1989年11月召开全国第一届地质统计学学术讨论会，标志着地统计学发展的第二阶段开始。\n从开发研究与学术交流活动转向生产实践，与地质勘探和矿山生产相结合。\n\n\n第三阶段（1995年10月至今）\n1995年，地质领域的有关部门公布了“运用地质统计学方法提交地质勘探报告的编写提纲和审查提纲”的试行意见。标志着地统计学技术在我国已经发展成熟，进入深入发展阶段。\n\n\n\n\n\n\n应用领域\n地质学\n矿产资源储量计算及平均品位估计\n矿产资源预测及找矿勘探\n石油勘探开发\n\n\n土壤学\n土壤物理性质空间变异\n土壤化学性质空间变异\n土壤学试验设计和采样方法\n土壤质量管理\n\n\n生态学\n生态学变量空间变异性的定量描述和解释\n生物特征的估计\n生态学研究对象的时空变化规律分析\n\n\n环境学\n土壤环境研究\n水环境研究\n其他相关领域研究\n\n\n气象学\n\n\n相关软件\nArcGIS地统计模块\nSurfer\nGeo-EAS\nGEOPACK\nGeostatistical Toolbox\nGSLIB\nGS+\n\n\n\n地统计学基础\n地理要素的数据类型\n地理数据是用一定的测度标准去描述或衡量地理要素而取得的地理信息。\n\n\n定量、定性地理数据分类\n间隔尺度数据：带单位的数据，如千克、摄氏度等。\n比例尺度数据：规定一个基点，再将其他量换算成与之的比例（没有单位）。\n有序数据：只表示次序关系的数据，如小雨为、中雨为、大雨为。\n二元数据：用和表示的数据。\n\n\n总体和样本\n总体\n定义\n根据统计分析或研究目的而确定的同类事物或现象的全体。\n\n\n理解\n总体可以指满足指定条件的元素或个体的集合。\n总体的范围根据研究目的而定，并非固定不变。\n总体可分为目的总体和抽样总体，并不是固定不变的。\n总体可分为定性总体（质量总体）和定量总体（数量总体）。\n根据总体包含的元素单位数是否有限，可分为有限总体和无限总体。\n\n\n\n\n样本\n定义\n从总体中抽取若干元素而构成的集合称为样本，也称子样。\n\n\n理解\n目的：从样本特性对总体特性作出统计估计与推断\n样本规模：能代表总体的抽样个数\n样本分布：均匀、特征点要有分布\n\n\n\n\n采样方法\n随机抽样\n机械抽样（系统采样）\n分层抽样\n分组抽样\n地质统计采样方法\n\n\n\n\n频数分布\n频数：在相同的条件下进行了次试验，在这次试验中，事件发生的次数称为事件发生的频数。\n频率：比值称为事件发生的频率，并记为。\n频数分布表\n离散数据频数分布表：直接统计样本值出现的次数和分组做频数分布表。\n连续数据频数分布表：确定组数、组距、各组的上下限，然后按样本值大小归组，要求：分组后能够真实的反映总体特征。\n累积频率（数）分布表：将各组的频数依次相加就得到累积频数值。\n\n\n频数分布图\n直方图：用矩形的宽度和高度来表示频数分布的图形，横轴表示数据分组，纵轴表示频数或频率。\n多边形图：在直方图的基础上，把直方图顶部的中点（即组中值）用直线连接起来，再把原来的直方图去掉。\n条形图：用宽度相同的条形的高度或长短来表示数据变动的图形，条形图可以横置或纵置。\n\n\n\n\n统计特征数\n集中性\n算数平均数：\n中数\n众数\n\n\n离散性\n极差（全距）\n四分位差\n离差：\n平均离差：\n离差平方和：\n\n\n总体方差：\n总体标准差：\n变异系数：\n\n\n形态数\n偏态数（偏度系数）\n定义：对分布偏斜方向和程度的测定\n公式：\n评价：为负偏态（右偏）；为分布对称；为正偏态（左偏）。\n\n\n峰态数（峰度系数）\n定义：用来反映频数分布曲线顶端尖峭或扁平程度的指标\n公式：\n评价：为低阔峰；为正态分布；为高狭峰。\n\n\n\n\n\n\n相关分析\n相关关系概念\n函数关系：某一个或某几个现象的变动会引起另一个现象确定的变动，它们之间的关系可以用数学函数表示出来。\n相关关系：两个或多个现象之间虽然存在某种关系，但这种关系是不确定或不确切的函数关系。\n\n\n相关关系种类\n按相关关系的程度分\n完全相关\n不完全相关\n不相关（零相关）\n\n\n按相关变化方向分\n正相关\n负相关\n\n\n按相关形式分\n线性相关\n非线性相关\n\n\n按变量数量分\n单相关\n复相关\n偏相关\n\n\n\n\n主要内容\n确定现象之间有无相关关系以及相关关系的表现形态\n确定相关关系的密切程度\n\n\n相关关系测定\n相关表\n相关图\n\n\n相关程度测定\n协方差\n公式\n定义：\n总体：\n样本：\n\n\n特点\n可定量的表示两个变量之间的相关程度。\n值为正时，为正相关；值为负时，为负相关。\n不存在相关关系时，值趋于零或为零。\n协方差值受数据值大小的影响。\n协方差值是一个有量纲单位的数值。\n\n\n\n\n相关系数\n公式\n\n\n\n\n说明\n两个变量之间的相关程度和方向取决于两个变量离差乘积之和。\n相关程度的大小与计量单位无关，相关系数是无量纲的数量。\n相关系数是用来说明变量之间在直线相关条件下相关关系密切程度和方向的统计分析指标，一般只适用于测定变量间的线性相关关系。\n若两随机变量相互独立，则协方差和相关系数均为，两者线性不相关；反之若两随机变量线性不相关，则两者不一定线性不相关。\n\n\n意义\n：不存在线性相关关系\n：微或无（极低度）线性相关\n：低度线性相关\n：显著（中度）线性相关\n：高度相关\n：完全线性正（负）相关\n\n\n检验步骤\n提出原假设和备择假设：假设样本相关系数是抽自具有零相关的总体，即。\n查临界值：规定显著性水平 ，并依据自由度，查分布表确定临界值。\n计算检验的统计量：计算。\n做出判断：若，则认为两变量线性相关（不线性相关的可能性只有）；反之认为在给定置信水平下两变量不线性相关。\n\n\n\n\n偏相关系数\n概念\n在多要素所构成的地理系统中，先不考虑其他要素的影响，而单独研究两个要素之间的相互关系的密切程度，这称为偏相关。\n用以度量偏相关程度的统计量，称为偏相关系数。\n当总共有个变量，固定其中的个，研究剩下的变量时，计算的相关系数称为级相关系数。\n\n\n说明\n只有级偏相关系数才真实地反映了研究的两个相关变量间线性相关的性质与程度。\n级偏相关系数共有个。\n\n\n三个变量的偏相关系数\n\n\n\n\n\n显著性检验\n方法：检验\n统计量：\n\n\n\n\n复相关系数\n公式\n\n\n\n显著性检验\n方法：检验\n统计量：\n\n\n与偏相关系数的关系\n复相关系数必大于或至少等于单相关系数的绝对值，如。\n\n\n\n\n\n\n\n\n回归分析\n概念\n回归分析就是对具有高度相关关系的现象，根据其相关的形态，建立一个适宜的数学模型（回归方程），来近似地反映变量之间的一般变化关系，以便于进行估计或预测的统计方法。\n\n\n种类\n按涉及自变量的数量分\n一元回归分析\n多元回归分析\n\n\n按回归方程的表现形式分\n线性回归分析\n非线性回归分析\n\n\n\n\n主要内容和步骤\n确定变量：根据理论和对问题的分析判断，将变量分为自变量和因变量。\n建立模型：找出合适的数学方程式（即回归模型）描述变量间的关系。\n统计检验：对回归模型进行统计检验。\n估计预测：利用回归模型，根据自变量去估计、预测因变量。\n\n\n一元线性回归模型\n基本结构\n\n\n\n概念\n设，其中不依赖于，有，则称为一元线性回归方程。\n若记参数、的拟合值分别为（回归常数）、（回归系数），则一元线性经验回归方程（简称回归方程）为，其中为的估计值。\n\n\n前提条件\n两个变量之间确实存在显著的相关关系\n两种变量之间确实存在着直线相关关系\n\n\n参数、的最小二乘估计\n记，表示实际观测值与回归值之差。\n使。\n由于为非负二次函数，其最小值一定存在，同时是、的可微函数，则与应是下面方程组的解：\n整理得下面正规方程组：\n解得：\n同时可以说明经过散点图的几何中心。\n\n\n显著性检验\n方法：检验\n相关符号定义\n总的离差平方和：\n剩余平方和（残差平方和）：\n回归平方和：\n决定系数（判断系数）：\n\n\n统计量：\n方程显著条件：\n\n\n\n\n多元线性回归模型\n回归方程\n\n\n\n参数的最小二乘估计\n使的必要条件为：\n整理得下面正规方程组：\n引入下面的矩阵：\n则有，解得。\n\n\n显著性检验\n方法：检验\n统计量：\n\n\n\n\n\n\n相关分析与回归分析比较\n联系\n相关分析是回归分析的基础和前提\n回归分析是相关分析的继续和深化\n\n\n区别\n相关分析中两变量对等，改变两者的地位，并不影响相关系数的数值，只有一个相关系数；回归分析中两变量要确定自变量和因变量，互为因果关系的两个变量可以编制两个独立的回归方程。\n相关分析中两变量均为随机变量；回归分析中只有因变量为随机变量。\n相关分析测定是否存在相关关系及相关程度和方向；回归分析则是建立回归方程，并用回归模型进行预测和控制。\n\n\n\n\n\n区域化变量理论\n随机场\n随机变量\n定义\n设随机实验的样本空间为，若对于，都有一个实数与之对应，且对于任意实数，事件都有确定的概率，则称是一个随机变量。\n\n\n理解\n随机变量本身是一个函数，定义域是样本空间。\n随机变量是一实值变量，有一个可能的取值范围，范围随实验不同而不同。\n随机变量的取值随实验结果而定，在实验之前不能预知其取什么值。\n随机变量的取值具有一定的概率，随机变量是具有一定概率分布的变量。\n随机变量和对随机变量的观测，可从总体和抽样的角度来理解。对随机变量每次的观测结果是一个确定的数值，该数值称为随机变量的一个实现。\n\n\n\n\n随机函数\n定义\n设随机实验的样本空间为，对于任一，都有一个函数与之对应（其中），且当各自变量取任意固定值时，函数为一随机变量，则称是定义在上的一个随机函数。\n\n\n理解\n横向：每次随机实验（或观测）的结果都可得到一个确定性的函数，称为随机函数的一个实现，因此随机函数可理解为它的所有实现的集合。\n纵向：随机函数可理解为具有个参数的随机变量族。\n\n\n\n\n随机过程\n定义\n当随机函数中只有一个自变量，且（一般表示时间或距离）时，称为随机过程，记为。\n\n\n理解\n横向：随机过程是所有实现的集合。\n纵向：随机过程是依赖于一个参数的一族随机变量。\n\n\n\n\n随机场\n定义\n当随机函数依赖于多个自变量时，称随机场。\n\n\n三元随机场的理解\n随机场中是依赖于三个参数（空间点的三个直角坐标）的一族随机变量，称为区域化变量。\n随机场是其所有实现的集合，每一个实现都是一个三元实值函数或空间点函数。\n\n\n\n\n\n\n区域化变量\n区域化\n定义\n一个变量呈现为空间分布。\n\n\n\n\n区域化变量\n定义\n以空间点的三个直角坐标为自变量的随机场。\n\n\n与普通随机变量的不同\n普通随机变量的取值按某种概率分布而变化，而区域化变量则根据其在一个域内的位置取不同的值。\n即区域化变量是普通随机变量在域内确定位置上的特定取值，它是随机变量与位置有关的随机函数。\n\n\n\n\n性质\n结构性：区域化变量具有一般的或平均的结构性质，即在空间两个不同点及（为向量）处的数值与具有某种程度的相关性，这种相关性依赖两点间的向量及研究变量特征。\n随机性：区域化变量是一个随机场，具有局部的、随机的、异常的性质。当空间一点固定之后，就是一个随机变量。\n空间局限性：区域化变量往往只存在于一定的空间范围内，如矿石品位只存在于矿化空间内、群落中某一林分类型的分布。这一空间称为区域化变量的几何域。\n不同程度的连续性：不同的区域化变量具有不同程度的连续性，连续性可通过相邻样点之间的变异函数来描述。\n不同类型的各向异性：区域化变量如果在各个方向上的性质变化（变异）相同，则称为各向同性若在各个方向上变异不同，则称为各向异性。\n\n\n\n\n相关前置公式及性质\n数学期望\n设为常数，则。\n设为随机变量，为常数，则。\n设与为随机变量，则。\n设与为互相独立的随机变量，则。\n\n\n方差\n\n设为常数，则。\n设为随机变量，为常数，则。\n设与为随机变量，则。\n设与为互相独立的随机变量，则。\n\n\n协方差\n\n设与为常数，则。\n设、与为随机变量，则。\n\n\n\n\n协方差函数\n随机过程的协方差函数\n随机过程在时刻处两个随机变量,的二阶混合中心矩成为随机过程的协方差函数，记为或。\n\n\n区域化变量的协方差函数\n在空间两点和（为向量）处两个随机变量,的 二阶混合中心矩成为随机过程的协方差函数，记为或。\n当时，有，称为先验方差函数，记为。\n\n\n实际计算\n设区域化变量满足（准）二阶平稳假设，为两样本点空间分隔距离，和分别是在空间位置和上的观测值（），则计算协方差公式如下：\n其中与分别表示与的样本平均数。\n\n\n协方差函数性质\n\n\n\n时，即\n为非负定函数\n\n\n\n\n变异函数\n定义\n在任一方向上，相距的两个区域化变量值和的增量的方差，记为。\n\n\n公式\n\n\n\n实际计算\n设区域化变量满足（准）二阶平稳假设或（准）本征假设，为两样本点空间分隔距离，和分别是在空间位置和上的观测值（），则计算实验变异函数如下：\n例题：一研究对象在水平方向上的采样数据（至依次从左往右排布），满足二阶平稳假设或本征假设，采样值如表所示，点间分隔距离，计算。\n列出数据对查找表：\n计算变异函数值：\n\n\n\n\n性质\n\n\n\n时，即\n为非负定函数\n\n\n功能\n\n变异函数通过“变程”反映变量的影响范围\n通常变异函数为一单调递增函数，当超过某一正值后，变异函数不再继续单调地增大，而往往稳定在一个极限值附近，这种现象称为“跃迁现象”。\n此时称为变程，称为基台值。\n在二阶平稳假设下，。\n变程表示区域化变量从存在空间相关状态（当时）转向不存在空间相关状态（当时）的转折点。\n变程的大小反映区域化变量影响范围的大小，或说反映该变量自相关范围的大小。也可说变程是区域化变量空间变异尺度或空间自相关尺度。\n基台值的大小反映区域化变量变化幅度的大小，即反映区域化变量在研究范围内变异的强度。\n凡具有一个变程和一个基台值的变异函数，称为“跃迁型”的变异函数。\n\n\n不同方向上的变异函数图可反映区域化变量的各向异性\n如果在各个方向上区域化变量的变异性相同或相近，则称区域化变量是各向同性的，反之称为各向异性。\n各向同性是相对的，各向异性是绝对的。\n\n\n块金常数的大小可反映区域化变量的随机性大小\n的现象被称为“块金效应”，被称为块金常数或块金方差。\n块金常数反应了区域化变量内部随机性的可能程度。\n产生原因之一：微观结构，即区域化变量在小于抽样尺度时所具有的变异性，当样点间的距离大于微域结构的范围，或样点样品的大小大于微域结构的范围就会出现块金效应。\n产生原因之二：采样、测量和分析等误差。\n\n\n\n\n\n变异函数在原点处的性状可反映区域化变量的空间连续性\n抛物线型\n线性型\n间断型\n随机型\n过渡型（实际研究工作中最常遇到）\n\n\n\n\n\n\n协方差函数与变异函数的关系\n\n\n\n\n\n\n\n\n地统计学理论假设\n平稳假设\n设某一区域化变量的任意维度分布函数不因空间点发生位移而改变，即对于，都有。\n简单来说，即只依赖于，而与无关。\n\n\n二阶平稳假设（弱平稳假设）\n条件\n整个研究区内的数学期望均存在，且等于常数，即，其中为常数。\n整个研究区内的协方差函数存在且平稳，即。\n\n\n推论\n协方差（函数）平稳意味着方差（函数）和变异函数的平稳。\n在二阶平稳假设条件下，变异函数、协方差函数和方差函数三者之间有重要的关系，即。\n协方差函数和变异函数都表示相距为的两个变量和之间的自相关特性，这时是两个等效的函数。\n空间相关函数为。\n\n\n准二阶平稳假设\n区域化变量在有限大小的邻域内满足二阶平稳假设，则称其满足准二阶平稳假设。\n\n\n\n\n本征假设（内蕴假设）\n条件\n整个研究区内，区域化变量的增量的数学期望为，即。若存在，则等价于，其中为常数。\n整个研究区内，区域化变量的增量的方差函数存在且平稳，即。\n\n\n准本征（内蕴）假设\n区域化变量在有限大小的邻域内满足本征（内蕴）假设，则称其满足准本征（内蕴）假设。\n\n\n\n\n\n\n\n变异函数结构分析\n变异函数的理论模型\n有基台值模型\n纯块金效应模型\n公式\n参数说明\n：块金常数（等于先验方差）\n\n\n\n\n球状模型\n公式\n参数说明\n：块金常数\n：拱高（偏基台值、结构方差）\n：基台值\n：变程\n\n\n标准球状模型\n\n\n\n\n\n\n指数模型\n公式\n参数说明\n：块金常数\n：拱高（偏基台值、结构方差）\n：基台值\n：变程（因为）\n\n\n标准指数模型\n\n\n\n\n\n\n高斯模型\n公式\n参数说明\n：块金常数\n：拱高（偏基台值、结构方差）\n：基台值\n：变程（因为）\n\n\n标准高斯模型\n\n\n\n\n\n\n线性有基台值模型\n公式\n参数说明\n：块金常数\n：拱高（偏基台值、结构方差）\n：基台值\n：变程\n：直线斜率（常数）\n\n\n\n\n\n\n无基台值模型\n线性无基台值模型\n公式\n参数说明\n：块金常数\n：直线斜率（常数）\n\n\n\n\n幂函数模型\n公式\n参数说明\n：取值范围为的幂指数\n：常数\n\n\n\n\n对数模型\n公式\n参数说明\n：常数\n\n\n\n\n\n\n孔穴效应模型\n当变异函数在大于一定的距离后，并非单调递增，而是以一定的周期进行波动，此时变异函数曲线就显示出一种“孔穴效应”。\n\n\n\n\n变异函数的结构分析\n结构分析\n就是构造一个变异函数模型对于全部有效结构信息作定量化的概括，以表征区域化变量的主要特征。\n\n\n结构分析的主要方法\n套合结构\n\n\n套合结构\n就是把分别出现在不同距离上和（或）不同方向上同时起作用的变异性组合起来，分为单一方向上的套合结构和不同方向上的套合结构。\n\n\n套合结构表达式\n套和结构可以表示为多个变异函数之和，每一个变异函数代表一种特定尺度上的变异性，即。\n例子\n设区域化变量在某一方向上的变异性是由、和组成：\n微观尺度为纯块金效应模型：\n变程为的球状模型：\n变程为（）的球状模型：\n则套合结构：\n\n\n\n\n\n\n变异函数理论模型的最优拟合\n定义\n根据变异函数的计算值，选择合适的理论模型来拟合一条最优的理论变异函数曲线，通常称为最优拟合。\n\n\n分类\n人工拟合\n自动拟合\n最小二乘法\n加权回归法\n\n\n\n\n\n\n结构分析的基本步骤\n区域化变量选择\n根据研究目的而定\n要有明确物理意义\n最好能定量表示\n\n\n数据的审议\n空间取样设计：方式、样点间距离大小、样本数量的大小、采样密度、取样方法\n数据代表性：采样均匀性、时空一致性等\n\n\n数据的统计分析\n基本分析：平均值、方差、标准差、变异系数等\n相关分析：协同克里金法\n异常值识别及处理：全局和局部离群值\n分布检验及数据转换\n\n\n变异函数的计算\n等间距的规则网格数据\n全部采样\n随机采样\n\n\n非等间距的不规则网格数据\n分组采样\n角度分组：与角度在范围内的归为一组\n距离分组：与相距归为一组\n\n\n具体实现\n扇区分组\n步长（）\n太大会掩盖区域化变量的局部微观结构。\n太小会产生很多空步长组或组内样点对很少。\n一般满足步长乘以步长组数等于样点间最大距离的一半。\n\n\n角度容限值（）\n太大会包含其他方向上的变异。\n太小会造成组数增加，计算量增加，某些组内的样点对可能过少，变异函数可靠性差。\n\n\n\n\n格网分组\n格网分组后的表面成为变异函数表面。\n表面中每一个栅格为一个组。\n颜色代表变异函数的大小。\n图案关于中心对称。\n\n\n\n\n\n\n\n\n变异函数的结构分析——各向异性\n结构分析的目的在于通过分析各种实验变异函数来分析所研究的区域化现象的主要结构特征。\n\n\n理论变异函数模型的最优拟合及检验\n变异函数理论模型的专业分析\n\n\n\n克里金法\n估计方差\n概念\n若某一区域化变量在某一点处的实际值为，其估计值为，则估计误差为。\n若该区域化变量满足二阶平稳假设，则估计误差也满足二阶平稳假设，估计误差的数学期望为（为常数），估计方差（估计误差的方差）为。\n\n\n估计量评价\n无偏性：\n最优性：\n\n\n线性估计量（线性平稳地统计学）\n假设要根据位于点（）的个样品值来估计中心点在、体积为的块段的平均值为, 显然估计量是诸的函数。\n通常采用线性函数，即，其中为每个样品点的权重。\n无偏性条件为。\n上述无偏性条件下的估计方差为。\n\n\n\n\n克里金法概述\n定义\n又称空间局部估计或空间局部插值法，是建立在变异函数理论及结构分析基础上，在有限区域内对区域化变量的取值进行线性无偏最优估计的一种方法。\n\n\n种类\n线性平稳地统计学范畴\n简单克里金法\n普通克里金法\n\n\n线性非平稳地统计学范畴\n泛克里金法\n\n\n非线性地统计学范畴\n对数正态克里金法\n指示克里金法\n概率克里金法\n析取克里金法\n\n\n多元地统计学范畴\n协同克里金法\n\n\n\n\n估计量\n表达式\n\n\n\n参数说明\n：研究区域内任一点的位置\n：权重系数\n\n\n条件\n无偏性：\n最优性：\n\n\n\n\n估值过程\n数据检查\n模型拟合\n模型诊断\n模型比较\n\n\n\n\n简单克里金法\n假设\n区域化变量满足二阶平稳假设\n区域化变量数学期望为已知的常数\n协方差函数和变异函数存在且平稳\n\n\n变形：\n估计量：\n方程组\n参数求解矩阵\n估计方差：\n估计值求算：\n例题：已知个点（编号为至）的坐标与高程（均值为已知常数）和待估点（编号为）的坐标，用简单克里金法插值高程。\n参数求解矩阵\n估计值求算：\n估计方差：\n\n\n\n\n普通克里金法\n假设\n区域化变量满足二阶平稳假设\n区域化变量数学期望为未知的常数\n协方差函数和变异函数存在且平稳\n\n\n估计量：\n方程组\n协方差函数形式\n参数求解矩阵：\n估计方差：\n\n\n变异函数形式\n参数求解矩阵：\n估计方差：\n\n\n估计值求算：\n例题：已知个点（编号为至）的坐标与高程（均值为未知常数）和待估点（编号为）的坐标，用简单克里金法插值高程。\n参数求解矩阵\n估计值求算：\n估计方差：\n\n\n块段估计\n点采样数据：将块段离散成若干点，求采样点和各离散点之间的协方差函数或变异函数值之和，后取平均值（除以块段离散成的点数）。\n块段采样数据：将采样和待估块段都离散成若干点，求各采样块段离散点和各待估块段离散点之间的协方差函数或变异函数值之和，后取平均值（除以两块段离散成的点数之积）。\n\n\n\n\n克里金法的内涵\n基于采样数据反映的区域化变量的结构信息（变异函数或协方差函数提供），根据待估点或块段有限邻域内的采样点数据，考虑样本点的空间相互位置关系（矩阵）、与待估点的空间位置关系（矩阵），对待估点进行的一种线性无偏最优估计，并且能给出估计精度，比其他传统方法更精确、更符合实际。\n\n\n克里金法的几点说明\n总体特征\n克里金矩阵和估计构形：数据构形相同，矩阵就相同。\n表达式通用性：不论采样数据和待估数据为点或块段，不论协方差函数和变异函数表征为何种结构模型，克里金方程组和克里金估计方差完全通用。\n估计可靠性。\n若已知协方差函数或变异函数，则可提前计算克里金估计方差，用于指导采样设计。\n\n\n权重系数特点\n可减弱丛聚效应：在克里金估计中，不会由于一些样点丛聚在一起而增大其权重系数（假设各向同性）。\n屏蔽效应：相近方向上的两点，距离近的一点的权重远大于远的一点的权重。屏蔽效应与块金常数有很大的关系。\n权重可正可负性：可获取大于最大或小于最小的样本值的插值结果。\n块金值的大小对权重影响：增加块金值会使插值过程更接近于简单算术平均。极端情形——纯块金效应模型，样本权重相同，结果为样本的算术平均。\n\n\n理论模型对克里金估计的影响\n偏基台值\n越大：变异越强，距离近的权重就越大，估计难度也越大，估计方差越大。\n越小：变异越弱，距离近的权重就越小，估计难度也越小，估计方差越小。\n\n\n变程\n越大：变异越平缓，距离近的权重就越小，估计难度越小，估计方差越小。\n越小：变异越剧烈，距离近的权重就越大，估计难度越大，估计方差越大。\n\n\n块金值\n越大：屏蔽效应减弱，距离近的权重就越小，同时样点间相关性也越小，估计难度越大，估计方差越大。\n越小：屏蔽效应增强，距离近的权重就越大，同时样点间相关性也越大，估计难度越小，估计方差越小。\n\n\n\n\n\n\n泛克里金法\n漂移\n定义\n非平稳区域化变量的数学期望，在任一点上的漂移就是该点上区域化变量的数学期望。形式化表达为。\n\n\n用邻域模型的研究\n在给定的以点为中心的邻域内的任一点其漂移可用如下函数表示：\n其中为已知函数（常为多项式），为未知系数。\n实际工作中，根据中心点有限邻域内的全部有效数据计算该邻域的漂移，一般只需要一次或二次多项式。\n\n\n\n\n涨落\n对于有漂移的区域化变量，假设可分解为漂移和涨落两部分，形式化表示为。其中为该点处的漂移，为涨落。\n上述分解可以理解为：是由两个不同尺度的现象合成的，是在较大尺度下可以观察到的现象变化，是在较小尺度下的现象变化。\n涨落的数学期望为。\n\n\n\n\n\n空间确定性插值\n探索性数据分析\n检查数据分布\n目的：探查数据、分析数据的特征\n工具\n直方图\nQQPlot图\nBox-Cox变换：\nlog变换：\n反正弦变换：\n\n\n\n\n\n\n寻找全局和局部离群值\n全局离群值：对于数据集中所有点的值，具有很高或很低值的观测样点。\n局部离群值：在数据集中，对于其周围点的值具有很高或很低值的观测样点。\n工具\n直方图\n半变异/协方差函数云图\n半变异函数云图：\n协方差函数云图：\n\n\nVonoroi图\n生成方法：多边形内任何位置到这一样点的距离都比该多边形到其他样点的距离要近。\n\n\n\n\n\n\n全局趋势分析\n目的：地统计分析时，为满足平稳假设，要剔除全局趋势。剔除后，可模拟随机短期变异。为合理预测，之后必须将全局趋势再还原回去。\n工具\nTrend Analysis工具\n\n\n\n\n检测空间自相关及方向变异\n工具\n半变异/协方差函数云图\n\n\n\n\n\n\n空间确定性插值\n插值定义\n空间插值：将离散的数据点转化为连续的数据曲面。\n内插：在已观测点的区域内估算未观测点的数据的过程。\n外推：在已观测点的区域外估算未观测点的数据的过程。\n\n\n插值法分类（加粗者包含克里金法）\n根据已知插值数据的不同\n点插值法\n面（区域）插值法\n\n\n根据插值时采用的数据点数不同\n全局（整体）插值法\n局部插值法\n\n\n根据插值方法是否提供预测的误差评价\n确定性插值法（不提供）\n统计插值法（提供）\n\n\n根据插值后表面是否通过采样点\n精确插值法\n非精确（近似）插值法\n\n\n\n\n径向基函数插值法\n概念\n径向基函数插值法是一系列精确插值方法的统称。\n\n\n条件\n生成的表面经过每个采样点\n表面有最小的曲率\n\n\n\n\n交叉验证\n首先从采样数据集中删除一点，然后使用其它采样值点估计此删除点的值，最后计算此点实测值和估计值的差，重复以上步骤直到遍历所有采样点。\n均方根预测误差：\n标准化均方根预测误差：\n\n\n验证\n将采样数据集分成两个子集：一个称为训练数据集，用于趋势分析及预插值；一个称为检验数据集，用于插值精度检测。\n若检验效果好，则将全部数据用于插值预测。\n\n\n\n\n\n软件操作\n简单克里金法\n数据集设置：[Dataset]中可以设置源数据集和需要插值的字段。\n克里金法及数据趋势参数设置：左侧[Kriging Type]选择[Simple]，[Output Surface Type]选[Prediction]；右侧[Dataset #1]中[Transformation Type]选择一个合适的数据变形，[Order of trend removal]按照ESDA的趋势分析选择合适的多项式拟合阶数。\n全局趋势函数类型及参数设置：右侧[General Properties]中[Kernel Function]可以设置对变量空间趋势拟合的函数类型。\n半变异/协方差函数建模：右侧[General]中[Variable]可以选择显示半变异函数或协方差函数的表面，[Model Nugget]中可以设置块金效应的建模参数，[Model #1]中可以选择区域化变量的理论模型（如球状模型[Spherical]并开启各向异性[Anisotropy]）。\n搜索邻域范围设置：右侧[Search Neighborhood]可以设置搜索邻域的相关参数。\n预测结果的交叉验证：观察[Regression function]上方的回归直线方程（深色）是否与1:1线（浅色）吻合情况。\n生成简单克里金预测表面图\n\n\n普通克里金法\n数据集设置\n克里金法及数据趋势参数设置：左侧[Kriging Type]选择[Ordinary]；其余与简单克里金类似。\n全局趋势函数类型及参数设置\n半变异/协方差函数建模\n搜索邻域范围设置\n预测结果的交叉验证\n生成普通克里金预测表面图\n\n\n指示克里金法\n数据集设置\n克里金法及数据趋势参数设置：左侧[Kriging Type]选择[Indicator]，[Output Surface Type]按需求选择[Probability]或者[Standard Error of Indicators]；右侧[Dataset #1]中两者都设置为[None]（指示克里金法无需假设数据来自正态分布）；右侧[Primary Threshold]中可以设置主阈值相关参数；右侧[Cutoffs]改变[Number of Cutoffs]值可以设置多个阈值。\n半变异/协方差函数建模\n搜索邻域范围设置\n预测结果的交叉验证\n生成指示克里金概率表面图\n\n\n外推\n双击生成的预测表面图层，切换至[Extent]选项卡，将[Set the extent to]改为[the rectanglar extent of provin_srtm]，其中[provin_srtm]为边界面要素图层。\n\n\n假裁切\n双击[Layers]，切换至[Data Frame]选项卡，[Clip Option]中选择[Clip to shape]，点击[Specify Shape]按钮。\n在弹出的对话框中选择[Outline of feature]，[Layer]选[provin_srtm]，其中[provin_srtm]为边界面要素图层。\n\n\n真裁切\n右击克里金预测表面图层，选择[Data]下的[Export to Raster]，选择一个无中文的路径保存栅格数据。\n打开[ArcToolbox]中[Spatial Analyst Tools]下[Extraction]下的[Extract by Mask]。\n在弹出的对话框中，[Input raster]选择上述保存的栅格文件，[Input raster or feature mask data]选[provin_srtm]（[provin_srtm]为边界面要素图层），[Output raster]选择保存的路径。\n\n\n训练/检验数据集生成及使用\n打开[Geostatistical Analyst]菜单下的[Subset Features]。\n在弹出的对话框中，[Input feature]选待插值的点要素图层，[Output training feature class]选择训练数据集的保存路径，[Output test feature class]选择检验数据集的保存路径，[Size of training feature subset]输入90。\n对生成的训练数据集点要素图层进行克里金插值。\n在上述生成的表面图层上右击，选择[Validation/Prediction]。\n在弹出的对话框中，[Input point observation locations]选上述生成的检验数据集点要素图层，[Field to validate on]选择上述插值的字段，[Output statistics at point locations]选择保存结果的文件路径。\n右击新生成的点要素图层，选择[Open Attribute Table]，滚动至最右侧即可查看检验结果。\n\n\nExcel操作\n纬度（度）位于E2:E677，海拔高度位于F2:F677，温度位于G2:G677。\n相关系数：CORREL(array1, array2)\n海拔温度：=CORREL(F:F,G:G)\n纬度温度：=CORREL(E:E,G:G)\n\n\n检验（双尾反函数）：T.INV.2T(probability, deg_freedom)\n：=T.INV.2T(0.01,676-2)\n\n\n一元线性回归截距：INTERCEPT(known_y's, known_x's)\n温度与海拔的回归方程参数：=INTERCEPT(G:G,F:F)\n\n\n一元线性回归斜率：SLOPE(known_y's, known_x's)\n温度与海拔的回归方程参数：=SLOPE(G:G,F:F)\n\n\n多元线性回归：LINEST(known_y's, [known_x's], [const], [stats])\n备注：该数组函数需要一个的空间，其中为自变量个数。\n温度与维度、海拔的回归系数：=LINEST(G2:G677,E2:F677,TRUE,TRUE)\n\n\n矩阵求逆：MINVERSE(array)\n矩阵相乘：MMULT(array1, array2)\n矩阵转置：TRANSPOSE(array)\n\n\n\n","categories":["学科笔记"]},{"title":"《空间数据库原理》笔记","url":"/posts/c42be008/","content":"\n2021年2月28日更新：由于课程内容变化，重新修订本笔记，同时保留原内容于引用块。\n\n数据库系统概论\n数据库基本概念\n数据\n定义\n人们用来反映客观世界而记录下来的可以鉴别的数字、字母或符号，可以存储在某一种媒体上。\n\n\n\n\n数据库（DB）\n定义\n长期存储在计算机内、有组织、可共享、可以表现为多种形式的数据集合。\n\n\n特点\n按一定的数据模型组织、描述和存储\n具有较小的冗余度\n具有较高的数据独立性和易扩展性\n可被用户共享\n\n\n\n\n数据库管理系统（DBMS）\n定义\n位于用户与操作系统之间的一层数据管理软件。\n\n\n主要功能\n数据定义\n数据操作\n数据库运行控制\n数据库的建立和维护\n\n\n\n\n数据库系统（DBS）\n定义\n拥有数据库基础支持的计算机系统。\n\n\n特点\n数据的结构化\n最小的冗余度\n数据的共享\n数据与程序独立\n数据的安全性和完整性\n\n\n\n\n\n\n数据库系统的组成\n硬件与软件\n数据库管理系统\n数据库系统\n数据库管理员\n用户\n\n\n三级模式与二级映射\n三级模式\n外模式（子模式、用户模式）\n数据库用户能看见和使用的局部数据的逻辑结构和特征的描述\n数据和用户的数据视图\n与某一应用有关的数据的逻辑表示\n一个应用程序只能使用一个外模式\n\n\n模式（逻辑模式、概念模式）\n数据库中全体数据的逻辑结构和特征的描述\n所有用户的公共数据视图\n数据库系统模式结构的中间层\n一个数据库只有一个模式\n\n\n内模式（存储模式）\n数据库在物理存储器上具体实现的描述\n数据在数据库内部的表示方法\n对数据物理结构和存储方式的描述\n一个数据库只有一个内模式\n\n\n\n\n二级映射\n外模式/模式映射\n定义了外模式与模式之间的对应关系\n把用户数据库与概念数据库联系起来\n保证了数据库的逻辑独立性\n\n\n模式/内模式映射\n定义了数据全局逻辑结构与存储结构之间的对应关系\n把概念数据库与物理数据库联系起来\n保证了数据与程序的物理独立性\n\n\n\n\n\n\n\n空间数据库\n空间数据\n定义\n空间数据是对空间事物的描述，实质上就是指以地球表面空间位置为参照，用来描述空间实体的位置、形状、大小及其分布特征诸多方面信息的数据。\n\n\n特征\n时空特征\n多维特征\n多尺度性\n空间多尺度\n时间多尺度\n\n\n海量数据特征\n\n\n类型\n概括性\n地图数据\n影像数据\n地形数据\n属性数据\n\n\n4D产品\nDEM（数字高程模型）\nDLG（数字线划图）\nDOM（数字正射影像图）\nDRG（数字栅格地图）\n\n\n\n\n\n\n空间数据库\n定义\n空间数据库是描述与特定空间位置有关的真实世界对象的数据集合，这些对象称为空间参考对象。空间数据库既要能处理空间参考对象类型，也要能处理非空间参考对象类型。\n\n\n作用\n空间数据处理与更新\n海量数据存储与管理\n空间分析与决策\n空间信息交换与共享\n\n\n问题\n数据共享问题\n数据瓶颈问题\n数据安全问题\n\n\n特点\n综合抽象特征\n非结构化特性\n分类编码特征\n复杂性与多样性\n\n\n与传统数据库的差异方面\n信息描述\n数据管理\n数据操作\n数据更新\n服务应用\n\n\n\n\n\n关系数据库模型\n数据模型\n定义\n严格定义的一组概念的集合。\n\n\n三要素\n数据结构\n数据操作\n数据的约束条件（数据完整性）\n\n\n\n\n概念模型\n定义\n也称信息模型，是人们为正确直观地反映客观事物及其联系，对研究的信息世界建立的一个抽象的模型，是现实世界到信息世界的第一层抽象，是数据库设计人员和用户之间进行交流的语言。\n\n\n\n\n实体之间的联系\n一对一联系\n一对多联系\n多对多联系\n\n\n关系模型及其相关概念\n关系模型：实体和联系均用二维表来表示的数据模型。\n关系模式：二维表的表头所在行，又称表的框架或记录类型。\n关系：对应于关系模式的一个具体的表，又称表。\n元组：关系中的每一行（不含表头），又称行或记录。\n属性：关系中的每一列，又称列。\n\n\n关系模型优缺点\n优点\n由于实体和联系都用关系描述，保证了数据操作语言的一致性。\n结构简单直观，用户容易理解。\n有严格的设计理论。\n存取路径对用户透明，从而具有更高的独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作量。\n\n\n缺点\n由于存取路径对用户透明，导致查询速度慢，效率低于非关系型数据模型。\n\n\n\n\n关系的性质\n列是同质的，即每一列中的分量是同一类型的数据，来自同一个域。\n关系中的任意两个元组不能相同。\n关系中的相同的列可以出自相同的域，但必须有不同的属性名。\n关系中行和列的顺序可以任意互换，不会改变关系的意义。\n关系中的每一个分量都必须是不可分的数据项，元组分量具有原子性。\n\n\n关系的完整性\n实体完整性\n定义：若属性是基本关系的主属性，则属性不能取空值。\n理解：基本关系的所有主属性都不能取空值，而不仅是主码整体不能取空值。\n意义：保证了关系中主码属性值的正确性。\n\n\n参照完整性\n定义：设是基本关系的一个或一组属性，但不是关系的码，若与一基本关系的主码相对应，则称的基本关系的外码。其中基本关系称为参照关系，基本关系称为被参照关系或目标关系。\n理解：表的外码必须为另一个表主码的有效值，或为空值。\n意义：定义了外码与主码之间的引用规则，保证了关系之间能够进行正确的联系。\n\n\n用户定义的完整性\n定义：用户按照实际的数据库应用系统运行环境要求，针对某一具体关系数据库定义的约束条件。\n理解：反映的是某一聚义应用所涉及的数据必须满足的语义要求。\n\n\n\n\n关系代数\n定义\n关系代数是一种抽象的查询语言，用对关系的运算来表达查询。每个运算都以一个或者多个关系（对象）作为它的运算对象，并生成另外一个关系作为该运算的查询结果。\n\n\n关系代数的运算\n传统的集合运算\n并：\n差：\n交：\n广义笛卡尔积：\n\n\n专门的关系运算\n选择\n定义\n\n\n\n理解\n从关系中找出满足逻辑表达式的元组。\n是从行的角度进行的运算。\n\n\n\n\n投影\n定义\n\n\n\n理解\n从关系中挑出某些属性构成新的关系，结果是一个表的列的子集，结果将取消某些列产生的重复元组。\n投影之后不仅取消了某些列，而且还有可能取消某些元组。\n是从列的角度进行的运算。\n\n\n\n\n连接\n定义\n连接：\n等值连接：\n自然连接：\n\n\n理解\n将两个或多个关系连接在一起，形成一个新的关系。\n连接运算的结果是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。\n\n\n\n\n象集\n定义\n若关系中与为互为补集的两个属性集，当时，在中的象集为。\n\n\n理解\n表示中属性组上值为的诸元组在属性组上分量的集合。\n本质为一次选择运算和一次投影运算。\n结果等于所有值等于的元组，然后在上的投影，即。\n\n\n\n\n除\n定义\n若有关系与，则。\n\n\n理解\n除运算得到的是一个新关系，是中满足下列条件的元组在属性列上的投影：元组在上分量值的象集包含在在上投影的集合。\n是从行和列的角度进行的运算。\n\n\n\n\n\n\n\n\n\n\n\n空间信息模型\n空间对象\n定义\n对地理现象进行观察、抽象、综合取舍而得到的实体目标。\n\n\n类型\n点\n线\n面\n体\n\n\n\n\n空间数据结构\n定义\n空间数据结构是指适用于计算机系统存储、管理和处理的地学图形的逻辑结构，是地理实体（空间对象）的空间排列方式和相互关系的抽象描述，它是对数据的理解和解释。\n\n\n分类\n矢量结构\n栅格结构\n\n\n\n\n空间信息模型\n对象模型：将研究的整个地理空间看成一个空域，地理现象和空间实体作为独立的对象分布在该空域中，对象模型强调地理空间中的单个地理现象。按照其空间特征分为点、线、面、体四种基本对象。\n网络模型：网络是由一系列节点和环链组成的，在本质上，网络模型可看成对象模型的一个特例，它是由点对象和线对象之间的拓扑空间关系构成的。\n场模型：把地理空间中的现象作为连续的变量或体来看待，如大气污染程度、地表温度、土壤湿度、地形高度以及大面积空气和水域的流速和方向等。\n\n\n空间数据组织（结构）\n矢量数据结构\n定义\n矢量数据结构是利用欧几里得几何学中的点、线、面及其组合体来表示地理实体空间分布的一种数据组织方式。\n\n\n特点\n点线面单体化\n属性信息丰富\n编辑更新方便\n公共边界信息冗余\n点线面拓扑关系维护复杂\n\n\n\n\n栅格数据结构\n定义\n栅格数据结构是指将空间分割成有规则的网格，称为栅格单元，在各个栅格单元上给出相应的属性值来表示地理实体的一种数据组织形式。\n\n\n特点\n地理要素表达直观\n数据结构相对简单\n定位精度比矢量低\n拓扑关系缺失\n局部数据更新复杂\n\n\n\n\n数字高程模型数据组织\n定义\n以一定范围内规则格网点的平面坐标（）及其高程（）的数据集来描述区域地貌形态的空间分布。\n\n\n分类\n格网数据组织\n不规则三角网模型\n\n\n\n\n地物三维模型数据组织\n定义\n三维矢量模型是二维中点、线、面矢量模型在三维中的推广，它将三维空间中的实体抽象为三维空间中的点、线、面、体四种基本元素，然后以这四种基本几何元素的集合来构造更复杂的对象。\n\n\n\n\n\n\n空间数据模型\n定义\n地理空间数据模型是关于现实世界中空间实体分布、发展变化及其相互联系的概念框架，是空间数据库系统中关于空间数据和数据之间联系逻辑组织形式的表示，是有效地组织、存储、管理各类空间数据的基础。它以抽象的形式描述系统的运行与信息流，为描述空间数据的组织和设计空间数据库模型提供支持。\n\n\n分类\n多尺度空间数据模型\n地理要素分层模型\n面向对象空间数据模型\n时空数据模型\n连续快照模型\n基态修正模型\n时空复合模型\n时空立方体模型\n\n\n\n\n\n\n\n结构化查询语言\nSQL语言基本知识\n定义\n结构化查询语言简称SQL，是一种数据库查询和设计程序语言，用于存取数据库以及查询、更新和管理关系数据库系统。\n\n\n组成\n数据定义语言（DDL）\n数据操作语言（DML）\n数据控制语言（DCL）\n\n\n特点\n综合统一\n高度非过程化\n面向集合的操作方式\n以同一种语言结构提供多种使用方式\n以简捷的自然语言作为操作语言\n\n\n\n\n定义基本表\n基本语法CREATE TABLE &lt;表名&gt; (    &lt;列名&gt; &lt;数据类型&gt; [列级完整性约束条件],    &lt;列名&gt; &lt;数据类型&gt; [列级完整性约束条件],    ...,    [表级完整性约束条件]);\n参数说明\n常用数据类型\nint\ndecimal(数据长度, 小数位)\ndatetime\nchar(字符串固定长度)\n\n\n常用完整性约束\n唯一性约束：列级UNIQUE：不能取相同值但允许多个空值\n非空值约束：列级NOT NULL：不能取空值\n主键约束：列级PRIMARY KEY、表级PRIMARY KEY (列1,列2,...,列n)\n\n\n\n\n例：建立一个“学生选课”表SC，它由学号Sno、课程号Cno，修课成绩Grade组成，其中(Sno, Cno)为主码。CREATE TABLE SC (    Sno char(5),    Cno char(3),    Grade decimal(4, 1),    PRIMARY KEY (Sno, Cno));\n\n\n增加字段\n基本语法ALTER TABLE &lt;表名&gt; ADD &lt;新列名&gt; &lt;数据类型&gt; [列级完整性约束条件];\n例：向Stu表增加联系电话Stel列，数据类型为位字符型。ALTER TABLE Stu ADD Stel char(11);\n\n\n修改字段类型\n基本语法ALTER TABLE &lt;表名&gt; ALTER COLUMN &lt;列名&gt; &lt;新数据类型&gt; [新列级完整性约束条件];\n例：修改Stu表成绩Sscore字段为整数型。ALTER TABLE Stu ALTER COLUMN Sscore int;\n\n\n删除字段\n基本语法ALTER TABLE &lt;表名&gt; DROP COLUMN &lt;列名&gt;;\n\n\n删除表\n基本语法DROP TABLE &lt;表名&gt;;\n\n\n创建索引\n基本语法CREATE [UNIQUE] [CLUSTERED] INDEX &lt;索引名&gt; ON &lt;表名&gt; (    &lt;列名&gt; [&lt;次序&gt;],    &lt;列名&gt; [&lt;次序&gt;],    ...);\n参数说明\nUNIQUE：此索引的每一个索引值只对应唯一的数据记录\nCLUSTERED：建立聚簇索引\n次序\nASC：升序（默认值）\nDESC：降序\n\n\n\n\n例：在Stu表上建立一个学号Sno字段的降序聚簇索引，索引名为Sno_Index。CREATE CLUSTERED INDEX Sno_Index ON Stu (    Sno DESC);\n\n\n删除索引\n基本语法DROP INDEX &lt;索引名&gt;;\n\n\n查询语句\n基本语法SELECT [重复值指示] &lt;目标列表达式&gt; [[AS] &lt;别名&gt;], &lt;目标列表达式&gt; [[AS] &lt;别名&gt;], ...FROM &lt;表名或视图名&gt;, &lt;表名或视图名&gt;, ...[WHERE &lt;条件表达式&gt;][GROUP BY &lt;分组列名&gt; [HAVING &lt;分组条件表达式&gt;]][ORDER BY &lt;排序列名&gt; [&lt;次序&gt;], &lt;排序列名&gt; [&lt;次序&gt;], ...];\n参数说明\n重复值指示\nALL：不取消重复行（默认值）\nDISTINCT：取消重复行\n\n\n次序\nASC：升序（默认值）\nDESC：降序\n\n\n\n\n\n\n插入数据\n基本语法INSERT INTO &lt;表名&gt; [(&lt;属性列&gt;, &lt;属性列&gt;, ...)]VALUES (&lt;常量&gt;, &lt;常量&gt;, ...);\n\n\n修改数据\n基本语法UPDATE &lt;表名&gt;SET &lt;列名&gt;=&lt;表达式&gt;, &lt;列名&gt;=&lt;表达式&gt;, ...[WHERE &lt;条件表达式&gt;];\n\n\n删除数据\n基本语法DELETE FROM &lt;表名&gt; [WHERE &lt;条件表达式&gt;];\n\n\n定义视图\n基本语法CREATE VIEW &lt;视图名&gt; [&lt;列名&gt;, &lt;列名&gt;, ...]AS &lt;查询子语句&gt; [WITH CHECK OPTION];\n参数说明\n查询子语句\n子查询可以是任意复杂的SELECT语句，但通常不允许含有GROUP BY子语句和DISTINC短语。\n\n\nWITH CHECK OPTION\n防止用户通过视图对数据进行更新、插入、删除操作。\n当尝试更新、插入、删除操作时，DBMS会检查视图中定义的条件，若不满足视图定义中的谓词条件（子查询中的条件表达式），则拒绝执行。\n\n\n\n\n例：建立XSheng表上所有院系YXi为计算机学院学生信息（学号XHao、姓名XMing、性别XBie、年龄NLing）的视图Jsj_Studentinfo。CREATE VIEW Jsj_Studentinfo [(XHao, XMing, XBie, NLing)]AS SELECT XHao, XMing, XBie, NLing FROM XSheng WHERE YXi = '计算机学院'[WITH CHECK OPTION];\n\n\n删除视图\n基本语法DROP VIEW &lt;视图名&gt;;\n\n\n\n\n空间查询语言\n地域实例上的OGC方法\nSTArea()\nSTBuffer(distance)\nSTContains(other_geography)\nSTCrosses(other_geography)\nSTDisjoint(other_geography)\nSTIntersects(other_geography)\nSTLength()\nSTTouches(other_geometry)\nSTWithin(other_geometry)\n\n\n\n关系模式的规范化理论\n三个方面\n数据依赖：核心、数据之间的联系\n范式：关系模式的标准\n模式设计方法：自动化设计的基础\n\n\n一个冗余和三个异常\n数据冗余\n插入异常\n删除异常\n修改异常\n\n\n函数依赖（FD）\n定义及符号\n设是属性集上的关系模式，和为的子集，若对于的任意一个可能的关系，中不可能存在两个元组在上的属性值相等但在上的属性值不等，则称函数确定（或称函数依赖于），其中称为决定因素，记作。\n非平凡函数依赖：\n平凡函数依赖：\n互相依赖：\n不依赖：\n\n\n完全函数依赖\n定义：在中，若且对于的任何一个子集，都有，则称对完全函数依赖，记作。\n理解：的真子集均不能确定。\n\n\n部分函数依赖\n定义：在中，若但不完全依赖于，则称对部分函数依赖，记作。\n\n\n传递函数依赖\n定义：在中，若，则有，称传递函数依赖于，记作。\n备注：若即，则直接函数依赖于；若，则。\n\n\n\n\n码和属性\n候选码：设为关系模式中的属性或属性组，若，则称为的一个候选码。候选码常常简称为码。\n主码：若一个关系模式有多个候选码，则选定其中的一个做为主码。其两个性质为决定性（）和最小性（）。\n全码：由关系模式的所有属性构成码。\n外码：也称外部码，关系模式中属性或属性组并非的码，但是另一个关系模式的码，则称是的外码。\n主属性：所有候选码中出现的属性。\n非主属性：不出现在任何候选码中的属性。\n\n\n范式\n定义\n范式是符合某一类满足一定要求的关系模式的集合。关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式。\n\n\n第一范式\n定义：对于给定的关系，如果中每个属性都是不可再分的，则称关系属于第一范式，记作。\n理解：大表不能套小表。\n意义：保证了原子性。\n问题：数据冗余度大、插入异常、删除异常、修改异常\n\n\n第二范式\n定义：若，且每一个非主属性完全依赖于码，则为第二范式，记作。\n理解：不存在非主属性对码的部分依赖。\n意义：通过投影分解消除了部分依赖。\n问题：数据冗余度大、插入异常、删除异常、修改复杂\n\n\n第三范式\n定义：若，且每一个非主属性既不部分依赖于码，也不传递依赖于码，则为第三范式，记作。\n理解：不存在非主属性对码的传递依赖。\n意义：消除了传递依赖。\n\n\nBC范式\n定义：若，对于每一个（），都包含码，即该关系中每一个决定因素都包含码，则为BC范式，记作。\n推论：\n\n\n\n\n\n\n\n数据库系统概论\n数据库基本概念\n数据管理技术演变\n人工管理阶段\n文件系统阶段\n数据库技术阶段\n\n\n数据库技术演变\n层次/网状系统\n关系系统\n新一代数据库系统家族\n\n\n数据\n定义\n人们用来反映客观世界而记录下来的可以鉴别的数字、字母或符号，可以存储在某一种媒体上。\n\n\n含义\n信息：描述事物特征的数据内容\n符号：存储在某一种媒体上的数据形式\n\n\n\n\n数据库（DB）\n定义\n长期存储在计算机内、有组织、可共享、可以表现为多种形式的数据集合。\n\n\n特点\n按一定的数据模型组织、描述和存储\n具有较小的冗余度\n具有较高的数据独立性和易拓展性\n可被用户共享\n\n\n\n\n数据库管理系统（DBMS）\n定义\n位于用户与操作系统之间的一层数据管理软件。\n\n\n主要任务\n科学有效地组织和存储数据\n高效地获取和管理数据\n接受和完成用户提出的访问数据的各种请求\n\n\n主要功能\n数据定义\n数据操作\n数据库运行控制\n数据库建立和维护\n\n\n\n\n数据库系统（DBS）\n定义\n拥有数据库基础支持的计算机系统。\n\n\n组成\n数据库\n数据库管理系统\n开发工具\n应用系统\n数据库管理员\n用户\n\n\n特点\n数据的结构化\n最小的冗余度\n数据的共享\n数据与程序独立\n数据的安全性和完整性\n\n\n\n\n\n\n数据库系统的组成\n硬件\n数据库系统（数据库管理员）\n数据库管理系统（数据库管理员）\n数据库应用系统（用户）\n\n\n数据库系统的结构\n最终用户角度\n集中式\n分布式\n客户/服务器\n并行结构\n\n\n数据库管理系统角度\n三级模式\n外模式（子模式、用户模式）\n数据库用户能看见和使用的局部数据的逻辑结构和特征的描述\n数据和用户的数据视图\n与某一应用有关的数据的逻辑表示\n一个应用程序只能使用一个外模式\n\n\n模式（逻辑模式、概念模式）\n数据库中全体数据的逻辑结构和特征的描述\n所有用户的公共数据视图\n数据库系统模式结构的中间层\n一个数据库只有一个模式\n\n\n内模式（存储模式）\n数据库在物理存储器上具体实现的描述\n数据在数据库内部的表示方法\n对数据物理结构和存储方式的描述\n一个数据库只有一个内模式\n\n\n\n\n二级映射\n外模式/模式映射\n定义了外模式与模式之间的对应关系\n把用户数据库与概念数据库联系起来\n保证了数据库的逻辑独立性\n\n\n模式/内模式映射\n定义了数据全局逻辑结构与存储结构之间的对应关系\n把概念数据库与物理数据库联系起来\n保证了数据与程序的物理独立性\n\n\n\n\n\n\n\n\n\n空间数据库\n空间数据\n定义\n空间数据是对空间事物的描述，实质上就是指以地球表面空间位置为参照，用来描述空间实体的位置、形状、大小及其分布特征诸多方面信息的数据。\n\n\n特征\n时空特征\n空间特性：空间实体的空间位置及其与其他空间实体的空间关系\n属性特性：地学现象的数量、质量和分类等属性信息\n时态特性：地理数据采集或地理现象发生的时刻或时段\n\n\n多维特征\n多尺度性\n空间多尺度\n时间多尺度\n\n\n海量数据特征\n\n\n\n\n空间数据库\n定义\n空间数据库是描述与特定空间位置有关的真实世界对象的数据集合，这些对象称为空间参考对象。空间数据库既要能处理空间参考对象类型，也要能处理非空间参考对象类型。\n\n\n作用\n空间数据处理与更新\n海量数据存储与管理\n空间分析与决策\n空间信息交换与共享\n\n\n问题\n数据共享问题\n数据“瓶颈”问题\n数据安全问题\n\n\n特点\n综合抽象特征：空间数据的抽象性包括人为地取舍数据。\n非结构化特性：表达成一个空间对象的记录的数据项可能是变长的。\n分类编码特征：每一个空间对象都有一个分类编码，一种地物类型对应一个属性数据表文件。\n复杂性与多样性：空间数据源广、量大，时有类型不一致、数据噪声大的问题。\n\n\n与传统数据库的差异方面\n信息描述\n数据管理\n数据操作\n数据更新\n服务应用\n\n\n\n\n\n数据模型\n数据模型\n定义\n严格定义的一组概念的集合。\n\n\n分类\n概念模型：按用户的观点进行数据信息建模，用于数据库设计。\n数据模型：按计算机系统的观点对数据建模，用户数据库管理系统设计。\n\n\n三要素\n数据结构\n数据操作\n数据约束条件（完整性）\n\n\n\n\n概念模型\n定义\n也称信息模型，是人们为正确直观地反映客观事物及其联系，对研究的信息世界建立的一个抽象的模型，是现实世界到信息世界的第一层抽象，是数据库设计人员和用户之间进行交流的语言。\n\n\n相关术语\n实体：客观存在并可相互区别的事物。\n属性：实体所具有的特征。\n域：属性的取值范围。\n实体型：用实体名及其属性名集合来抽象和刻画同类实体，如学生(学号,姓名,年龄,性别,院系,年级)。\n实体集：具有相同属性的实体的集合。\n键（关键字、码）：能够唯一地标识出一个实体集中每一个实体的属性或属性组。\n联系：现实世界中事物内部和事物之间是有联系的，这些联系在信息世界中反映为实体（型）内部和实体（型）之间的联系。\n\n\n实体之间的联系\n一对一联系\n一对多联系\n多对多联系\n\n\nE-R模型\n实体：矩形\n属性：椭圆\n联系：菱形\n\n\n\n\n数据模型分类\n层次模型（树状）\n网状模型（网状）\n层次模型数据库性能优于关系模型数据库，不低于网状数据库。\n关系模型（见下）\n面向对象的模型\n\n\n关系模型\n定义\n实体和联系均用二维表来表示的数据模型。\n一张二维表由行和列组成，且每一列都是不可再分的数据项。\n\n\n基本概念\n关系模式（表的框架、记录类型）：二维表的表头一行，即对关系结构的描述。\n关系（表）：对应于关系模式的一个具体的表。\n元组（行、记录）：关系中的每一行。\n属性（列、字段）：关系中的每一列。\n属性名：给属性起的名字。\n属性域：关系中的每一属性所对应的取值范围。\n分量：元组的一个属性值。\n主键：关系模式中能唯一标识对应于该关系模式中任何一个元组的某个或某几个属性组成的属性组。\n外键（外码）：某关系内，不是该关系的主键，但是另一关系的主键的某一属性组。\n\n\n完整性约束（见下一章）\n实体完整性\n参照完整性\n用户定义完整性\n\n\n优点\n由于实体和联系都用关系描述，保证了数据操作语言的一致性。\n结构简单直观，用户容易理解。\n有严格的设计理论。\n存取路径对用户透明，从而具有更高的独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作量。\n\n\n缺点\n由于存取路径对用户透明，导致查询速度慢，效率低于非关系型数据模型。\n\n\n\n\n\n关系数据库模型\n概述\n三要素\n关系数据结构\n关系操作集合\n关系完整性约束\n\n\n关系操作（操作对象和结果都是集合）\n查询\n选择\n投影\n连接\n除\n并\n交\n差\n\n\n增加\n删除\n修改\n\n\n完整性约束\n实体完整性\n参照完整性\n用户定义的完整性\n\n\n\n\n关系数的数学定义\n域\n定义\n一组具有相同数据类型的值的集合。\n域中数据的个数称为域的基数。\n\n\n举例\n自然数集\n\n\n\n\n\n\n笛卡尔积\n定义\n给定一组域（可以有相同的域），则笛卡尔积为。\n每个称为元组。\n元组中每一个值称为分量。\n\n\n举例\n\n\n\n\n\n关系\n定义\n笛卡尔积的子集称为在域上的关系，记作。\n称为关系名。\n称为关系的度或目，该关系称为元关系（时称为单元关系）。\n\n\n举例\n\n\n\n相关概念\n属性：列的名字。\n候选码：关系中能唯一地标识一个元组的某一属性组。\n主码：若一个关系中有多个候选码，选定其中一个作为主码。\n主属性：主码的各个属性。\n非码属性：不包含在任何候选码内的属性。\n全码：关系模式的所有属性组是这个关系的候选码。\n\n\n\n\n关系的三种类型\n基本关系（基本表、基表）：实际存在的表，是实际存储数据的逻辑表示。\n查询表：查询结果对应的表。\n视图表：由基本表或其他视图导出的表，是虚表，不对应实际存储的数据。\n\n\n\n\n关系的性质\n列是同质的，即每一列中的分量是同一类型的数据，来自同一个域。\n关系中的任意两个元组不能相同。\n关系中的相同的列可以出自相同的域，但必须有不同的属性名。\n关系中行和列的顺序可以任意互换，不会改变关系的意义。\n关系中的每一个分量都必须是不可分的数据项，元组分量具有原子性。\n\n\n关系模式\n定义\n对关系结构的描述称为关系模式。\n\n\n形式化表示\n\n：关系名\n：组成该关系的属性名集合\n：属性的域\n：属性向域的映像集合\n：属性间数据的依赖关系\n\n\n\n\n关系的完整性\n实体完整性\n定义：若属性是基本关系的主属性，则属性不能取空值。\n理解：基本关系的所有主属性都不能取空值，而不仅是主码整体不能取空值。\n意义：保证了关系中主码属性值的正确性。\n\n\n参照完整性\n定义：设是基本关系的一个或一组属性，但不是关系的码，若与一基本关系的主码相对应，则称的基本关系的外码。其中基本关系称为参照关系，基本关系称为被参照关系或目标关系。\n理解：表的外码必须为另一个表主码的有效值，或为空值。\n意义：定义了外码与主码之间的引用规则，保证了关系之间能够进行正确的联系。\n\n\n用户定义的完整性\n定义：用户按照实际的数据库应用系统运行环境要求，针对某一具体关系数据库定义的约束条件。\n理解：反映的是某一聚义应用所涉及的数据必须满足的语义要求。\n\n\n\n\n关系代数\n定义\n关系代数是一种抽象的查询语言，用对关系的运算来表达查询。每个运算都以一个或者多个关系（对象）作为它的运算对象，并生成另外一个关系作为该运算的查询结果。\n\n\n关系代数的运算\n传统的集合运算\n并：\n差：\n交：\n广义笛卡尔积：\n\n\n专门的关系运算\n选择\n定义\n\n\n\n理解\n从关系中找出满足逻辑表达式的元组。\n是从行的角度进行的运算。\n\n\n\n\n投影\n定义\n\n\n\n理解\n从关系中挑出某些属性构成新的关系，结果是一个表的列的子集，结果将取消某些列产生的重复元组。\n投影之后不仅取消了某些列，而且还有可能取消某些元组。\n是从列的角度进行的运算。\n\n\n\n\n连接\n定义\n连接：\n等值连接：\n自然连接：\n\n\n理解\n将两个或多个关系连接在一起，形成一个新的关系。\n连接运算的结果是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。\n\n\n\n\n象集\n定义\n若关系中与为互为补集的两个属性集，当时，在中的象集为。\n\n\n理解\n表示中属性组上值为的诸元组在属性组上分量的集合。\n本质为一次选择运算和一次投影运算。\n结果等于所有值等于的元组，然后在上的投影，即。\n\n\n\n\n除\n定义\n若有关系与，则。\n\n\n理解\n除运算得到的是一个新关系，是中满足下列条件的元组在属性列上的投影：元组在上分量值的象集包含在在上投影的集合。\n是从行和列的角度进行的运算。\n\n\n\n\n\n\n\n\n\n\n关系演算\n定义\n用谓词来描述关系的构成（查询的结果）。按照谓词变元的不同分为元组关系演算和域关系演算，分别简称为元组演算和域演算。\n\n\n元组演算的等价规则\n\n\n\n\n\n\n\n\n\n\n结构化查询语言\nSQL特点\n综合统一。\n高度非过程化。\n面向集合的操作方式。\n以同一种语法结构提供两种使用方法。\n不是一个应用程序开发语言，只提供对数据库的操作能力，不能完成屏幕控制、菜单管理、报表生成等功能。\n书写简单，易学易用。\n\n\nSQL组成\n数据定义语言（DDL）\n数据操作语言（DML）\n数据控制语言（DCL）\n\n\nSQL与三级模式体系结构\n\n关系模式的规范化理论\n三个方面\n数据依赖：核心、数据之间的联系\n范式：关系模式的标准\n模式设计方法：自动化设计的基础\n\n\n一个冗余和三个异常\n数据冗余\n插入异常\n删除异常\n修改异常\n\n\n函数依赖（FD）\n定义及符号\n设是属性集上的关系模式，和为的子集，若对于的任意一个可能的关系，中不可能存在两个元组在上的属性值相等但在上的属性值不等，则称函数确定（或称函数依赖于），其中称为决定因素，记作。\n非平凡函数依赖：\n平凡函数依赖：\n互相依赖：\n不依赖：\n\n\n完全函数依赖\n定义：在中，若且对于的任何一个子集，都有，则称对完全函数依赖，记作。\n理解：的真子集均不能确定。\n\n\n部分函数依赖\n定义：在中，若但不完全依赖于，则称对部分函数依赖，记作。\n\n\n传递函数依赖\n定义：在中，若，则有，称传递函数依赖于，记作。\n备注：若即，则直接函数依赖于；若，则。\n\n\n\n\n码和属性\n候选码：设为关系模式中的属性或属性组，若，则称为的一个候选码。候选码常常简称为码。\n主码：若一个关系模式有多个候选码，则选定其中的一个做为主码。其两个性质为决定性（）和最小性（）。\n全码：由关系模式的所有属性构成码。\n外码：也称外部码，关系模式中属性或属性组并非的码，但是另一个关系模式的码，则称是的外码。\n主属性：所有候选码中出现的属性。\n非主属性：不出现在任何候选码中的属性。\n\n\n范式\n定义\n范式是符合某一类满足一定要求的关系模式的集合。关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式。\n\n\n第一范式\n定义：对于给定的关系，如果中每个属性都是不可再分的，则称关系属于第一范式，记作。\n理解：大表不能套小表。\n意义：保证了原子性。\n问题：数据冗余度大、插入异常、删除异常、修改异常\n\n\n第二范式\n定义：若，且每一个非主属性完全依赖于码，则为第二范式，记作。\n理解：不存在非主属性对码的部分依赖。\n意义：通过投影分解消除了部分依赖。\n问题：数据冗余度大、插入异常、删除异常、修改复杂\n\n\n第三范式\n定义：若，且每一个非主属性既不部分依赖于码，也不传递依赖于码，则为第三范式，记作。\n理解：不存在非主属性对码的传递依赖。\n意义：消除了传递依赖。\n\n\nBC范式\n定义：若，对于每一个（），都包含码，即该关系中每一个决定因素都包含码，则为BC范式，记作。\n推论：\n\n\n\n\n多值依赖（MVD）\n定义及符号\n在关系模式（为全集的子集且）的任一关系中，如果存在元组和，使得，且交换和在上的分量构成的新元组也在中，则称多值依赖于，记为。\\begin{array}{|c|c|c|c|}\\hline&X&Y&Z\\\\\\hline t&x&y_1&z_1\\\\\\hline s&x&y_2&z_2\\\\\\hline w&x&y_1&z_2\\\\\\hline v&x&y_2&z_1\\\\\\hline\\end{array}\n非平凡多值依赖：\n平凡多值依赖：\n\n\n性质\n对称性：若，则。\n传递性：若，则。\n函数依赖是多值依赖的特殊情况：若，则。\n若，则。\n若，则。\n若，则。\n\n\n与函数依赖的区别\n有效性\n若在上成立，则在包含和的任一的子集成立。\n若在上成立，则在上一定成立，其中。反之则不然。若对于有在上成立，其中，则称为的嵌入型多值依赖。\n\n\n包含性\n若在上成立，则对于任何均有成立。\n若在上成立，不能断言对于任何均有成立。\n\n\n\n\n第四范式\n定义：若，对于每个非平凡多值依赖（），都包含码，则为第四范式，记作。\n\n\n\n\n数据依赖的公理系统\n公理系统\n定义：给定一组公式（公理）和推理规则，由这些公式依据推理规则得到更多的公式，公理、规则和推导出的公式构成公理系统。如欧氏几何即为公理系统。\n有效性：通过推理规则得到的公式（形式推演）与通过逻辑推理得到的结论（逻辑推论）一致，即形式推演的结论是有效的。\n完备性：通过逻辑推理得到的结论（逻辑推论），都可以用形式推演得到，逻辑推理是完备的。\n\n\n函数依赖的公理系统（Armstrong公理系统）\n逻辑蕴含：设关系模式，其中是属性集上的函数依赖集，，对其任何一个关系实例，若函数依赖都成立，则称逻辑蕴含，记作。\n三条推理规则\n(A1)自反律：若，则。\n(A2)增广律：若，则。\n(A3)传递律：若，则。\n\n\n定义：由自反律(A1)、增广律(A2)和传递律(A3)三条推理规则构成Armstrong公理系统。\n\n\n函数依赖集的闭包\n定义：在关系模式中为所逻辑蕴含的函数依赖的全体叫作的闭包，记作。\n意义：包含了给定函数依赖集（部分）所蕴涵的属性集上的全部函数依赖。\n缺点：这些依赖信息太多太庞杂，很难管理和利用。\n\n\n属性集的闭包\n定义：设为属性集上的一组函数依赖，，关于函数依赖集的闭包。\n求解算法\n令，。\n令。\n若已没有使得，算法结束，；否则，令，转上一步。\n\n\n例题：已知关系模式，其中，，求。\n令。\n逐一的扫描集合中各个函数依赖，找左部为的子集（即、或）的函数依赖，有、，于是。\n因为，算法继续。\n找出左部为的子集的函数依赖，有、、、，于是。\n因为，算法结束，。\n\n\n定理：设为属性集上的一组函数依赖，，能由根据Armstrong公理导出的充分必要条件是。\n\n\n最小函数依赖集\n等价函数依赖集：设在关系模式上有两个函数依赖集和，若，则称和是等价的，或称与相互覆盖。\n定理一：当且仅当且时。\n意义：给出了两个函数依赖集等价的判定方法。\n定义：如果函数依赖集满足下列条件，则称为一个极小函数依赖集（亦为最小依赖集或最小覆盖）。\n中任一函数依赖的右部仅含有一个属性。\n中不存在这样的函数依赖，使得与等价。\n中不存在这样的函数依赖，使得有真子集满足与等价。\n\n\n求解算法\n对中每一个函数依赖，若（），则用替换。\n对中每一个函数依赖，若，逐一考察，若，则用替换，其中称为无关属性。\n对于中的每一个函数依赖，若，则从中去掉。\n\n\n定理二：每一函数依赖集均与其对应的最小函数依赖集等价。\n例题：设关系模式上的函数依赖集，求的最小函数依赖集。\n右部属性分离：对每个函数依赖右部属性分离，得。\n去掉左部冗余属性：因为，包含，所以中的为冗余属性，以取代之，得。\n去掉多余函数依赖：可以得到，所以多余，应去掉，得。\n\n\n结论：一个给定的函数依赖集的最小函数依赖集不是唯一的，因为在求解过程中由于考察函数依赖的次序的不同会产生不同的结果，但一个函数依赖集的所有最小函数依赖集是等价的（都等价于）。\n\n\n候选码求解算法\n相关概念：对于给定的关系模式，依照函数依赖集将中的属性分为以下四类。\nL类属性：在中只出现在函数依赖的左部的属性。\nR类属性：在中只出现在函数依赖的右部的属性。\nLR类属性：分别出现在中的函数依赖左部和右部的属性。\nN类属性：不在中的函数依赖中出现的属性。\n\n\n结论\nL类属性和N类属性必包含于任何候选码中。\nR类属性必不包含于任何候选码中。\nLR类属性不能确定是在码中。\n\n\n求解算法\n依照函数依赖集将中的所有属性分为L类、R类、LR类和N类属性，令为L、N类属性的集合，为LR类属性集合。\n若，则为的唯一候选码，算法结束；否则，转下一步。\n逐一取中的单一属性，若，则为候选码，令＝，转下一步。\n依次取中的任意两个、三个……属性，与组成属性组，若不包含已求得的候选码，求其关于的闭包，若，则为候选码。直到取完中的所有属性为止，算法结束。\n\n\n例题：设，函数依赖集，求的所有候选码。\n中无L、N类属性，均为LR类属性。\n取，则，故为候选码；取、、，三者各自的闭包均不等于全属性集；取，则，故为候选码。\n在中任取两个属性判定：，故为候选码；不等于全属性集，故不为候选码；，故为候选码。\n包含已求得的候选码，故不是码，算法结束。\n\n\n\n\n数据依赖的公理系统总结\nA1（FD的自反律）：若，则。\nA2（FD的增广律）：若，则。\nA3（FD的传递律）：若，则。\n合并规则：若，则。\n分解规则：若，则。\n伪传递规则：若，则。\nA4（MVD的补规则）：若，则。\nA5（MVD的增广律）：若，则。\nA6（MVD的传递律）：若，则。\nA7（复制规则）：若，则。\nA8（接合规则）：若，则。\n合并规则：若，则。\n伪传递规则：若，则。\n混合伪传递规则：若，则。\n分解规则：若，则。\n\n\n\n\n\n数据库设计\n概述\n定义\n在给定的应用环境下，构造最优的数据库逻辑结构和物理结构，建立数据库及其应用系统，使之能够有效地存储数据，满足各种用户的应用需求（信息要求和处理要求）。\n\n\n评价准则\n完备性\n一致性\n规范性\n\n\n设计内容\n结构特性设计\n行为特性设计\n\n\n特点\n早期：结构和行为相分离的设计\n现代：结构和行为相结合的设计\n\n\n步骤\n需求分析\n概念结构设计\n逻辑结构设计\n数据库物理设计\n数据库实施\n数据库运行和维护\n\n\n\n\n需求分析\n任务：获取用户对数据库的如下要求\n信息要求\n处理要求\n安全性与完整性要求\n\n\n步骤\n需求收集\n分析整理\n主要工作：业务流程分析\n一般方法：数据流分析法\n结果呈现：数据流图\n整理文档\n数据清单\n业务活动清单\n数据的完整性、一致性、安全性需求等文档\n\n\n\n\n评审\n\n\n方法\n调查系统的组织结构\n熟悉系统主要业务\n确定用户需求\n进行系统划分\n\n\n结果\n数据流图\n功能\n便于用户理解系统数据流程\n精确地在逻辑上描述系统的功能、输入、输出和数据存储\n表达数据与处理的关系\n\n\n基本元素\n圆圈：表示一次处理过程\n有向线：表示数据流\n双线段：表示存储的信息\n\n\n方法\n自顶向下\n逐层分解\n\n\n\n\n数据字典\n定义\n数据字典是系统中各类数据描述的集合，它以特定的格式记录系统中的各种数据、数据元素以及它们的名字、性质、意义及各类约束条件，以及系统中用到的常量、变量、数组和其他数据单位的重要文档。\n\n\n组成部分\n数据项：数据项是数据的最小单位，对数据项的描述一般包括项名、含义说明、别名、类型、长度、取值范围及该项与其它项的逻辑关系。\n数据结构：数据结构是若干数据项的有意义的集合，通常代表某一具体的事物。包括数据结构名、含义、组成成份等。\n数据流：数据流可以是数据项，也可以是数据结构，表示某一次处理的输入/输出数据。包括数据流名，说明，数据来源，数据去向，及需要的数据项或数据结构。\n数据存储：加工中需要存储的数据。包括数据存储名、说明、输入数据流、输出数据流、组成成份、数据量、存取方式、存取频度等。\n处理过程：加工处理过程定义和说明。包括处理名称、输入数据、输出数据、数据存储、响应时间等。\n\n\n\n\n\n\n\n\n概念结构设计\n目的\n产生反映系统信息需求的数据库概念结构，即概念模式。\n\n\n概念结构模型的特点\n有丰富的语义表达能力\n易于交流和理解\n易于修改\n易于向各种数据模型转换\n\n\n方法\n自顶向下（集中式模式设计法）\n自底向上（视图集成法）\n逐步扩张\n混合策略\n\n\n步骤\n数据抽象与局部E-R模型设计\n数据抽象\n分类\n聚集\n概括\n\n\n局部E-R模型设计\n三条原则\n相对原则\n一致原则\n简单原则\n\n\n步骤\n选择局部应用\n逐一设计分E-R图\n\n\n\n\n标定局部应用中的实体\n确定实体的属性、标识实体的码\n确定实体之间的联系及其类型\n\n\n总体E-R模型设计\n合并分E-R图\n属性冲突\n命名冲突\n结构冲突\n\n\n修改与重构\n评审\n\n\n\n\n结果\n系统各子部门的局部概念结构描述文档\n系统全局概念结构描述文档\n修改后的数据字典文档\n概念模型应具有的业务规则文档\n\n\n\n\n逻辑结构设计\n目的\n把概念结构设计阶段设计好的基本E-R图转换为特定的DBMS所支持的数据模型，包括数据库模式和外模式，并对其进行优化。\n\n\n任务\n将E-R模型转换为等价的关系模式。\n按需要对关系模式进行规范化。\n对规范化后的模式进行评价。\n根据局部应用的需要，设计用户外模式。\n\n\n步骤\n将概念结构转换为一般的关系、网状、层次模型\n将由概念结构转换来的模型向所选用DBMS支持的数据模型转换\n对数据模型进行优化\n对数据模型进行评价和修正\n设计外模式\n\n\n\n\n物理结构设计\n内容\n存储结构的设计\n规则：从数据库中检索的的数据由其中的数据项组成。\n三方面因素：存取时间、存储空间利用率、维护代价\n\n\n存取方法的设计\n存储结构：限定了可能访问的路径和存储记录\n检索机制：定义每个应用的访问路径\n\n\n\n\n评价\n时间效率\n空间效率\n维护代价\n各种用户要求\n\n\n\n\n数据库的实施与维护\n数据库实施\n建立实际的数据库结构\n数据库模式与子模式\n数据库完整性描述\n数据库安全性描述\n数据库物理存储参数描述\n\n\n数据加载\n\n\n数据库试运行\n先小批量后大批量地数据入库。\n先调试运行DBMS的恢复功能，做好数据库的转储和恢复工作。\n一定要有非设计人员的参与。\n\n\n数据库运行和维护\n对数据库性能的检测和改善\n数据库的转储和恢复\n数据库的安全性、完整性控制\n数据库的重组（织）与重构（造）\n\n\n\n\n\n\n","categories":["学科笔记"]},{"title":"《GIS二次开发》笔记","url":"/posts/23459c4c/","content":"GIS二次开发概述\nGIS 开发模式\n独立开发模式\n不依赖于任何GIS工具软件，从空间数据的采集、编辑到数据的处理分析及结果输出，所有的算法都由开发者独立设计，然后选用某种程序设计语言，如Visual C++、Delphi、Visual Basic等，在一定的操作系统平台上编程实现。\n开发周期长；软件功能相对简单；对开发者要求高；用于购买软件的费用相对节省；独立开发难度大。\n\n\n宿主型开发模式\n基于GIS平台软件，进行应用系统开发。多数GIS平台软件都提供了可供用户进行二次开发的脚本语言，用户以原GIS软件为开发平台，利用这些脚本语言，开发出自己的针对不同应用领域的应用程序，如ArcView的Avenue语言，MapInfo Professional的MapBasic语言。\n开发较为容易；二次开发的脚本语言功能较弱；所开发的系统不能脱离GIS平台，且受平台所提供的脚本语言的限制；是解释执行的，运行效率低；用户界面受平台软件的限制。\n\n\nGIS组件开发模式\n建立在组件技术基础上的GIS功能组件，实现了地理信息系统的各种功能，这些组件都具备GIS的基本功能。开发人员可以基于通用软件开发工具，尤其是可视化开发工具，如.Net、Delphi、Visual C++、Visual Basic、Power Builder等为开发平台，进行二次开发，实现GIS功能。\n大多数GIS软件产商都提供商业化的GIS组件。如ESRI公司的MapObjects、MapInfo公司的MapX等。\n\n\n\n\n面向对象程序设计模式\n对象：在一个面向对象的系统中，对象是运行期的基本实体，问题的分析一般以对象及对象间的自然联系为依据。对象在内存中占有一定空间，并且具有一个与之关联的地址。一个对象就是已定义的某个类型的变量。\n类：对象包含数据以及操作这些数据的代码。一个对象所包含的所有数据和代码可以通过类来构成一个用户定义的数据类型。事实上，对象就是类类型的变量。\n封装：把数据和函数包装在一个单独的单元（称为类）的行为称为封装。数据封装是类的最典型特点。数据不能被外界访问，只能被封装在同一个类中的函数访问。这些函数提供了对象数据和程序之间的接口。避免数据被程序直接访问的概念被称为“数据隐藏”。封装机制将数据和代码捆绑到一起，避免了外界的干扰和不确定性。\n继承：继承是可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念，这种分类的原则是，每一个子类都具有父类的公共特性。\n多态：事物具有不同形式的能力。例如，对于不同的实例，某个操作可能会有不同的行为，而这个行为依赖于所要操作数据的类型。\n\n\n组件式GIS\nCOM\nCOM是组件式对象模型（Component Object Model）的英文缩写，是组件之间相互接口的规范，是OLE（Object Linking &amp; Embedding）和ActiveX共同的基础，其作用是使各种软件构件和应用软件能够用一种统一的标准方式进行交互。\nCOM不是一种面向对象的语言，而是一种与源代码无关的二进制标准。COM所建立的是一个软件模块与另一个软件模块之间的链接，当这种链接建立之后，模块之间就可以通过称之为“接口”的机制来进行通信。\nCOM本质上是客户/服务器模式。客户（通常是应用程序）请求创建COM对象并通过COM对象的接口操纵COM对象。服务器根据客户的请求创建并管理COM对象。客户和服务器这两种角色是相对的。\n\n\nDCOM\n基于分布式环境下的COM被称作DCOM（Distribute COM，分布式组件对象模型）。\nDCOM是ActiveX的基础，它实现了COM对象与远程计算机上的另一个对象之间直接进行交互。\n\n\nActiveX\nActiveX是Microsoft提出的一组基于COM（Component Object Model，组件对象模型）规范使得软件组件在网络环境中进行交互的技术集。它与具体的编程语言无关。\n作为针对Internet应用开发的技术，ActiveX被广泛应用于WEB服务器以及客户端的各个方面。同时，ActiveX技术也被 用于方便地创建普通的桌面应用程序。\n其内容包括控件、文档、脚本、服务器框架。\n\n\n组件式GIS\n基本思想是把GIS的各大功能模块划分为几个控件，每个控件完成不同的功能。各个GIS控件之间，以及GIS控件与其它非GIS控件之间，可以方便地通过可视化的软件开发工具集成起来，形成最终的GIS应用。\n控件如同一堆各式各样的积木，他们分别实现不同的功能（包括GIS和非GIS功能），根据需要把实现各种功能的 “积木”搭建起来，就构成应用系统。\n其开发平台通常可设计为三级结构：基础组件、高级通用组件、行业组件。\n其功能包括空间数据获取、坐标转换、图形编辑、数据存储、数据查询、数据分析、制图表示等。\n\n\n\n\n\nArcGIS Engine编程基础\nArcObjects\nAO是ESRI公司ArcGIS™家族中应用程序（ArcMap、 ArcCatalog、 ArcScene）的开发平台，是基于Microsoft® COM技术所构建的一系列COM组件集。\nAO是随ArcGIS产品一同发布的，要使用AO必须购买ArcGIS Desktop，才能利用AO提供的组件对象来进行应用开发。\n在ArcGIS 9中发布了一个新的产品：ArcGIS Engine，ArcGIS Engine基于AO，并且实现了更好的封装是一个独立的产品。\n\n\nArcGIS Engine\nArcGIS Engine是基于COM的集合，可以被任何支持COM的编程语言所调用。\n使用ArcGIS Engine编程真正实现GIS功能的灵活配置，不仅可以编写功能复杂的独立应用程序，而且可以将GIS的相关功能嵌入到现有的软件中。\n在产品架构上，ArcGIS Engine由两部分组成：构建GIS应用软件所用的开发工具包（ArcGIS Engine Developer Kit），以及可分发的、为应用程序提供运行基础的运行时（ArcGIS Engine Runtime）。\n\n\n上述两者联系与区别\n联系\nArcGIS Engine包括ArcObjects的核心功能，是对ArcObjects中大部分接口、类库进行封装所构成的。\nArcGIS Engine中组件的接口、方法、属性与ArcObjects是相同的。\n\n\n区别\n开发环境上：基于ArcObjects开发时，必须安装ArcGIS Desktop；基于ArcGIS Engine开发时，由于ArcGIS Engine是独立的COM组件，不需要安装ArcGIS Desktop，只需安装ArcGIS Engine Developer Kit即可。\n功能强弱上：ArcObjects包含了很多ArcGIS Desktop中的UI功能，而部分UI功能在ArcGIS Engine中是没有的，如在ArcCatalog中向地图文档中添加数据所用到的IGxDialog接口，用于打印设置的IPrintDialog接口等。\n\n\n\n\nArcGIS Engine类库\n不同的组件库分别封装不同的GIS功能。\n在.Net开发环境中，不同的GIS功能分别被定义在不同的命名空间内。\n提供的类库主要可以分为Version类库、界面和控件类库、可视化显示类库、数据访问类库、数据分析类库等几大部分。\n\n\nArcGIS Engine控件\nArcGIS Engine控件是一组可视化的开发组件。\n每个ArcGIS Engine控件都是一个COM组件。\n\n\n三种类型的类\nAbstractClass类\nAbstractClass类是抽象类，不能被实例化。不能用new关键字去生成一个该类的对象。如Geometry类，可以用Polyline创建。\n抽象类的主要目的是为它的子类定义公共接口，一个抽象类将把它的部分或全部实现延迟到子类中，不同的类可以继承自同一个抽象类，但内部对同一个方法的实现可能是不一样的。\n抽象类不能直接创建类对象，只能通过派生子类的方法来实现自己。\n\n\nCoClass类\nCoClass类是可创建类，可通过new关键字直接实例化对象。\n实例对象和生存周期都是独立的，其实例对象不依赖其他对象的存在而存在，其生存周期也不由其它的对象管理。\n\n\nClass类\nClass类是一个可实例化类，不能直接使用new关键字创建对象，但是可以借助其它对象类来创建该类的实例，如Workspace类可以通过WorkspaceFactory类的OpenFromFile方法来创建。\n\n\n\n\n接口\n接口是指组件对象的接口，它是包含了一组函数的数据结构，通过这组数据结构，客户代码可以调用组件对象的功能，组件对象间的访问都是通过接口来进行的。\n接口设计必须满足以下两个条件：\n必须直接或间接地从IUnknown接口继承（该接口在AO中是省缺的）。\n接口必须有唯一的标识符号（接口不变性）。即，一旦分配和公布了ID，接口定义的任何因素都不能改变。\n\n\n\n\n对象模型图\n继承关系的类：空心三角箭头\n组合关系的类：实心菱形\n关联关系的类：实线\n依赖关系的类：虚线箭头\n入接口：空心圆\n出接口：实心圆\n\n\n空间数据库\n概念\n空间数据库指的是地理信息系统在计算机物理存储介质上存储的与应用相关的地理空间数据的总和，一般是以一系列特定结构的文件的形式组织在存储介质之上的。\n\n\n主要特点\n数据量庞大\n具有高可访问性\n空间数据模型复杂\n\n\n管理系统的实现方法\n寄生在关系数据库管理系统之上的空间数据引擎\n直接扩展通用数据库的空间数据库系统\n\n\n\n\n桌面GIS应用软件的开发方式\nVBA开发\nDLL开发\nAdd-in开发\nArcGIS Engine开发\n\n\n\nAdd-in开发\n在Visual Studio 2012中新建项目，选择“类库”。\n更改[Properties]-&gt;[生成]-&gt;[目标平台]为x86，勾选[为 COM 互操作注册]。\n更改[Properties]-&gt;[AssemblyInfo.cs]的第20行为[assembly: ComVisible(true)]。\n添加引用ESRI.ArcGIS.ArcMapUI、ESRI.ArcGIS.Carto、ESRI.ArcGIS.Framework、ESRI.ArcGIS.SystemUI、System.Windows.Forms。\n下面例子实现功能：在ArcMap中点击一个工具栏上的按钮，弹出对话框，显示当前所有图层名。\n将一个类实现ICommand接口，关键代码如下：public class GetLayerNameClass : ICommand {    IApplication m_App;    public string Caption { get { return \"Get Layer Names\"; } }    public string Category { get { return \"myetyet Tools\"; } }    public string Message { get { return \"My first add-in.\"; } }    public string Name { get { return \"Get Layer Names\"; } }    public void OnClick() {        IMxDocument pMxDoc = m_App.Document as IMxDocument;        IMap pMap = pMxDoc.FocusMap;        int n = pMap.LayerCount;        string[] names = new string[n];        for (int i = 0; i &lt; n; ++i)           names[i] = pMap.Layer[i].Name;        MessageBox.Show(string.Join(\"\\n\", names));    }    public void OnCreate(object Hook) {        m_App = Hook as IApplication;    }}\n按F6生成解决方案。\n在ArcMap中，打开[Customize]-&gt;[Customize Mode]，在弹出的对话框中切换至[Commands]选项卡，点击[Add From File]，选择解决方案中的*.tlb文件，点击[打开]，找到[myetyet Tools]下的[Get Layer Names]，将其拖至任一工具条上即可单击该图标使用。\n\nESRI.ArcGIS下常用接口及其常用成员\nCarto\nIAnnotateLayerPropertiesCollectionvoid Add(IAnnotateLayerProperties Item);void Clear();int Count { get; }void QueryItem(    int Index, ref IAnnotateLayerProperties Item,    ref IElementCollection placedElements, ref IElementCollection unplacedElements);void Remove(IAnnotateLayerProperties Layerprops);void Sort();\nIBasicGeoprocessorIFeatureClass Clip(    ITable inputTable, bool useSelectedInput, ITable clipTable,    bool useSelectedClip, double Tolerance, IFeatureClassName outputName);ITable Dissolve(    ITable inputTable, bool useSelected, string dissolveField,    string summaryFields, IDatasetName outputName);IFeatureClass Intersect(    ITable inputTable, bool useSelectedInput, ITable overlayTable,    bool useSelectedOverlay, double Tolerance, IFeatureClassName outputName);IFeatureClass Merge(IArray tables, ITable fieldsTable, IFeatureClassName outputName);IFeatureClass Union(    ITable inputTable, bool useSelectedInput, ITable overlayTable,    bool useSelectedOverlay, double Tolerance, IFeatureClassName outputName);\nIBasicHistogrambool GetHistogram(ref object doubleArrayValues, ref objectlongArrayFrequencies);\nIClassBreaksRendererint BreakCount { get; set; }string Field { get; set; }double MinimumBreak { get; set; }double get_Break(int Index);void set_Break(int Index, double Value);string get_Label(int Index);void set_Label(int Index, string Label);ISymbol get_Symbol(int Index);void set_Symbol(int Index, ISymbol sym);\nIElementIGeometry Geometry { get; set; }bool HitTest(double x, double y, double Tolerance);\nIFeatureLayer : ILayerstring DisplayField { get; set; }IFeatureClass FeatureClass { get; set; }string Name { get; set; }\nIFillShapeElementIFillSymbol Symbol { get; set; }\nIGeoFeatureLayer : IFeatureLayer, ILayerIAnnotateLayerPropertiesCollection AnnotationProperties { get; set; }bool DisplayAnnotation { get; set; }IFeatureRenderer Renderer { get; set; }\nILabelEngineLayerPropertiesstring Expression { get; set; }ITextSymbol Symbol { get; set; }\nILineElementILineSymbol Symbol { get; set; }\nIMarkerElementIMarkerSymbol Symbol { get; set; }\nIPictureElementvoid ImportPictureFromFile(string Name);bool SavePictureInDocument { get; set; }\nIRasterClassifyColorRampRendererint ClassCount { get; set; }string ClassField { get; set; }double get_Break(int Index);void set_Break(int Index, double Value);string get_Label(int Index);void set_Label(int Index, string Label);ISymbol get_Symbol(int Index);void set_Symbol(int Index, ISymbol Symbol);\nIRasterRGBRendererint BlueBandIndex { get; set; }int GreenBandIndex { get; set; }void QueryBandIndices(ref int redIndex, ref int greenIndex, ref int blueIndex);int RedBandIndex { get; set; }SetBandIndices(int redIndex, int greenIndex, int blueIndex);bool UseBlueBand { get; set; }bool UseGreenBand { get; set; }bool UseRedBand  { get; set; }\nIRasterRendererIRaster Raster { get; set; }void Update();\nIRasterStretchColorRampRendererint BandIndex { get; set; }IColorRamp ColorRamp { get; set; }string ColorScheme { get; set; }string LabelHigh { get; set; }string LabelLow { get; set; }string LabelMedium { get; set; }void ResetLabels();\nIRasterUniqueValueRenderervoid AddValue(int iHeading, int iClass, object Value);string DefaultLabel { get; set; }ISymbol DefaultSymbol { get; set; }int HeadingCount { get; set; }string Field { get; set; }void RemoveValues(int iHeading, int iClass);bool UseDefaultSymbol { get; set; }int get_ClassCount(int iHeading);void set_ClassCount(int iHeading, int pCount);string get_Heading(int iHeading);void set_Heading(int iHeading, string pHeading);string get_Label(int iHeading);void set_Label(int iHeading, int iClass, string pLabel);ISymbol get_Symbol(int iHeading, int iClass);void set_Symbol(int iHeading, int iClass, ISymbol pSymbol);\nISimpleRendererISymbol Symbol { get; set; }\nITableHistogramstring Field { get; set; }ITable Table { get; set; }\nITextElementbool ScaleText { get; set; }ITextSymbol Symbol { get; set; }string Text { get; set; }\nIUniqueValueRendererISymbol DefaultSymbol { get; set; }int FieldCount { get; set; }bool UseDefaultSymbol { get; set; }string get_Field(int Index);void set_Field(int Index, string Field);\n\n\nControls\nIMapControl2IActiveView ActiveView { get; }void AddLayer(ILayer Layer, int toIndex = 0);void CenterAt(IPoint centerPoint);bool CheckMxFile(string fileName);void ClearLayers();ITool CurrentTool { get; set; }void DeleteLayer(int index);void FlashShape(    IGeometry pShape, int nFlashes = 3, int flashInterval = 300,    object symbol = Type.Missing);int LayerCount { get; }void LoadMxFile(    string mxPath,    object mapNameOrIndex = Type.Missing, object password = Type.Missing);IMap Map { get; set; }void MoveLayerTo(int fromIndex, int toIndex);void Refresh(    esriViewDrawPhase phase = 65535,    object layerOrElement = Type.Missing, object envelope = Type.Missing);IPoint ToMapPoint(int X, int Y);IGeometry TrackCircle();IGeometry TrackLine();IGeometry TrackPolygon();IEnvelope TrackRectangle();ILayer get_Layer(int index);\n\n\nDataSourcesRaster\nIRaster2ITable AttributeTable { get; set; }object GetPixelValue(int iBand, int iColumn, int iRow);void MapToPixel(double x, double y, ref int pColumn, ref int pRow);void PixelToMap(int iColumn, int iRow, ref double pX, ref double pY);IRasterDataset RasterDataset { get; }double ToMapX(int iColumn);double ToMapY(int iRow);int ToPixelColumn(double x);int ToPixelRow(double y);\nIRasterBandITable AttributeTable { get; }string Bandname { get; }void ComputeStatsAndHist();void HasStatistics(ref bool b);void HasTable(ref bool b);IRasterHistogram Histogram { get; }IRasterDataset RasterDataset { get; }IRasterStatistics Statistics { get; }\nIRasterBandCollectionvoid Add(IRasterBand Element, int index);void AppendBand(IRasterBand Element);IEnumRasterBand Bands { get; }void Clear();int Count { get; }IRasterBand Item(int BandIndex);void Remove(int index);IRasterBand get_BandByName(string Name);int get_BandIndex(string Name);\nIRasterPropsint Height { get; set; }bool IsInteger { get; }object NoDataValue { get; set; }rstPixelType PixelType { get; set; }int Width { get; set; }\nIRasterStatisticsobject IgnoredValues { get; set; }bool IsValid { get; set; }double Maximum { get; set; }double Median { get; }double Minimum { get; set; }double Mode { get; }void Recalculate();int SkipFactorX { get; set; }int SkipFactorY { get; set; }double StandardDeviation { get; set; }\n\n\nDisplay\nIAlgorithmicColorRamp : IColorRampesriColorRampAlgorithm Algorithm { get; set; }IColor FromColor { get; set; }IColor ToColor { get; set; }\nIColorint CMYK { get; set; }int RGB { get; set; }byte Transparency { get; set; }\nIColorRampIEnumColors Colors { get; }void CreateRamp(ref bool ok);string Name { get; set; }int Size { get; set; }IColor get_Color(int index);\nIEnumColorsIColor Next();void Reset();\nIFillSymbolIColor Color { get; set; }ILineSymbol Outline { get; set; }\nILineSymbolIColor Color { get; set; }double Width { get; set; }\nIMarkerSymboldouble Angle { get; set; }IColor Color { get; set; }double Size { get; set; }double XOffset { get; set; }double YOffset { get; set; }\nITextSymboldouble Angle { get; set; }IColor Color { get; set; }stdole.IFontDisp Font { get; set; }esriTextHorizontalAlignment HorizontalAlignment { get; set; }bool RightToLeft { get; set; }double Size { get; set; }string Text { get; set; }esriTextVerticalAlignment VerticalAlignment { get; set; }\nIRandomColorRamp : IColorRampint EndHue { get; set; }int MaxSaturation { get; set; }int MaxValue { get; set; }int MinSaturation { get; set; }int MinValue { get; set; }int Seed { get; set; }int StartHue { get; set; }bool UseSeed { get; set; }\nIRgbColor : IColorint Blue { get; set; }int Green { get; set; }int Red { get; set; }\nISimpleFillSymbol : IFillSymbolesriSimpleFillStyle Style { get; set; }\nISimpleLineSymbol : ILineSymbolesriSimpleLineStyle Style { get; set; }\nISimpleMarkerSymbol : IMarkerSymbolbool Outline { get; set; }IColor OutlineColor { get; set; }double OutlineSize { get; set; }esriSimpleMarkerStyle Style { get; set; }\n\n\nGeodatabase\nIDatasetNamestring Category { get; set; }string Name { get; set; }esriDatasetType Type { get; }\nIFeature : IObject, IRow, IRowBufferIEnvelope Extent { get; }esriFeatureType FeatureType { get; }IGeometry Shape { get; set; }\nIFeatureBuffer : IRowBufferIGeometry Shape { get; set; }\nIFeatureClass : IClass, IObjectClassvoid AddField(IField Field);string AliasName { get; }IFeature CreateFeature();void DeleteField(IField Field);IFields Fields { get; }IFeatureCursor Search(IQueryFilter filter, bool Recycling);esriGeometryType ShapeType { get; }\nIFeatureClassNameIDatasetName FeatureDatasetName { get; set; }esriFeatureType FeatureType { get; set; }string ShapeFieldName { get; set; }esriGeometryType ShapeType { get; set; }\nIFeatureCursorvoid DeleteFeature();IFields Fields { get; }int FindField(string Name);void Flush();object InsertFeature(IFeatureBuffer buffer);IFeature NextFeature();void UpdateFeature(IFeature Object);\nIFeatureWorkspaceIFeatureClass OpenFeatureClass(string Name);IFeatureDataset OpenFeatureDataset(string Name);ITable OpenTable(string Name);\nIFieldstring AliasName { get; }string Name { get; }esriFieldType Type { get; }\nIFieldsint FieldCount { get; }int FindField(string Name);IField get_Field(int Index);\nIPixelBlockint BytesPerPixel { get; }object GetVal(int plane, int X, int Y);int Height { get; set; }int Planes { get; }int Width { get; }object get_SafeArray(int plane);void set_SafeArray(int plane, object val);\nIPntvoid Convert2Point(IPoint env);void Set2Point(IPoint env);void SetCoords(double X, double Y);double X { get; set; }double Y { get; set; }\nIQueryFiltervoid AddField(string subField);string SubFields { get; set; }string WhereClause { get; set; }\nIRasterIRasterCursor CreateCursor();IPixelBlock CreatePixelBlock(IPnt Size);void Read(IPnt tlc, IPixelBlock block);rstResamplingTypes ResampleMethod { get; set; }\nIRow : IRowBuffervoid Delete();void Store();\nIRowBufferIFields Fields { get; }object get_Value(int Index);object set_Value(int Index, object Value);\nISaveAsbool CanSaveAs(string Format);IDataset SaveAs(string Name, IWorkspace Workspace, string Format);\nISpatialFilter : IQueryFilterIGeometry Geometry { get; set; }string GeometryField { get; set; }esriSpatialRelEnum SpatialRel { get; set; }\nITable : IClassIRow CreateRow();IRowBuffer CreateRowBuffer();void DeleteSearchedRows(IQueryFilter QueryFilter);IRow GetRow(int OID);int RowCount(IQueryFilter QueryFilter);\nIWorkspacebool Exists();string PathName { get; }esriWorkspaceType Type { get; }IWorkspaceFactory WorkspaceFactory { get; }IEnumDataset get_Datasets(esriDatasetType DatasetType);\nIWorkspaceEditvoid AbortEditOperation();void DisableUndoRedo();void EnableUndoRedo();void HasEdits(ref bool pHasEdits);void HasRedos(ref bool pHasRedos);void HasUndos(ref bool pHasUndos);bool IsBeingEdited();void RedoEditOperation();void StartEditing(bool withUndoRedo);void StartEditOperation();void StopEditing(bool saveEdits);void StopEditOperation();void UndoEditOperation();\nIWorkspaceFactoryIWorkspace OpenFromFile(string fileName, int hWnd);esriWorkspaceType WorkspaceType { get; }\n\n\nGeoAnalyst\nIGeoAnalysisEnvironmentIWorkspace OutWorkspace { get; set; }// object Missing = Type.Missing;void SetCellSize(    esriRasterEnvSettingEnumenv Type,    ref object cellSizeProvider = ref Missing);void SetExtent(    esriRasterEnvSettingEnumenv Type,    ref object extentProvider = ref Missing, ref object snapRasterData = ref Missing);\nIGeoAnalysisSemiVariogramvoid DefineVariogram(    esriGeoAnalysisSemiVariogramEnum Type,    double aRange, double sill, double aNugget);double Lag { get; set; }double Nugget { get; }double PartialSill { get; }double Range { get; }esriGeoAnalysisSemiVariogramEnum VariogramType { get; set; }\nIInterpolationOp2// object Missing = Type.Missing;IGeoDataset IDW(    IGeoDataset geoData, double power, IRasterRadius radius,    ref object barrier = ref Missing);IGeoDataset Krige(    IGeoDataset geoData, esriGeoAnalysisSemiVariogramEnum semiVariogramType,    IRasterRadius radius, bool outSemiVariance,    ref object barrier = ref Missing);IGeoDataset NaturalNeighbor(IGeoDataset GeoDataset);IGeoDataset Spline(    IGeoDataset geoData, esriGeoAnalysisSplineEnum splineType,    ref object weight = ref Missing, ref object numPoints = ref Missing);IGeoDataset TopoToRasterByFile(    string paramFile,    ref IFeatureClass outStream, ref IFeatureClass outSink);IGeoDataset Trend(IGeoDataset geoData, esriGeoAnalysisTrendEnum trendType, int order);IGeoDataset Variogram(    IGeoDataset geoData, IGeoAnalysisSemiVariogram semiVariogram,    IRasterRadius radius, bool outSemiVariance,    ref object barrier = Missing);\nIRasterAnalysisEnvironmentIGeoDataset Mask { get; set; }void Reset();\nIRasterNeighborhoodvoid SetAnnulus(    double innerRadius, double outerRadius,    esriGeoAnalysisUnitsEnum unitsType);void SetCircle(double radius, esriGeoAnalysisUnitsEnum unitsType);void SetDefault();void SetIrregular(int height, int width, ref object entryValues);void SetRectangle(double width, double height, esriGeoAnalysisUnitsEnum unitsType);void SetWedge(    double radius, double startAngle, double endAngle,    esriGeoAnalysisUnitsEnum unitsType);void SetWeight(int height, int width, ref object entryValues);\nIRasterRadius// object Missing = Type.Missing;void SetFixed(double distance, ref object minCount = ref Missing);void SetVariable(int count, ref object maxDistance = ref Missing);\nIReclassOpIGeoDataset Lookup(IGeoDataset GeoDataset, string FieldName);IGeoDataset Reclass(    IGeoDataset GeoDataset, ITable remapTable, string fromField,    string toField, string OutField, bool retainMissingValues);IGeoDataset ReclassByASCIIFile(    IGeoDataset inRaster, string sRemapFile,    bool retainMissingValues);IGeoDataset ReclassByRemap(IGeoDataset GeoDataset, IRemap Remap, bool retainMissingValues);// object Missing = Type.Missing;IGeoDataset Slice(    IGeoDataset GeoDataset, esriGeoAnalysisSliceEnum sliceType, int zoneCount,    ref object baseZone = ref Missing);\nISurfaceOp2IGeoDataset Aspect(IGeoDataset GeoDataset);// object Missing = Type.Missing;IGeoDataset Contour(    IGeoDataset GeoDataset, double interval,    ref object base = ref Missing, ref object zFactor = ref Missing);IGeoDataset ContourList(IGeoDataset GeoDataset, ref object contoursArray);IGeoDataset Curvature(    IGeoDataset GeoDataset, bool profile, bool plan,    ref objectzFactor = ref Missing);IGeoDataset CutFill(    IGeoDataset beforeGeoDataset, IGeoDataset afterGeoDataset,    ref objectzFactor = ref Missing);IGeoDataset HillShade(    IGeoDataset GeoDataset, double azimuth, double altitude,    bool inModelShadows,    ref objectzFactor = ref Missing);IGeoDataset Slope(    IGeoDataset GeoDataset, esriGeoAnalysisSlopeEnum slopeType,    ref objectzFactor = ref Missing);IGeoDataset Visibility(    IGeoDataset GeoDataset, IGeoDataset observers,    esriGeoAnalysisVisibilityEnum visType,    ref objectzFactor = ref Missing, ref object pRefractivityCoefficient = ref Missing);\n\n\nGeometry\nIAreadouble Area { get; }IPoint Centroid { get; }IPoint LabelPoint { get; }\nIGeometryesriGeometryDimension Dimension { get; }IEnvelope Envelope { get; }esriGeometryType GeometryType { get; }\nIPoint : IGeometryvoid PutCoords(double X, double Y);double X { get; set; }double Y { get; set; }\nIPointCollection// object Missing = Type.Missing;void AddPoint(    IPoint inPoint,    ref object before = ref Missing, ref objectafter = ref Missing);void AddPointCollection(IPointCollection newPoints);int PointCount { get; }void RemovePoints(int Index, int Count);IPoint get_Point(int i);\nIRelationalOperatorbool Contains(IGeometry other);bool Crosses(IGeometry other);bool Disjoint(IGeometry other);bool Equals(IGeometry other);bool Overlaps(IGeometry other);bool Touches(IGeometry other);bool Within(IGeometry other);\nITopologicalOperatorIGeometry Boundary { get; }IGeometry Buffer(double distance);IGeometry Difference(IGeometry other);IGeometry Intersect(IGeometry other, esriGeometryDimension resultDimension);void Simplify();IGeometry SymmetricDifference(IGeometry other);\n\n\nSpatialAnalyst\nIDensityOp// object Missing = Type.Missing;IGeoDataset KernelDensity(    IGeoDataset sourceFeatures,    ref object radiusDistance = ref Missing, ref object scaleFactor = ref Missing);IGeoDataset LineDensity(    IGeoDataset lineFeatures,    ref object radiusDistance = ref Missing, ref object scaleFactor = ref Missing);IGeoDataset PointDensity(    IGeoDataset pointFeatures, IRasterNeighborhood nbrhood,    ref object scaleFactor = ref Missing);\nIDistanceOpIGeoDataset Corridor(IGeoDataset distance1, IGeoDataset distance2);// object Missing = Type.Missing;IGeoDataset CostAllocation(    IGeoDataset sourceData, IGeoDataset costRaster,    ref object maxDistance = ref Missing, ref object valueRaster = ref Missing);IGeoDataset CostBackLink(    IGeoDataset sourceData, IGeoDataset costRaster,    ref object maxDistance = ref Missing, ref object valueRaster = ref Missing);IGeoDataset CostDistance(    IGeoDataset sourceData, IGeoDataset costRaster,    ref object maxDistance = ref Missing, ref object valueRaster = ref Missing);IGeoDataset CostPath(    IGeoDataset fromData, IGeoDataset distance, IGeoDataset backlink,    esriGeoAnalysisPathEnum pathType);IGeoDataset EucAllocation(    IGeoDataset sourceData,    ref object maxDistance = ref Missing, ref object valueRaster = ref Missing);IGeoDataset EucDirection(    IGeoDataset sourceData,    ref object maxDistance = ref Missing, ref object valueRaster = ref Missing);IGeoDataset EucDistance(    IGeoDataset sourceData,    ref object maxDistance = ref Missing, ref object valueRaster = ref Missing);\nIMapAlgebraOpvoid BindRaster(IGeoDataset geoDataset, string symbol);IGeoDataset Execute(string expression);void UnbindRaster(string symbolName);\n\n\nSystemUI\nICommandint Bitmap { get; }string Caption { get; }string Category { get; }bool Checked { get; }bool Enabled { get; }string Message { get; }string Name { get; }void OnClick();void OnCreate(object Hook);string Tooltip { get; }\nIToolint Cursor { get; }bool Deactivate();void OnMouseDown();\n\n\nesriSystem\nIClassifyGENobject ClassBreaks { get; }void Classify(object doubleArrayValues, object longArrayFrequencies,  ref int numClasses);\nIObjectCopyobject Copy(object pInObject);void Overwrite(object pInObject, ref object pOverwriteObject);\n\n\n\n\n示例\n绑定运行时：修改Program.cs文件中相关代码。static void Main() {    Application.EnableVisualStyles();    Application.SetCompatibleTextRenderingDefault(false);    ESRI.ArcGIS.RuntimeManager.Bind(ESRI.ArcGIS.ProductCode.EngineOrDesktop);    Application.Run(new Form1());}\n切换Map和Layout选项卡时互相传递数据。private void tabControl1_SelectedIndexChanged(object sender, EventArgs e) {    IObjectCopy pOC = new ObjectCopyClass();    if (tabControl1.SelectedIndex == 0) {        object pSourceMap = axPageLayoutControl1.ActiveView.FocusMap;        object pDestMap = axMapControl1.ActiveView.FocusMap;        pOC.Overwrite(pSourceMap, ref pDestMap);        axTOCControl1.SetBuddyControl(axMapControl1);        axMapControl1.Refresh();    } else if (tabControl1.SelectedIndex == 1) {        object pSourceMap = axMapControl1.ActiveView.FocusMap;        object pDestMap = axPageLayoutControl1.ActiveView.FocusMap;        pOC.Overwrite(pSourceMap, ref pDestMap);        axTOCControl1.SetBuddyControl(axPageLayoutControl1);        axPageLayoutControl1.Refresh();    }}\nlistBox1中列出了当前所有图层，选择其中一个，在listBox2中列出该图层属性表中的所有属性名。IMap pMap = App.ActiveView.FocusMap;ILayer pLayer = pMap.Layer[listBox1.SelectedIndex];IFields pFields = null;if (pLayer is IFeatureLayer) {    IFeatureLayer pFL = pLayer as IFeatureLayer;    IFeatureClass pFC = pFL.FeatureClass;    pFields = pFC.Fields;} else if (pLayer is IRasterLayer) {    IRasterLayer pRL = pLayer as IRasterLayer;    IRasterBandCollection pRBC = pRL.Raster as IRasterBandCollection;    IRasterBand pRB = pRBC.Item(0);    ITable pTable = pRB.AttributeTable;    if (pTable != null) pFields = pTable.Fields;}listBox2.Items.Clear();if (pFields != null)    for (int i = 0; i &lt; pFields.FieldCount; ++i)        listBox2.Items.Add(pFields.Field[i].Name);\nlistBox1中列出了当前所有图层，创建两个按钮，分别控制将选中图层向上、下移动一层。private void btnLayerUp_Click(object sender, EventArgs e) {    int index = listBox1.SelectedIndex;    IMap pMap = App.ActiveView.FocusMap;    ILayer pLayer = pMap.Layer[index];    if (index &gt; 0) {        pMap.MoveLayer(pLayer, index - 1);        listBox1.Items.Insert(index - 1, pLayer.Name);        listBox1.Items.RemoveAt(index + 1);        listBox1.SelectedIndex = index - 1;    }}private void btnLayerDown_Click(object sender, EventArgs e) {    int index = listBox1.SelectedIndex;    IMap pMap = App.ActiveView.FocusMap;    ILayer pLayer = pMap.Layer[index];    if (index &gt; -1 &amp;&amp; index &lt; pMap.LayerCount - 1) {        pMap.MoveLayer(pLayer, index + 1);        listBox1.Items.Insert(index + 2, pLayer.Name);        listBox1.Items.RemoveAt(index);        listBox1.SelectedIndex = index + 1;    }}\n在点击处添加标记元素。IMarkerElement pME = new MarkerElementClass();ISimpleMarkerSymbol pSMS = new SimpleMarkerSymbolClass();pSMS.Style = (esriSimpleMarkerStyle)4;pSMS.Size = 8.0; pSMS.Angle = 359.9;IRgbColor pColor = new RgbColorClass(); pColor.Red = 255;pSMS.Color = pColor as IColor;pME.Symbol = pSMS as IMarkerSymbol; // OptionalIElement pE = pME as IElement;pE.Geometry = m_App.ToMapPoint(x, y);m_App.ActiveView.GraphicsContainer.AddElement(pE, 0);m_App.ActiveView.PartialRefresh(esriViewDrawPhase.esriViewGraphics, pE, null);\n跟踪绘制线条元素。ILineElement pLE = new LineElementClass();ISimpleLineSymbol pSLS = new SimpleLineSymbolClass();pSLS.Style = (esriSimpleLineStyle)6;pSLS.Width = 2.0;IRgbColor pColor = new RgbColorClass(); pColor.Green = 255;pSLS.Color = pColor as IColor;pLE.Symbol = pSLS as ILineSymbol; // OptionalIElement pE = pLE as IElement;pE.Geometry = m_App.TrackLine();m_App.ActiveView.GraphicsContainer.AddElement(pE, 0);m_App.ActiveView.PartialRefresh(esriViewDrawPhase.esriViewGraphics, pE, null);\n跟踪绘制面元素。IFillShapeElement pPE = new PolygonElementClass();ISimpleFillSymbol pSFS = new SimpleFillSymbolClass();pSFS.Style = (esriSimpleFillStyle)7;IRgbColor pColor = new RgbColorClass(); pColor.Blue = 255;pSFS.Color = pColor as IColor;pPE.Symbol = pSFS as IFillSymbol; // OptionalIElement pE = pPE as IElement;pE.Geometry = m_App.TrackPolygon();m_App.ActiveView.GraphicsContainer.AddElement(pE, 0);m_App.ActiveView.PartialRefresh(esriViewDrawPhase.esriViewGraphics, pE, null);\n在点击处添加文字元素。ITextElement pTE = new TextElementClass();pTE.Text = \"myetyet\";ITextSymbol pSTS = new TextSymbolClass();pSTS.Size = 16.0; pSTS.Angle = 45.0;IRgbColor pColor = new RgbColorClass();pColor.RGB = 0x808080;pSTS.Color = pColor as IColor;stdole.StdFontClass pFD = new stdole.StdFontClass();pFD.Name = \"Consolas\";pSTS.Font = pFD as stdole.IFontDisp;pTE.Symbol = pSTS; // OptionalIElement pE = pTE as IElement;pE.Geometry = m_App.ToMapPoint(x, y);m_App.ActiveView.GraphicsContainer.AddElement(pE, 0);m_App.ActiveView.PartialRefresh(esriViewDrawPhase.esriViewGraphics, pE, null);\n在矩形框选区内充填BMP图片，作为元素绘制在地图上。IPictureElement pPE = new BmpPictureElementClass();pPE.ImportPictureFromFile(@\"C:\\myetyet.bmp\");IElement pE = pPE as IElement;pE.Geometry = m_App.TrackRectangle();m_App.ActiveView.GraphicsContainer.AddElement(pE, 0);m_App.ActiveView.PartialRefresh(esriViewDrawPhase.esriViewGraphics, pE, null);\n将country图层中所有国家的货币代码不重复地加入comboBox1。IFeatureLayer pFL = App.ActiveView.FocusMap.Layer[0] as IFeatureLayer;IFeatureCursor pFC = pFL.Search(null, false);for (IFeature pF = pFC.NextFeature(); pF != null; pF = pFC.NextFeature()) {    string s = pF.Value[pFC.FindField(\"CURR_CODE\")].ToString();    if (comboBox1.FindStringExact(s) == -1) comboBox1.Items.Add(s);}\n将所有使用comboBox1中选中的货币代码的国家图形选中，并将这些国家的全名列于listBox1。IFeatureLayer pFL = App.ActiveView.FocusMap.Layer[0] as IFeatureLayer;IQueryFilter pQF = new QueryFilterClass();pQF.WhereClause = String.Format(\"CURR_CODE = '{0}'\", comboBox1.SelectedItem.ToString());IFeatureCursor pFC = pFL.Search(pQF, false);listBox1.Items.Clear();App.ActiveView.FocusMap.ClearSelection();for (IFeature pF = pFC.NextFeature(); pF != null; pF = pFC.NextFeature()) {    listBox1.Items.Add(pF.Value[pFC.FindField(\"LONG_NAME\")].ToString());    App.ActiveView.FocusMap.SelectFeature(pFL, pF);}App.Refresh(esriViewDrawPhase.esriViewGeoSelection);\n选中所有与绘制出的矩形包围框相交的图形。IFeatureLayer pFL = m_App.ActiveView.FocusMap.Layer[0] as IFeatureLayer;ISpatialFilter pSF = new SpatialFilterClass();pSF.Geometry = m_App.TrackRectangle();pSF.SpatialRel = esriSpatialRelEnum.esriSpatialRelIntersects;IFeatureCursor pFC = pFL.Search(pSF, false);m_App.ActiveView.FocusMap.ClearSelection();for (IFeature pF = pFC.NextFeature(); pF != null; pF = pFC.NextFeature())    m_App.ActiveView.FocusMap.SelectFeature(pFL, pF);m_App.Refresh(esriViewDrawPhase.esriViewGeoSelection);\n在世界地图上绘制一条“铁路”（线条）并建立距离为的缓冲区，并显示该缓冲区在与之相交的国家内的面积。IGeometry pRailway = m_App.TrackLine();IElement pElement = new LineElementClass() as IElement;pElement.Geometry = pRailway;m_App.ActiveView.GraphicsContainer.AddElement(pElement, 0);m_App.ActiveView.PartialRefresh(esriViewDrawPhase.esriViewGraphics, pElement, null);ITopologicalOperator pTO1 = pRailway as ITopologicalOperator; pTO1.Simplify();IGeometry pRailwayBuffer = pTO1.Buffer(1.0);IFeatureLayer pFL = m_App.ActiveView.FocusMap.Layer[0] as IFeatureLayer;ISpatialFilter pSF = new SpatialFilterClass();pSF.Geometry = pRailway;pSF.SpatialRel = esriSpatialRelEnum.esriSpatialRelIntersects;IFeatureCursor pFC = pFL.Search(pSF, false);ITopologicalOperator pTO2 = pRailwayBuffer as ITopologicalOperator; pTO2.Simplify();List&lt;string&gt; res = new List&lt;string&gt;();for (IFeature pF = pFC.NextFeature(); pF != null; pF = pFC.NextFeature()) {    IGeometry pInGeo = pTO2.Intersect(pF.Shape, esriGeometryDimension.esriGeometry2Dimension);    double area = (pInGeo as IArea).Area;    res.Add(String.Format(\"{0}: {1}\", pF.Value[pF.Fields.FindField(\"CNTRY_NAME\")], area));}MessageBox.Show(string.Join(\"\\n\", res));\n两相交面图层的裁剪分析。IFeatureLayer pFLclip = axMapControl1.get_Layer(0) as  IFeatureLayer;IFeatureLayer pFLin = axMapControl1.get_Layer(1) as IFeatureLayer;IFeatureClass pFCclip = pFLclip.FeatureClass,pFCin = pFLin.FeatureClass;// Get shapefile workspaceIWorkspaceName pWN = new WorkspaceNameClass(); pWN.PathName = @\"C:\\myetyet\";pWN.WorkspaceFactoryProgID = \"esriDataSourcesFile.ShapefileWorkspaceFactory\";// Set paraments of the result FeatureClassIFeatureClassName pFCN = new FeatureClassNameClass();pFCN.ShapeType = pFCin.ShapeType;pFCN.ShapeFieldName = pFCin.ShapeFieldName;pFCN.FeatureType = esriFeatureType.esriFTSimple;IDatasetName pDN = pFCN as IDatasetName;pDN.Name = \"ClippedDatasetFileName\"; pDN.WorkspaceName = pWN;// Initialize the BasicGeoprocessorIBasicGeoprocessor pGB = new BasicGeoprocessorClass();pGB.SpatialReference = axMapControl1.SpatialReference; // OptionalITable pTin = pFCin as ITable, pTclip = pFCclip as ITable;IFeatureClass pFCout = pGB.Clip(pTin, false, pTclip, false, 0.01, pFCN);// Add to the mapIFeatureLayer pFLout = new FeatureLayerClass();pFLout.FeatureClass = pFCout;axMapControl1.AddLayer(pFLout);\n用打开文件对话框添加多个.shp文件至地图中。IWorkspaceFactory pWF = new ShapefileWorkspaceFactoryClass();OpenFileDialog pOFD = new OpenFileDialog();pOFD.Filter = \"Shape File(*.shp)|*.shp\"; pOFD.Multiselect = true;if (pOFD.ShowDialog() == DialogResult.OK) {    string pDN = System.IO.Path.GetDirectoryName(pOFD.FileNames[0]);    IFeatureWorkspace pFW = pWF.OpenFromFile(pDN, 0) as IFeatureWorkspace;    for (int i = 0, len = pOFD.FileNames.Length; i &lt; len; ++i) {        IFeatureLayer pFL = new FeatureLayerClass();        pFL.FeatureClass = pFW.OpenFeatureClass(pOFD.SafeFileNames[i]);        pFL.Name = pFL.FeatureClass.AliasName;        m_App.ActiveView.FocusMap.AddLayer(pFL);    }}\n添加World数据库中所有矢量要素至地图中。string pPath = @\"C:\\myetyet\\World\", pExt = \".mdb\";IWorkspaceFactory pWF = null;if (pExt == \".gdb\") pWF = new FileGDBWorkspaceFactoryClass();else pWF = new AccessWorkspaceFactoryClass();IWorkspace pWs = pWF.OpenFromFile(pPath + pExt, 0);IFeatureWorkspace pFW = pWs as IFeatureWorkspace;IEnumDataset pED = pWs.Datasets[esriDatasetType.esriDTFeatureClass];for (IDataset pD = pED.Next(); pD != null; pD = pED.Next()) {    IFeatureLayer pFL = new FeatureLayerClass();    pFL.FeatureClass = pFW.OpenFeatureClass(pD.Name);    pFL.Name = pFL.FeatureClass.AliasName;    m_App.ActiveView.FocusMap.AddLayer(pFL);}\n显示C:\\myetyet目录下所有数据集的名称。IWorkspaceFactory pWF = new ShapefileWorkspaceFactoryClass();IWorkspace pWs = pWF.OpenFromFile(@\"C:\\myetyet\", 0);IEnumDataset pED = pWs.Datasets[esriDatasetType.esriDTAny];List&lt;string&gt; res = new List&lt;string&gt;(); IDataset pD;while ((pD = pED.Next()) != null) res.Add(pD.Name);MessageBox.Show(string.Join(\"\\n\", res));\n单一符号化渲染。ISimpleFillSymbol pSFS = new SimpleFillSymbolClass();IRgbColor pColor1 = new RgbColorClass(); pColor1.Red = 0xff;pSFS.Color = pColor1 as IColor;ILineSymbol pLS = new SimpleLineSymbolClass();IRgbColor pColor2 = new RgbColorClass(); pColor2.Blue = 0xff;pLS.Color = pColor2 as IColor; pLS.Width = 2;pSFS.Outline = pLS;ISimpleRenderer pSR = new SimpleRendererClass();pSR.Symbol = pSFS as ISymbol;IFeatureLayer pFL = Layer as IFeatureLayer;IGeoFeatureLayer pGFL = pFL as IGeoFeatureLayer;pGFL.Renderer = pSR as IFeatureRenderer;m_App.ActiveView.Refresh(); m_TOC.Update();\n唯一值符号化、随机色带、按值渲染国家名字段。// Define default symbolISimpleFillSymbol pSFS = new SimpleFillSymbolClass();pSFS.Style = esriSimpleFillStyle.esriSFSHollow;pSFS.Outline.Width = 0.4;// Set the UniqueValueRendererIUniqueValueRenderer pUVR = new UniqueValueRendererClass();pUVR.FieldCount = 1; pUVR.Field[0] = \"CNTRY_NAME\";pUVR.DefaultSymbol = pSFS as ISymbol; pUVR.UseDefaultSymbol = true;// Build a RandomColorRamp and get the cursorIRandomColorRamp pRCR = new RandomColorRampClass();pRCR.MinSaturation = 20; pRCR.MaxSaturation = 40;pRCR.MinValue = 85; pRCR.MaxValue = 100;pRCR.StartHue = 76; pRCR.EndHue = 188;pRCR.UseSeed = true; pRCR.Seed = pUVR.ValueCount + 5;pRCR.Size = pUVR.ValueCount;bool pCheck; pRCR.CreateRamp(out pCheck);IEnumColors pEC = pRCR.Colors; pEC.Reset();// Set the symbol of each Feature(country)List&lt;string&gt; pValues = new List&lt;string&gt;();IFeatureLayer pFL = Layer as IFeatureLayer;IFeatureCursor pFC = pFL.Search(null, false);IFields pFields = pFC.Fields; int pIndex = pFields.FindField(\"CNTRY_NAME\");for (IFeature pF = pFC.NextFeature(); pF != null; pF = pFC.NextFeature()) {    if (pValues.Contains(pF.Value[pIndex].ToString())) continue;    pValues.Add(pCN);    ISimpleFillSymbol ppSFS = new SimpleFillSymbolClass();    ppSFS.Style = esriSimpleFillStyle.esriSFSSolid;    ppSFS.Outline.Width = 0.4; ppSFS.Color = pEC.Next();    pUVR.AddValue(pCN, \"CNTRY_NAME\", ppSFS as ISymbol);    pUVR.set_Label(pCN, pCN); pUVR.set_Symbol(pCN, ppSFS as ISymbol);}// Render and refreshIGeoFeatureLayer pGFL = pFL as IGeoFeatureLayer;pGFL.Renderer = pUVR as IFeatureRenderer;m_App.ActiveView.Refresh(); m_TOC.Update();\n分级符号化、渐变色带、渲染国家人口字段。// Prepare the histogram of the field \"POP_CNTRY\"IFeatureLayer pFL = m_App.get_Layer(0) as IFeatureLayer;ITable pTable = pFL.FeatureClass as ITable;ITableHistogram pTH = new BasicTableHistogramClass();pTH.Field = \"POP_CNTRY\"; pTH.Table = pTable;object pValues, pFrequencies;(pTH as IBasicHistogram).GetHistogram(out pValues, out pFrequencies);// Get the result of quantile classification with 5 classesIClassifyGEN pCGEN = new QuantileClass();pCGEN.Classify(pValues, pFrequencies, 5);double[] pClasses = pCGEN.ClassBreaks as double[]; // double[6]// Set the UniqueValueRendererIClassBreaksRenderer pCBR = new ClassBreaksRenderer();pCBR.Field = \"POP_CNTRY\"; pCBR.BreakCount = 5; pCBR.MinimumBreak = pClasses[0];// Build an AlgorithmicColorRamp and get the cursorIRgbColor pRC1 = new RgbColorClass();pRC1.RGB = ColorTranslator.ToOle(ColorTranslator.FromHtml(\"#D6D6FF\"));IRgbColor pRC2 = new RgbColorClass();pRC2.RGB = ColorTranslator.ToOle(ColorTranslator.FromHtml(\"#003994\"));IAlgorithmicColorRamp pACR = new AlgorithmicColorRampClass();pACR.Algorithm = esriColorRampAlgorithm.esriCIELabAlgorithm;pACR.FromColor = pRC1; pACR.ToColor = pRC2; pACR.Size = 5;bool pCheck; pACR.CreateRamp(out pCheck);IEnumColors pEnumColors = pACR.Colors; pEnumColors.Reset();// Set the symbol of each classfor (int i = 0; i &lt;= 4; ++i) {    pCBR.set_Break(i, pClasses[i + 1]);    pCBR.set_Label(i, String.Format(\"{0} - {1}\", pClasses[i], pClasses[i + 1]));    ISimpleFillSymbol pSFS = new SimpleFillSymbolClass();    pSFS.Color = pEnumColors.Next();    pCBR.set_Symbol(i, pSFS as ISymbol);}// Render and refresh(pFL as IGeoFeatureLayer).Renderer = pCBR as IFeatureRenderer;m_App.ActiveView.Refresh(); m_TOC.Update();\n在世界地图上文字标注每个国家的全名和面积。IGeoFeatureLayer pGFL = pFL as IGeoFeatureLayer;IAnnotateLayerPropertiesCollection pALPC = pGFL.AnnotationProperties;// Set the fontITextSymbol pTS = new TextSymbolClass(); pTS.Size = 8;pTS.VerticalAlignment = esriTextVerticalAlignment.esriTVACenter;pTS.HorizontalAlignment = esriTextHorizontalAlignment.esriTHACenter;stdole.IFontDisp pFD = new stdole.StdFontClass() as stdole.IFontDisp;pFD.Name = \"Consolas\"; pTS.Font = pFD;// Modify the first (already existed) AnnotateLayerPropertiesIAnnotateLayerProperties pALP; IElementCollection pECpe, pECue;pALPC.QueryItem(0, out pALP, out pECpe, out pECue);ILabelEngineLayerProperties pLELP = pALP as ILabelEngineLayerProperties;pLELP.Expression = String.Format(\"[{0}]\", ed.SelectedField);pLELP.Symbol = pTS;// Construct a new AnnotateLayerProperties and add itpLELP = new LabelEngineLayerPropertiesClass();pLELP.Expression = \"[Area]\"; pLELP.Symbol = pTS;pALPC.Add(pLELP as IAnnotateLayerProperties);// Display the annotation and refreshpGFL.DisplayAnnotation = true;m_App.ActiveView.Refresh();\n创建一个点矢量图层，拥有OID、Shape、Name字段。// Prepare a FeatureWorkspace and a FeatureLayerIWorkspaceFactory pWF = new ShapefileWorkspaceFactoryClass();IFeatureWorkspace pFW = pWF.OpenFromFile(@\"C:\\myetyet\", 0) as IFeatureWorkspace;IFeatureLayer pFL = new FeatureLayerClass(); pFL.Name = \"New Point Layer\";// Create a fields collection for the feature classIFields pFs = new FieldsClass(); IFieldsEdit pFsE = pFs as IFieldsEdit;// Add an ObjectID field to the fields collectionIField pOIDF = new FieldClass(); IFieldEdit pOIDFE = pOIDF as IFieldEdit;pOIDFE.Name_2 = \"OID\"; pOIDFE.Type_2 = esriFieldType.esriFieldTypeOID;pFsE.AddField(pOIDF);// (Optional) Set the spatial referenceISpatialReferenceFactory pSRF = new SpatialReferenceEnvironmentClass();int pPCS = (int)esriSRProjCSType.esriSRProjCS_NAD1983UTM_20N;ISpatialReference pSR = pSRF.CreateProjectedCoordinateSystem(pPCS);ISpatialReferenceResolution pSRR = pSR as ISpatialReferenceResolution;pSRR.ConstructFromHorizon(); pSRR.SetDefaultXYResolution();ISpatialReferenceTolerance pSRT = pSR as ISpatialReferenceTolerance;pSRT.SetDefaultXYTolerance();// Define the GeometryDefIGeometryDefEdit pGDE = new GeometryDefClass();pGDE.GeometryType_2 = esriGeometryType.esriGeometryPoint;pGDE.SpatialReference_2 = pSR;// Add the field \"Shape\"IField pGDF = new FieldClass(); IFieldEdit pGDFE = pGDF as IFieldEdit;pGDFE.Name_2 = \"Shape\"; pGDFE.Type_2 = esriFieldType.esriFieldTypeGeometry;pGDFE.GeometryDef_2 = pGDE as IGeometryDef;pFsE.AddField(pGDF);// Add the field \"Name\"IField pNF = new FieldClass(); IFieldEdit pNFE = pNF as IFieldEdit;pNFE.Name_2 = \"Name\"; pNFE.Type_2 = esriFieldType.esriFieldTypeString;pNFE.Length_2 = 20;pFsE.AddField(pNF);// (Optional) Use a FieldChecker to create a validated fields collectionIFieldChecker pFC = new FieldCheckerClass();IEnumFieldError pEFE = null; IFields pVFs = null;pFC.ValidateWorkspace = pFW as IWorkspace;pFC.Validate(pFs, out pEFE, out pVFs);// Create the feature classesriFeatureType pFT = esriFeatureType.esriFTSimple;pFL.FeatureClass = pFW.CreateFeatureClass(pFCN, pVFs, null, null, pFT, \"Shape\", \"\");// Write as follows if did not use a FieldChecker// pFL.FeatureClass = pFW.CreateFeatureClass(pFCN, pFs, null, null, pFT, \"Shape\", \"\");m_App.AddLayer(pFL);\n编辑新建的点矢量图层，添加两个坐标不同的点。IWorkspaceEdit pWE = pFW as IWorkspaceEdit;pWE.StartEditing(true); pWE.StartEditOperation();IFeature pFeature1 = pFL.FeatureClass.CreateFeature();IPoint pPoint1 = new PointClass(); pPoint1.PutCoords(0, 0);pFeature1.Shape = pPoint1 as IGeometry;int index = pFeature1.Fields.FindField(\"Name\");pFeature1.Value[index] = \"Point 1\"; pFeature1.Store();IFeature pFeature2 = pFL.FeatureClass.CreateFeature();IPoint pPoint2 = new PointClass(); pPoint2.PutCoords(2, 3);pFeature2.Shape = pPoint2 as IGeometry;pFeature2.Value[index] = \"Point 2\"; pFeature2.Store();pWE.StopEditOperation(); pWE.StopEditing(true);\n对人口排行字段进行IDW插值，然后将生成的栅格保存为.tiff格式的文件并进行栅格数据统计分析。// IDW interpolationIFeatureLayer pFL = m_App.get_Layer(1) as IFeatureLayer; // citiesIFeatureClassDescriptor pFCD = new FeatureClassDescriptorClass();pFCD.Create(pFL.FeatureClass, null, \"POP_RANK\");IRasterRadius pRR = new RasterRadiusClass(); pRR.SetVariable(12);IInterpolationOp pIO = new RasterInterpolationOpClass();IRasterAnalysisEnvironment pRAE = pIO as IRasterAnalysisEnvironment;pRAE.SetCellSize(esriRasterEnvSettingEnum.esriRasterEnvValue, 0.5);IGeoDataset pGDin = pFCD as IGeoDataset;IGeoDataset pGDout = pIO.IDW(pGDin, 2, pRR);IRasterLayer pRL = new RasterLayerClass();pRL.CreateFromRaster(pGDout as IRaster);m_App.AddLayer(pRL);// Save fileIWorkspaceFactory pWF = new RasterWorkspaceFactoryClass();IRasterWorkspace pRW = pWF.OpenFromFile(@\"C:\\myetyet\", 0) as IRasterWorkspace;(pGDout as ISaveAs).SaveAs(\"IDW.tiff\", pRW as IWorkspace, \"TIFF\");// Raster statisticsIRasterBandCollection pRBC = pGDout as IRasterBandCollection;IRasterBand pRB = pRBC.Item(0);bool pCheck; pRB.HasStatistics(out pCheck);if (!pCheck) pRB.ComputeStatsAndHist();IRasterStatistics pRS = pRB.Statistics;List&lt;string&gt; res = new List&lt;string&gt;();res.Add(String.Format(\"Max = {0}\", pRS.Maximum));res.Add(String.Format(\"Min = {0}\", pRS.Minimum));res.Add(String.Format(\"Ave = {0}\", pRS.Mean));res.Add(String.Format(\"Mode = {0}\", pRS.Mode));res.Add(String.Format(\"StdEv = {0}\", pRS.StandardDeviation));MessageBox.Show(string.Join(\"\\n\", res));\n由栅格数据生成五级等高线。ISurfaceOp pSO = new RasterSurfaceOpClass(); double[] pSep = { 0, 1, 2, 3, 4 };IFeatureClass pFC = pSO.ContourList(pRD as IGeoDataset, pSep) as IFeatureClass;IFeatureLayer pFL = new FeatureLayer(); pFL.FeatureClass = pFC;m_App.AddLayer(pFL);\n用矩形包围框对矢量数据进行裁切并添加图层至地图。IRasterLayer pRL = m_App.Layer[0] as IRasterLayer;IEnvelope pEnvelope = m_App.TrackRectangle();IExtractionOp pEO = new RasterExtractionOpClass();IRasterAnalysisEnvironment pRAE = pEO as IRasterAnalysisEnvironment;pRAE.SetExtent(esriRasterEnvSettingEnum.esriRasterEnvValue, pEnvelope);IGeoDataset pGD = pEO.Rectangle(pRL.Raster as IGeoDataset, pEnvelope, true);pRL = new RasterLayerClass(); pRL.CreateFromRaster(pGD as IRaster);m_App.AddLayer(pRL);\n修改现有矢量数据的对角线上（横纵索引号一致）的数据为原先的倍。IRasterProps pRP = pRaster as IRasterProps;int pWidth = pRP.Width, pHeight = pRP.Height;IPnt pPnt = new PntClass(); pPnt.SetCoords(pWidth, pHeight);IPixelBlock pPB = pRaster.CreatePixelBlock(pPnt);pPnt.SetCoords(0, 0); pRaster.Read(pPnt, pPB);float[,] pArray = pPB.SafeArray[0] as float[,];for (int i = 0; i &lt; pWidth; ++i)    for (int j = 0; j &lt; pHeight; ++j)        if (i == j) pArray[i, j] *= 10;pPB.SafeArray[0] = pArray;IRasterEdit pRE = pRaster as IRasterEdit;pPnt.SetCoords(0, 0); pRE.Write(pPnt, pPB);pRE.Refresh();\n将矢量数据所有单元格的数据乘以并作为新的图层添加至地图。IMapAlgebraOp pMAO = new RasterMapAlgebraOpClass();pMAO.BindRaster(pRaster as IGeoDataset, \"Rmyetyet\");IGeoDataset pGDout = pMAO.Execute(\"[Rmyetyet] * 2\");IRasterLayer pRL = new RasterLayerClass();pRL.CreateFromRaster(pGDout as IRaster);m_App.AddLayer(pRL);\n添加包含多波段的*.tif文件中的特定波段至地图。// Open raster datasetIWorkspaceFactory pWF = new RasterWorkspaceFactoryClass();IRasterWorkspace pRW = pWF.OpenFromFile(@\"C:\\myetyet\", 0) as IRasterWorkspace;IRasterDataset pRD = pRW.OpenRasterDataset(\"Layers.tif\");IRasterBandCollection pRBC = pRD as IRasterBandCollection;// Add a RasterLayer to the map with the speicific band (e.g. third)IRasterBand pRB3 = pRBC.Item(3);IRaster pRaster3 = new RasterClass();(pRaster3 as IRasterBandCollection).AppendBand(pRB3);IRasterLayer pRL = new RasterLayerClass();pRL.CreateFromRaster(pRaster3); pRL.Name = pRB3.Bandname;m_App.AddLayer(pRL);\n矢量数据的拉伸渲染。// Build an AlgorithmicColorRampIRgbColor pColor1 = new RgbColorClass(); pColor1.Red = 0xff;IRgbColor pColor2 = new RgbColorClass(); pColor2.Blue = 0xff;IAlgorithmicColorRamp pACR = new AlgorithmicColorRampClass();pACR.Size = 255; pACR.FromColor = pColor1; pACR.ToColor = pColor2;bool pCheck; pACR.CreateRamp(out pCheck);// Set the RasterStretchColorRampRendererIRasterStretchColorRampRenderer pRSCRR = new RasterStretchColorRampRendererClass();pRSCRR.BandIndex = 0; pRSCRR.ColorRamp = pACR;IRasterRenderer pRR = pRSCRR as IRasterRenderer;IRasterLayer pRL = m_App.Layer[0] as IRasterLayer;pRR.Raster = pRL.Raster;IRasterStretch pRS = pRR as IRasterStretch;pRS.StretchType = esriRasterStretchTypesEnum.esriRasterStretch_StandardDeviations;pRS.StandardDeviationsParam = 2.0;pRR.Update();// Render and refreshpRL.Renderer = pRR;m_App.ActiveView.Refresh(); m_TOC.Update();\n矢量数据的分级渲染。// Build an AlgorithmicColorRamp simplyIAlgorithmicColorRamp pACR = new AlgorithmicColorRamp(); pACR.Size = 5;bool pCheck; pACR.CreateRamp(out pCheck);// Set the RasterClassifyColorRampRendererIRasterClassifyColorRampRenderer pRCCRR = new RasterClassifyColorRampRendererClass();pRCCRR.ClassCount = 5;IRasterRenderer pRR = pRCCRR as IRasterRenderer;IRasterLayer pRL = m_App.Layer[0] as IRasterLayer;pRR.Raster = pRL.Raster;for (int i = 0; i &lt; 5; i++) {    ISimpleFillSymbol pSFS = new SimpleFillSymbol();    pSFS.Color = pACR.Color[i];    pRCCRR.set_Symbol(i, pSFS as ISymbol);    pRCCRR.set_Label(i, \"Class \" + i.ToString());}pRR.Update();// Render and refreshpRL.Renderer = pRR;m_App.ActiveView.Refresh(); m_TOC.Update();\n\n","categories":["学科笔记"]},{"title":"《创新创业基础》视频文字稿","url":"/posts/36c7715c/","content":"前言视频文字稿整理：@Abyss @myetyet\n创新创业教育背景创业与大学生创业&#8195;&#8195;当前大学生创业越来越受到世界各国的关注。作为未来社会中坚力量的大学生，所以身在校园，却能通过各种信息渠道深刻了解到国内外的变化。一方面，全球经济一体化的世界局势日益健康完善的经济环境，为大学生创业提供了良好的外部条件。另一方面，国内外不断涌现的大学生创业成功案例，无疑对大学生产生了很大的诱惑与启发，激发了他们的创业激情。当不再把创业仅仅当作是一个时髦的词语来看待，而是作为一种社会现象进行思考和叹息的时候，创业就具有了不可抗拒的魔力。&#8195;&#8195;第一节，创业与大学生创业。&#8195;&#8195;首先我们来看一下关于创业的基本内涵。创业的概念经历过一个不断发展演变的过程。现今没有一个统一的共识，但社会的发展进步、人类的实践活动不断赋予“创业”新的内涵。因此，要深入了解创业的概念，必须将之置之于特定的社会环境当中来理解。首先，我们来看一下创业的概念在中国的发展。“创业”一词最先出现时，与“垂统”连用。《孟子·梁惠王》中有：“君子创业垂统，为可继也。”句中的“创业”是创建功业，传之子孙的意思。这样的含义在古汉语中一直沿用数千年，经过总结发现，传世古籍中，大凡出现创业一词时，多为开拓疆土、创建功业的意思，有鲜明的封建君主建功立业、传之后世的含义。走入近现代社会，创业的释义在古代汉语的基础上，有了全新的发展。辞海中将创业解释为创立基业、事业，创业的行为主体，已经从古代的帝王转变为普通百姓，创业的内容也从开疆拓土、建立新王朝转变为一切能够创造新事物、新价值的活动。但“创业”最初起源里“传之后世”的重要特点却沿用了下来，即“可继承性”。“创业”一词真正在中国社会得到广泛应用，是进入20世纪80年代改革开放之后。中国逐步由计划经济进入到市场经济时代，商品经济的快速发展，为更多的老百姓提供了区别于传统的发财致富的“创业之路”。创业作为一种新兴的经济活动，为越来越多的专家学者所重视、研究。不同时期，也有不同的研究者对创意的内涵提出了自己的观点。2000年，郁义鸿等在《创业学》中提出：“创业是一个发现和捕捉机会，并由此创造出新颖的产品、服务，实现其潜在价值的过程。”2002年，宋克勤提出：“创业是创业者通过发现和识别商业机会，组织各种资源，提供产品和服务，以创造价值的过程。”罗天虎认为，创业是社会上的个人或群体为了改别现状，造福后人，依靠自己的力量，创造财富的艰苦奋斗的过程，是开创事业和积累财富的过程。创业活动具有开拓性、自主性和功利性的基本特征。近年来，随着社会及经济的发展，越来越多的人投入到创业的浪潮中去，对创业的内涵研究和探讨还会继续下去。&#8195;&#8195;二、我们来看一下创业的概念在国外的发展。创业的英文翻译有两种，一个是动词，另外一个是名词，那么关于动词venture的侧重表现在创业的行为活动。在20世纪创业活动蓬勃发展以后，使用动词venture更能揭示“创建企业”这一动态过程，而名词entrepreneurship则表示静态的创业状态或创业活动。作为经济活动的创业，在欧美国家已经有了几百年的发展历史。创业的概念在国外商业领域当中也已经使用了200多年。然而，国外的专家学者对“创业”也没有达成最完备、权威的统一认识。最早的“创业”定义是由18世纪理查德·康蒂隆提出的：“创业隐含了承担，以确定价格买进而已，不确定价格卖出的风险。”此后，国外的学者从未停止过对创业的内涵的研究，创业的概念也在不断的演变发展。1934年，约瑟夫·熊彼特首次将创业的概念与创新联系起来，认为创业的本质是创新，创业的过程就是创新的过程，创业者通过创新，使自由市场经济的内在矛盾得以克服，从而促使经济的增长。1989年，霍华德·斯蒂文森提出 ：“创业是一个人不管是独立的还是一个组织内部追踪或捕获机会的过程，这一过程与当时控制的资源无关”。后来他又进一步的指出：“创业是可以由六个方面的企业经营活动来理解的，即发现机会、战略导向、致力于机会、资源配置过程、资源控制的概念以及管理的概念和回报政策。”1999年，杰弗里·A·蒂蒙斯提出： “创业是一种思考、推理和行为方式，这种行为方式是机会驱动，注重方法和与领导相平衡。创业导致价值的产生、增加、实现和更新，不只是为所有者，也为所有的参与者和利益相关者。”总的来说，国外对创业概念的研究要比国内早得多。在对创业定义的表述中，有人侧重的是创业的经济功能，有人侧重的是创业的过程，而有人则侧重将之视为一种管理的方式和方法。&#8195;&#8195;三、创业定义。无论是国内学者还是国外专家，由于研究创业行为的视角不同，得出的结论也不同。创业是一个横跨经济学、心理学、社会学、人类学、管理学等多个学科的复杂现象。在总结借鉴前人理论的基础之上，我们将创业进行了广义和狭义的定义。广义的创业是指创造新的基业、事业，泛指人类一切具有开拓意义的社会变革行为。而狭义的创业是指以个人或团队的形式运用一切外界资源和力量，开创性的去寻求机遇，创立实业或企业，并谋求发展的一种经济活动。通过这种活动，创业者获得了精神和物质的满足。在这里，我们要讨论的创业，主要是指狭义的创业，完整的创业活动，有四大核心要素：创业者、市场机会、组织以及资源。创业者是指开展创业活动的个人或者团体，其在创业过程当中，起着关键的推动和领导作用；市场机会也可以称为商业机会，是指能够促进产品开发和这市场开拓。能够推动企业生产，提高经济效益的信息条件等，创业活动通常从创业者发现和把握市场机会开始；组织是指一个完整的创业活动系统，包括企业内的系统与企业外的系统；资源是指创业活动当中的各种投入，包括人财物的，既包括厂房、机器等有形资产，也包括品牌、专利企业声誉等无形资产。&#8195;&#8195;那么接下来我们来看一下创业与创新的关系。约瑟夫·熊彼特在经济发展理论当中提出：“创新是在生产体系当中，引进一种生产要素和生产条件的新组合，包括五种情况：引进新产品、引进新的生产方法、开辟新的市场、控制原材料的新来源、建立企业的新组织。这些新的组合，能够使原来的成本曲线不断更新，由此会产生超额利润或潜在的超额利润。”创新活动的这些本质，体现着他与创业活动的性质上是赢一致性和关联性的。&#8195;&#8195;一、创新是创业的基础，创业推动着不断创新。一方面，科学技术思想观念的创新，能够促进人们这些物质生产、生活方式的变革，从而引发新的生产生活方式，进而为整个社会不断的提供新的消费需求。这是创业活动之所以源源不断的根本原因。另一方面，创业是人们的一种创新性的实践活动。无论是何种性质类型的创业活动，他们都有一个共同的特征，那就是，创业是创业者的一种能动的开创性的实践活动。这种主观能动性，充分体现了创业的创新性特征。&#8195;&#8195;二、创新是创业的本质与源泉。创业者只有在创业的过程当中，具有持续的创新思维和创新意识，才可能产生新的富有创意的想法和方案，才可能不断寻求新的经营和管理模式与思路，最终获得创业的成功。&#8195;&#8195;三、创业是创新的重要价值体现。从一定程度上讲，创新的价值就在于将潜在的知识、技术和市场机会转变为现实生产力，实现这种转化的最直接有效的途径就是创业。创新与创业相互关联。四、创业推动并深化创新。创业可以推动新发明星产品或者新服务的不断涌现，创造出新的市场需求，从而进一步推动和深化各方面的创新，提高企业或者是整个国家的创新能力，推动经济的增长。由此可见，创新和创业二者是紧密联系的，一个成功的创业者必须具备在技术上和管理上的创新能力。创业者首先是创新者，创新意识是创业者的核心精神，创新贯穿于创业的全过程。创业活动是创新精神的重要表现形式。&#8195;&#8195;第三个方面，我们再来看一下大学生创业的特点以及意义。大学生创业具有他自由的特点。大学生处在职业选择和事业起步的关键期，既有创业的优势，即系统的专业知识和技能、思维灵活、创新意识强；同时又有明显的不足，就是社会阅历欠缺、人际交往很窄、适应性弱、缺乏人脉和资金等等。那大学生创业也具有时代意义。从上个世纪80年代起，全世界都卷入了创业的热潮之中。&#8195;&#8195;大学生的创业对于国家发展、社会进步个体价值的实现意义重大。&#8195;&#8195;首先，我们说大学生的创业能够推动经济发展，社会的进步。在上世纪80年代以前，世界各国基本还没有认识到创业活动产生的小企业对于经济、社会发展的重要意义，而迷信于大企业在经济发展当中的作用。1973年石油危机的发生给世界经济带来了严重的波动，各国经济结构的危机问题凸显，人们才看到了大公司僵硬的体制对于市场环境适应的调解较慢。1979年，美国麻省理工大学经济学家伯克发表了爆炸性的经济研究结果，即美国的小企业在工作岗位创造和经济发展当中，起着重要的作用。在1969到1979年之间，小企业创造了81%的新工作，承担了美国税收总数的54%以上，小企业成为美国经济发展的动力源泉。创业还创建和领导了全新的行业，新行业代替老行业的频率越来越快。上个世纪六十年代，社会若想以新型的企业来更新世界500强企业当中35%的公司需要20年的时间；到了80年代后期只需要5年；到了90年代仅需要3到4年的时间。那么对于我国来说，目前正处于市场经济体系不断完善的过程当中，大学生创业不论成功与否，都将为社会培养储备一批具有较高文化层次及丰富社会实践的人才。这一点对于社会发展的战略意义远大于经济利益。&#8195;&#8195;二、大学生创业能够增加就业机会，缓解就业压力。大学生创业不仅能解决自身的就业问题，还能为其他毕业生提供就业岗位，缓解日趋严峻的就业压力，解决经济结构调整带来的全国范围内的就业难题。有研究表明，一个企业的创立，至少能够提供3到6个工作岗位，如果每年的毕业生当中有十分之一创业，那么大学生的就业压力将不再成为急需解决的社会问题。&#8195;&#8195;三、大学生创业能够加速技术创新的步伐，促进科技成果向生产力的转化。教育和引导大学生创业，有利于培养广大高校学生的创业精神、创业意识和创业能力，在全社会营造科技创新的氛围，增强企业的自主创新能力和国际竞争力。当代大学生如果缺乏创业的冲动和欲望，而仅仅安于现状和守成，那么国家将失去持续发展的不竭动力。&#8195;&#8195;四、大学生创业推动了高等教育的发展。大学生的创业活动是高效课堂教育和学生实践活动的有机结合，是对高校创业教育开展成效的实践检验。大学生的创业实践过程不但是对他们自身意志品质创业能力的检验，同时也检验的高等学校的创业教育开展的成效。&#8195;&#8195;五、大学生创业有助于个人的成长，有利于实现个人的价值。大学生创业活动有助于大学生个人能力和素质的全面提升。一方面，创业活动能够有效的引导大学生，自觉培养创新意识，创新精神和实践能力。另一方面，创业活动的开展，也能够客观的反映大学生自身存在的缺陷。在创业过程当中。让大学生反思还有哪些不足，以便更有针对性地来提升自己。&#8195;&#8195;谢谢大家这节课我们就讲到这里。  \n大学生创业与国外创业教育发展历史&#8195;&#8195;第二节、大学生创业与国外创业教育发展历史。&#8195;&#8195;首先我们来看一下创业教育的概念。创业教育的理念是1989年11月底至12月初，联合国教科文组织在北京召开了“面向21世纪教育国际研讨会”上首次用到了“创业教育”这一全新的概念。1998年1月，联合国教科文组织在50年来首次世界高等教育会议上，发表了《21世纪的高等教育：展望与行动世界宣言》和《高等教育改革和发展的优先行动框架》两个文件，一致强调必须把培养学生的创业技能和创业精神作为高等教育的基本目标。1999年4月，联合国教科文组织在汉城举行了第二届的国际职业技术大会，会上，除进一步强调了创业教育，又特别强调的创业能力是一种核心能力，必须通过普通教育和职业教育来培养。创业教育的任务是通过揭示创业活动的一般规律、创业活动的特点和本质介绍创业的基本知识和技能，帮助学生认识创业的意义，树立创业意识，培养创新精神，更新就业观念。创业教育的目标是让学生了解创新创业活动。在经济发展当中的地位和作用，了解创业过程当中的一般规律，是学生对自己的创业项目。以及技能进行评估，了解新企业进入市场的一般策略，了解创业计划的基本要素，了解如何控制和管理新型创新企业的成长与扩张等规律。&#8195;&#8195;二、我们来看看创业教育的作用。创业教育的理念，对于高等教育的办学体制管理体制、人才培养模式等提出了新的要求。他是世界各国高等教育在信息化与全球化背景下的必然选择和发展趋势，对社会发展有着重要的意义和作用。一、培养创业意识，是创业教育的一个重要任务。创业教育的首要任务是使大学生树立独立开拓、勇于创新、敢于竞争的创业意识，引导学生愿意创业，创业教育的一个重要目的，就是鼓励学生将创业作为自己的职业选择，并为学生的创业活动提供科学的指导和有力的平台创业教育，能够极大的激发大学生的创业意识和创新精神，培养他们从被动的就业观念转变为主动的创业观点。二、创业教育还可以提高创业活动的成功率。创业教育有助于提高大学生的创业素质；有助于创业企业的顺利产生；创业教育有助于提高创业企业对风险的防范能力；以及有利于创业者管理水平的提高。那么，如何去提高大学生的就业能力呢？创业教育有利于引领大学生转变就业观念，还拓宽了大学生的就业思路。另外，创业教育也有利于提升大学生的就业竞争力。&#8195;&#8195;第三个方面，我们来看一下国外大学生创业以及创业教育。&#8195;&#8195;美国是全世界大学生创业活动以及创业教育的开拓者实践者和成功者，可以成为世界各国学习的典范。英国、日本作为欧洲和亚洲发达国家的代表，在大学生创业以及创业教育方面，也取得了较其他国家更为突出的成就，可以为我国提供更为直接有效的经验。首先，我们来看一下美国的大学生创业以及创业教育。早在1947年，哈佛大学商学院的迈尔斯·梅斯教授，就以MBA学生为对象，开设了创业课程。然而，当时美国的经济发展以大企业为支柱和主流，大学生创办小企业并没有引起重视。1973年的石油危机爆发，暴露了美国在经济发展过程当中的结构性问题。1979年，麻省理工学院伯克教授里程碑式的研究，揭示了创业对于经济发展的重要作用，震惊的美国社会各界并引起了大讨论。此后几年，美国的大学生创业活动以及创业教育逐步为社会关注以及重视。美国大学生的创业热情起始于1983年，德克萨斯州大学奥斯汀分校的两位MBA学生举办的第一届创业计划竞赛。这场竞赛在当时引起了社会及高效的强烈反响。此后，美国很多高校陆续举行的创业计划大赛，其中以麻省理工大学“五万美金创业计划竞赛”最为成功。据统计，美国表现最优秀的50家高新技术公司当中的23家出自于麻省理工学院的创业竞赛。可见美国的大学生创业计划大赛为美国大学生创业做出了突出的贡献。美国大学生创业成功的案例不胜枚举。这些在创业过程当中，取得杰出成就的大学生创业者，成为全球有志于创业的大学生的偶像和楷模。这一群人中，又创造了世界级企业的耳熟能详的名字，如微软的比尔·盖茨、戴尔计算机公司的戴尔、雅虎公司的杨志远等。除此之外，还有无数的中小型企业的创业者。据麻省理工学院统计，自1990年以来，麻省理工学院的大学生和教师平均每年创建150多个新公司，到1999年，该校的毕业生已经创办了4000家公司，雇用了110万个岗位，创造了2320亿美元的销售额。总结起来，美国的大学生创业有着鲜明的特点。首先，美国的社会文化为大学生创业提供了良好的外部环境。美国人特有的开拓牛仔精神，以及对于财富的追求，成为美国大学生创业所特有的创业精神。其次，美国的大学生创业意愿高，创业人数多。美国考核办企业领导中心的研究报告显示，每12个美国人当中就有一个人期望自己开办自己的企业。再次，美国的创业大学生主要集中在100多所理工大学，他们普遍以技术为核心，致力于科学技术向生产力的转化。例如斯坦福大学的师生、校友的创业活动促进了硅谷的创业活动，他们创办的企业产值约占硅谷总产值的50%到60%。最后，美国的大学生创业成功率非常高。那么美国是如何构建它的成熟的创业教育体系的呢？首先，美国大学生创业计划大赛，是帮助学生从大学生走向市场的捷径。美国的创业大赛采用市场运作的模式。学生参加创业计划大赛，一方面可以获得创业计划大赛的经验和不菲的奖金，另一方面还有机会从经验和反馈中学习。一大批对美国经济发展做出重要贡献，并且成为高科技企业领军人物的都是曾经在创业计划大赛当中的获奖者。比如苹果、雅虎、网景、戴尔等等。第二，美国为大学生创业提供了商业孵化器。据统计，2006年10月，美国拥有1115个孵化器。这些孵化器有力的促进了大学生科技创新成果的商业化，降低了小企业的运营风险，创造了大量的就业岗位。第三，美国大学科技园是支持大学生创业的重要手段。自1951年斯坦福大学创办了第一个科技园并成功运行以来，美国大学科技园正逐渐发展，成为产学研结合的重要基地和创新创业人才培养的摇篮。第四，美国高校的成熟完备的创业教育体系，成功培养了创业型人才。美国高校将创业教育渗透到大学的各个学科、各个领域，越来越多的高校构建了全校性的创业教育项目。&#8195;&#8195;接下来我们看一下英国的大学生创业及创业教育。英国的大学生创业，得益于英国的青年创业计划。自1973年的石油危机到1983年的十年间，英国的经济一直处于负增长状态，失业率长期居高不下。为了解决日趋严重的社会失业问题，英国王储查尔斯于1983年开始倡导青年创业计划，并设立了王子基金。基金动员并联合社会和企业，为青年创业者提供了资金、技术、网络、咨询等各种服务，并开始推行称之为“自我雇佣”的创业培训。有调查显示，接近三成的英国年轻人，有自主创业的想法，或者正在实行。53%的在校学生希望能够成为企业家。英国参加课外创业活动。动的学生人数为87869人，占参与创业教育活动学生人数的66%。英国大学生创业的兴起和发展，与英国王室和政府的大力提倡、大量投入密不可分。英国的大学生创业教育已经形成了完整优良的创业帮扶和创业教育体系。首先，英国政府专门设立了大学生创业机构，用于指导服务大学生创业活动。1999年，英国政府推动成立了英国科学创业中心，下设8个创业中心，后来发展的13个，涉及到英国的60多所高校。2000年，英国政府又成立专门的机构小企业服务，由20个具有经营中小企业实践经验的创业家组成，为大学生创业提供建议和援助。2004年，教育与技能部小企业服务，共同出资的70万英镑，建立了全国大学生创业委员会，全面负责大学生创业活动的指导。其次，英国建立了多项创业项目及基金，鼓励扶持大学生创业。英国王室设立的王子基金，为申请者个体提供5000英镑的利息贷款，开办自己的企业，在特殊情况下，还另外给予奖金。基金会成立以后，已经扶持成立了数万个新企业。2001年，英国政府启动了高等教育创新基金，一个重要之初就是支持大学内部师生的创业活动，比如专利申请、资金启动、公司筹建和市场开发等。第三、英国积极开展创业教育研究，探索教与学的新模式。随着大学生创业活动的开展，创业教育也扩展到英国不同层次和不同专业的学生。如何将创业教育的理念融入大学的核心价值体系，如何将创业整合到大学的其他课程当中去促进教学模式教学态度和教学方法的改变，成为了一个新挑战。高等教育学会为英国大学提供创业技能教学的材料，该学会的各种小组，以及各个学科中心的工作，为高校的创业教育提供了学术支持，学会还在全国发起了大学生创业技能计划，目的在各个专业的本科生课程当中嵌入有关创业技能的内容。英国在青年创业中，推行一对一的创业辅导。在创业的前三年当中，每个创业的青年都会得到一名创业导师的帮助。创业导师一般每个月进行4到5小时的指导，指导方式灵活多样，可以是实地考察、电话咨询等。导师完全由志愿者担任。&#8195;&#8195;第三、我们来看一下日本的大学生创业以及创业教育。与欧美国家相比，日本的青年创业意识处于较低的水平，甚至不如韩国。2000到2003年。GEM报告显示，日本劳动人口当中创业者比例仅有2.7%，而美国、英国分别是11.6%和6.1%。进入21世纪后，随着经济的发展，日本人就业观念发生了巨大变化。许多大学生的创业意识正在增强。为了实现日本经济的全面振兴，把“失去的十年”转化为培养新兴企业和风险企业的“孵化的十年”。日本全国范围内掀起了创建高新技术企业和高附加值、高成长风险企业的浪潮。日本政府也将培养富有挑战精神、创新能力的创业人才作为国家的重要战略。日本最初实施创业教育，开展创业教育课程的学校不过30所左右。但近年来发展势头强劲，目前已经超过了200所，形成了自己的“官产学”协作一体的创业教育特色。第一，日本政府对高校创业教育支援力度大。日本政府将“官产学”合作，视为日本创业教育的主要理念。政府在创业教育体系当中，始终处于指导者、推动者和协助者的角色。近年来，日本又在简化新公司申请手续，广泛的资金援助方面出台的政策，为大学生创业和高效的创业教育提供良好的服务。第二，日本众多企业和中介机构，为高校创业教育做出了重要贡献。日本的众多企业既向学校提供人才供需意见，为学校提供见习基地，还未有潜力的创业计划提供风险资金，并且到企业和大学联合开发创业教育教材、课程，设计创业型人才的培养方案和实施方案。第三，日本高校不断改变大学的教育理念，甚至创立了全新的办学思想，很多高校在原有设施的基础之上，加强了创业企业孵化器、创业辅导机构等基础设施的建立，加强与校友资源的联系，同时在原有管理和经营学课程的基础上，结合学校的特色，开展了工科创业计划，开设广泛的创业课程。在创业师资方面，导入了具有优秀企业家资源和创业经历的“双师”，提升教育质量。&#8195;&#8195;谢谢大家，这节课我们就上到这里。  \n我国创业教育发展及现状&#8195;&#8195;第三节、我国创业教育发展及现状。&#8195;&#8195;近十多年来，随着国家对大学生创业重视程度的提高，相关部门和地方政府做出了很多积极的探索。我国的大学生创业教育活动逐步活跃起来。不少大学生用创业实践，为我国的大学生创业活动，积累了很多成功的经验和失败的教训，同时也为我国高校开展创业教育指明了方向。&#8195;&#8195;首先，我们来看一下我国大学生创业活动兴起的背景。&#8195;&#8195;我国大学生创业的普遍兴起，是在特定的国际环境下，伴随着我国社会经济的改革以及高等教育的改革而开始的。从国际背景来看，近年来创业文化在全球兴起，无论是发达国家还是发展中国家，大学生创业都成为一个社会时尚，并引起了社会的广泛关注和重视。纵观世界经济的全局，全球经济一体化的趋势已经基本形成，中国作为这条产业链上的重要一环，在产业结构上深受全球经济发展的影响。在国际化背景中，产业结构的调整与升级也不断刺激着我国创业活动的兴起与发展。从国内背景来看，首先，我国已经基本完成了社会的转型，国内的创业环境不断完善，国家出台了一系列的政策，鼓励引导大学生创业有效的刺激了大学生的创业热情。同时，高等学校将创业教育纳入素质教育的范畴，学生的创业素质创业能力得到了明显的提升。这也为大学毕业生自主创业提供了基础条件。其次，我国大学生就业压力明显增加，促进了我国“以创业促进就业”政策的出台。第三，我国科技发展的速度，以及国际化产业结构的调整，为大学生创业带来了很大的机遇。我国大学生创业活动兴起于20世纪90年代后期进入21世纪后，初步形成的规模主要分为起步时期、高热时期和理性时期。起步期是从1997年到1999年。1997年，清华大学研究生举办了第一届的清华大学创业计划大赛，标志着我国大学生创业的起点。大赛直接孵化了四家学生公司，其中首推视美乐科技发展有限公司，获得上海第一百货股份有限公司5250万元的投资承诺。1999年，清华大学举办的第二届创业计划大赛，北京大学、华中理工大学、上海交通大学也于1999年开始举办自己的首届创业计划大赛，中国大学生逐渐成规模地亮相在创业舞台。第二阶段是高热期从2000到2002年，这一时期以清华大学为代表的高校创业大赛、团中央举办的挑战杯大学生创业计划大赛、中关村2000等省、市级创业计划大赛及网易等网络公司举办的创业计划大赛越来越多。除较大规模的创业大赛以外。在北京、上海、南京、武汉、西安、成都等地，还是逐步形成了一批依托于理工科大学建立的创业中心。2000年1月，教育部公布了一项有关大学生、研究生可以休学保留学籍，创办高校技术企业的政策。此举为正在涌动的大学生创业浪潮推波助澜，大学生创业新公司如雨后春笋般的竞相出现。到2002年，通过挑战杯竞赛产生的大学生创业公司达到百余家。第三个时期是理性期。2002年以后，在1999到2001年期间，大学生创业的公司经过一段时间的发展以后，倒闭率达到了85%以上。前期大学生自主创业公司大多面临难以维系的局面。大学生创业也逐步冷却，并开始冷静地反思与分析。伴随着理性的分析与思考，大学生创业的作用和意义，反而逐渐被社会各界所认同。国家和各地政府纷纷出台了一系列的政策和法规，鼓励大学生从事创业活动，高校也越来越重视对大学生的创业教育。&#8195;&#8195;二、我国大学生创业教育的概况。&#8195;&#8195;首先我们来看一下我国大学生创业教育的进程。我国的创业教育大致分为两个阶段。&#8195;&#8195;第一个阶段是高校创业教育自主探索期是从1997到2002年。在这一阶段中，许多高校都做出了有意义的自发的探索。1997年，清华大学学生发起。第一届的清华大学创业计划大赛，在比赛期间，学校组织了各种相关的讲座和培训，对于普及创业知识起到了良好的作用。1998年，清华大学在国内管理学院当中，率先为MBA开设了“创新与创业管理方向”这个方向的课程，其中包括了8门课程，即创业管理、创业投资、创新产品的开发、项目管理、企业家精神与创新、技术创新管理、知识产权管理、技术创新与制度创新。同时还与全校本科生开设了高新技术创业管理的课程。紧随其后的是国内一些著名的高校，也陆续开设了创业方面的课程。比如复旦大学将创业教育融入到教学中，让学生获得创业的基础知识和基本技能，并设立了专项基金，支持学生参加社会实践和科技创新活动，对有志于创业的学生还提供专门的指导。华东师范大学尝试开设了创业教育课。武汉大学则是通过实施 “三创”教育，即创造、创新、创业教育，来提高教学质量，培养创业人才。北京航空航天大学在用创业解决部分就业问题方面做了一些有益的探索与尝试，比如在学生创业方面，校产管理部门、北航科技园、北航科技化器等机构对学生创业给予了资金支助，并帮助解决注册难、筹资难等问题。1999年，由共青团中央、中国科协、全国学联举办、清华大学承办的首届“挑战杯”中国大学生创业计划竞赛在北京成功举办，汇集了全国120多所高校近400件作。大赛的举办使创业热障从清华园向全国扩散，在全国高校掀起了一轮新的创新创业的热潮，孕育了视美乐、易得方舟等一批高科技公司，产生了良好的社会影响。从此团中央开始每年组织全国性的大学生创业计划和课外学术科技作品竞赛，迄今为止已经举办了六届全国大学生“挑战杯”创业计划大赛，一些参赛团队脱颖而出，有的创建了企业，个别的甚至吸引到了创业投资，加速了学术产业化的进程。目前大学生创业计划大赛已经成为全国大学创业教育当中的重要活动，与创业教育课程新城了良好的互补。&#8195;&#8195;第二阶段是高校创业教育初步发展阶段，是从2002年起至今。2002年，为了响应由联合国教科文组织在面向21世纪教育国际研讨会上提出的“创业教育”的理念和“要求把创业能力提高到与学术性和职业教育同等地位”的号召，我国高校逐步开始实行系统的创业教育。2002年4月，教育部确定了9所创业教育试点高校，它们是中国人民大学、清华大学、北京航空航天大学、黑龙江大学、上海交通大学、南京经济学院即现在的南京财经大学、武汉大学、西安交通大学和西北工业大学。这标志着我国创业教育进入了政府引导、高校落实、市场参与的多元发展阶段。各个试点高校开始了各具特色的创业教育探索。比如中国人民大学强调将第一课堂和第二课堂相结合起来，开展创业教育，开设企业家精神、风险投资、企业管理等创业教育课程。北京航空航天大学有专门从事创业教育研究与实践探讨的教师，以及专门的机构叫创业管理培训学院。上海交通大学以“三个基点”即素质教育、终身教育和创业教育，和 “三个转变”即专才向通才转变、教学向教育转变、传授向学习转变，为指导思想，确立了创新人才培养体系的基本框架和内容。2003年的10到11月，教育部首期的创业教育骨干教师培训班，在北京航空航天大学举办，来自全国105所高校的180位教师参加了培训。这是国内第一次有组织地对创业教育教师进行系统的培训。&#8195;&#8195;二十多年来，我国创业教育取得了一定的成绩。&#8195;&#8195;首先，很多高校积极、努力地从精神、制度、行为等方面营造校园创业氛围，不仅编写创业的教材，开设创业相关课程，通过系统教学向学生介绍市场动态、融资、法律等知识，培养学生思维的灵活性、独创性，帮助学生树立自信、自强、自立的创业心态，还定期的举办大学生创业竞赛，积极建立创业扶持体系，创建园区，建立大学生创业奖励机制，鼓励大学生进行自主创业生涯规划，为学生的自主创业开辟道路，并给予奖励。&#8195;&#8195;其次，高校重视对大学生开展创业意识和创业观念教育，帮助大学生改变传统的就业观念，树立正确的创业观。&#8195;&#8195;第三，各高校加强对大学生系统的创业教育和指导，通过创业课程宣传报告和讲座等形式，为大学生提供正规和有效的创业教育和创业培训，提供及时、有效、准确的创业信息，为大学生的创业和创业企业接触提供锻炼的机会，为大学生提供社会实践的机会，开展多种多样的模拟创业，实践考察公司企业的运作，进行丰富的案例教学，针对创业意向，进行个性化的辅导和开业跟踪扶持。&#8195;&#8195;第四个方面，介绍一下我国大学生创业教育的突破口。虽然我国的创业教育在帮助指导大学生创业活动方面起到了良好的作用，但是和国外相比还有很大的差距，需要寻找不断完善的现行的创业教育的突破口。首先，我们应该转变对创业教育的社会认知。在我国对创业教育的认识上还存在着误解。最典型的表现就是认为高校创业教育的目的是使在校学生成为大大小小的 “老板”，创业教育成果是大大小小的“学生创业公司”。实际上，创业教育的首要目标是培养学生的创业意识和创业精神，要引导大学生转变择业观念，增强他们的自主创业意识。第二是要建立科学的创业教育的教学和管理模式。国外成功的教育实践证明，优秀的师资力量，合理的机构设置、综合的课程体系、科学的教学方法与模式，是高校创业教育运行的保证。我国高校需要加强创业教育师资队伍的建设，优化师资配置，强化教师技能和培训，改进教学教育方法，构建综合化的课程体系。第三是要建设有利于创业的校园文化和社会氛围。良好的创业文化是实施创业教育的重要前提。只有重视、推崇创业活动，创业教育才能得以顺利得以实施。国家应该设立专门管理创业的管理机构，政府应该制定更加完善的政策机制，高校要开展丰富多彩的实践活动，在全社会营造一种推崇创业、鼓励冒险、宽容失败的宽松自由的环境。第四，要多方力量，共同推进创业教育。创业教育的实施是一个系统工程，我们要整合力量、多方配合，才能顺利地推行、有效地实施。在教育系统内部，各级领导要重视，要建立纵向的领导协调机制；联合相关部门，建立横向的协同工作机制。而在教育系统外，要建立和教育、劳动与社会保障、工商行政管理、团组织、基金管理等机构的密切联系，形成创业人才培养和学生创业者实践的支持体系，要与各种各样的企业保持密切的联系，来争取更多的风险投资和创业实践基地，解决创业教育启动资金不足、创业实践能力不强的问题。第五，要加强创业教育的理论研究，对创业教育的概念、性质、特点培养目标和培养途径，要进行全面系统的探讨，形成了一套较完整、系统的科学理论，用于指导创业教育。&#8195;&#8195;谢谢大家，我们这节课就讲到这里。  \n创新方法创新的含义&#8195;&#8195;各位同学大家好，我是南京信息工程大学信息与控制学院的孙宁。在《创新创业基础》这门课程中，由我给大家来介绍《第二章、创新思维与创新方法》。在本章节授课过程中，我将为大家介绍什么是创新，为什么要创新，怎么做创新等内容，帮助大家对创新思维与创新方法有初步的了解。希望能为您以后的创新实践活动有所启迪和帮助。&#8195;&#8195;在我们的传统文化里，关于创新的成语有很多，比如推陈出新、标新立异、革故鼎新、改天换地、独树一帜、积极进取、自强不息、万象更新、别具匠心、别具一格等等。通过字面来看，我们或多或少对创新的含义有了一定的认识。&#8195;&#8195;创新的定义是指人类为了满足自身的需要，不断扩展对客观事件及其自身认知与行为的过程和结果的活动。或具体的讲，创新是指人为了一定的目的，遵循事物发展的规律，对事物的整体或其中的某些部分进行变革，从而使其得以更新与发展的活动。《新华词典》中说，抛弃旧的，创立新的。&#8195;&#8195;创新的目的是满足人类自身的需要，比如衣、食、住、行。&#8195;&#8195;创新的主体是人类。创新的客体是客观事件，包括人类自身。&#8195;&#8195;创新的过程是不断拓展和改变对客观事件（包括人类）认知与行为的动态活动本身。&#8195;&#8195;创新的核心就是创新思维。创新的本质就是改变，向着有益于人类的方向改变。&#8195;&#8195;创新的结果有两种，一种是物质的，一种是非物质的。&#8195;&#8195;创新的特征有价值取向性：如爱因斯坦建议罗斯福制造原子弹；明确目的性：如航天事业；综合新颖性：如日本丰田概念车；高风险、高回报性：如载人飞船。&#8195;&#8195;创新的基本原理有三个。创新第一原理：创新是人脑的一种机能和属性，它与生俱来，如斯佩里的脑部功能定位说。创新的第二原理：创新是人类资深的本质属性，人人皆有。创新的第三原理：创新是可以被某种原因激活或教育培训引发了一种潜在的心理品质，潜力巨大。&#8195;&#8195;熊·彼得的创新理论：美国经济学家熊彼得（美籍奥地利人）1912年在《经济发展理论》一书中，首先提出了创新的概念。他提出了创新就是建立一种新的生产函数。&#8195;&#8195;创新的经济学解释：一、引进一种新产品或产品的新特性。二、采用一种新的生产方法。三、开辟一个新市场。四、控制原材料的一种新来源。五、实现企业的一种新组织。一、引入一种新产品或产品的新特性：比如工作人员在向观众展示一种可自由调整角度的新款显示器、CT与核磁共振成像将计算机技术与核技术应用于医学。二、产业一种新的生产方法：人类从石器到铁器；瓦特与蒸汽机，让人类从人力到畜力到蒸汽机的一个发展过程，这是蒸汽机车，现在是世界上最快的列车高铁，时速三百六十公里；电力从火电、水电、核电、风电、太阳能发电；印刷术的革命——活字排版，《梦溪笔谈》中记录毕昇发明活字板的记载，当代有王选与激光照排，也因此王选被称为当代的毕昇。三、开辟一个新市场：推销员非洲卖鞋的故事，大家可以上网自行查阅思考。四、控制原材料的一种新来源：比如我国寻找新的石油基地、从化工到煤化学到石油天然气化工、从天然的橡胶到人造橡胶、纳米材料等等，都是一种控制原材料的新来源。五、实现企业的一种新组织：比如股份制企业组织创新、零库存。熊彼得的理论给了我们很大的启示。他着重提出，创新是一种经济学的概念，特别是企业家的行为，其局限性在于仅仅是个体行为。随着时代的发展，我们把创新扩展到理论创新、制度创新、技术创新、教育创新等方面。&#8195;&#8195;下面我们来谈谈为什么要创新。一、满足我们的个人需要，解决我们的生存问题。二、生活需要，让我们的生活越来越便捷。三、企业需要，赚取更多的利润。四、国家需要，保证国土安全。五、人类需要，人类不停的进步。小结，只有创新才有好的出路。&#8195;&#8195;可是我们的学生创新思维、创新能力如何呢？下面给大家看一个报道。中国学生没有个性和创新能力被扼杀——软件公司在华机构招聘员工事件：据说西方一家著名软件公司在华机构招聘员工，在上海交大设点时，有800多人应聘；在西安交大2000多人报名，最后只取2人。参加招聘的工程师说：“现在大学生太性了，缺少个性。流水线出来了同样的产品。”&#8195;&#8195;思考我们的学生为什么缺乏个性，归根结底是我们的教育缺乏对学生创新能力的培养，或者对创新能力培养不够。看到以上的报道，大家不禁要问，我能创新吗？答案是肯定的。只要用心，人人可以创新。我们把这个问题留到下节讲解，大家可以针对这个问题提前做做功课。&#8195;&#8195;本次课的内容到这里结束了，主要给大家介绍“什么是创新”、“为什么要创新”、“我能创新吗”等内容。感谢大家的收看，我们下期再见。  \n创新思维-打破思维定势&#8195;&#8195;各位同学大家好，上节课我给大家介绍了“什么是创新”、“为什么要创新”、“我能创新吗”等内容。本讲我们将围绕“我能创新吗？”这个话题共同探讨创新思维。&#8195;&#8195;创新思维，是人类在探索未知领域过程中，能够打破常规，积极向上寻求获得新成果的思维活动。创新思维是人类思维活动的精髓。那么创新思维有什么用呢？&#8195;&#8195;思考的重要性。物理学家卢瑟福有一次问他的学生：“你今天上午准备做什么？”学生回答：“做实验。”又问：“下午呢？”答曰：“做实验。”再问：“晚上做什么？”学生又回答：“做实验。”卢瑟福遂不满的问道：“你整天都做实验，那么你用什么时间进行思考呢？”这件事情告诉人们，要很好地进行创造，必须要有专门的时间进行思考。不善于思考，就不能把学到的知识进行消化，就不能发现问题，当然就更谈不上更多的想象和创造了。爱尔兰作家萧伯纳曾说：“难得有人一年内会思考两三次以上，我则因一个星期思考一、两次而博得国际声誉。”由此可知，思考了重要作用。&#8195;&#8195;下面我们举例进行热身练习：有6只杯子一字排在桌上前3只杯中盛水，后3只是空杯。问至少需要移动几次，使得任何相邻两只杯子必为一只空杯、一直为盛水杯。我们把六只杯子分别进行标号1、2、3、4、5、6，将第二杯和第五杯进行调换顺序，即得到我们想要的结果。热身练习二：如图中有一个正方形的水池，水池的四个角上，栽着四株老橡树。需要把水池扩大，使它的面积增加一倍。当然要求仍然保持正方形，而不移动老橡树的位置。您应该怎么做呢？请同学们思考。大家看虚线的位置，标出了新的正方形水池。&#8195;&#8195;中国有句老话叫做“不破不立”、“推陈出新”，要创新，必须打破创新的思维障碍、破除思维定式。&#8195;&#8195;什么叫 “思维定式”呢？思维定式就是过去的思维，影响当前的思维。&#8195;&#8195;一、习惯思维定势：人们不自觉的用某种习惯的思维方式去思考已经变化的问题。后面留一个练习：请大家把一张很大很大的正方形纸反复对折50次，厚度是多少？竹禅和尚巧画佛像：有一年竹禅和尚云游北京，被召到宫里去作画。那时宫里画家很多，各有所长。一天一名宦官向画家宣布：“这里有一张五尺宣纸，慈禧太后要画一幅九尺高的观世音菩萨像。谁来接旨？” 画家中无一人敢应命。因为五尺纸怎么能画九尺高的佛像呢？这时竹禅想一想就说：“我来接。”说完他研墨展纸，一挥而就。大家一看，无不惊奇叹绝，心悦诚服。此画传到了慈禧手中，慈禧也连连称奇，甚至表示自愿“受法出家”，并让竹禅和尚担任 “承保人”。据说后来慈禧被称为“老佛爷”，就是由此开始的。试问竹禅和尚是怎样画的呢？竹禅画的观音和大家常话没有多大差异，只是把观音化成了弯腰在拾净水瓶中的柳枝，如果观音直起腰来，则正合九尺。&#8195;&#8195;二、权威思维定势：指人们对权威人士的言行的一种不自觉的认同或盲从。例如穆勒的权威暗示实验，参加的学生有100名。权威暗示效应：一化学家称，他将测验一瓶臭气的传播速度，他打开瓶盖15秒后，前排学生即举手称自己闻到了臭味，而后排的人则陆续举手，纷纷称自己也闻到了，其实瓶中什么也没有。第二个例子：亚里士多德物体下落理论延续了100多年，说过重的物体从高处下落的速度比轻物体下落的速度快，后来被伽利略推翻了。&#8195;&#8195;三、从众思维定势：人不加思索的盲从众人的认知与行为。有趣的毛毛虫实验：法国科学家约翰·法伯做的实验，将毛毛虫围成一圈，第一只毛毛虫跟着了另外一只毛毛虫的尾巴，一直不停的爬行，最后活活累死。由这个故事我们想到，其实在我们的生活中也存在着大量这样的毛毛虫，他们只会跟着人家走，没有自己的思想与见解，人云亦云。不加思索的盲从众人的认知与行为，这是从众型的思维障碍。&#8195;&#8195;四、书本思维定势：人类书本知识的完全认同与盲从。比如中国的应试教育。美籍华人物理学家吴健雄曾说过：“美国的家长问孩子：‘今天又想教授提了几个问题？’中国的家长问孩子：‘今天又得了几个A？’中国的教育是引导学生认识已知事件，而美国的教育则是引导学生探索未知的世界。”&#8195;&#8195;五、自我中心思维定势：人想问题、做事情，完全从自己的利益好恶出发，主观武断而不顾他人的存在与感受。比如有些人特别固执，思考问题时以自我为中心的心理状态。唯我独尊、刚愎自用、固执己见。历史上就有这样的例子，如关羽大意失荆州、诸葛亮挥泪斩马谡。任何人都有局限性，天才也不例外。每个人都应当有自知之明。在威斯敏斯特教堂的英国圣公会主教的墓碑上写道：“当我年轻的时候，我的想象力没有任何限制，我梦想改变整个世界。当我成熟、渐渐明智的时候，我发现这个世界是不可能改变的。于是我将目光放在短浅了些，那就是只改变我的国家吧，但我的国家似乎也是不可改变的。当我到了迟暮之年，抱着一丝努力的希望我决定是改变我的家庭、我亲近的人，但是，唉，他们根本不接受改变。现在在我临终之际，我在突然意识到，如果我只改变自己，接着我可以依次改变我的家人，然后在他们的激发和鼓励下，我也许就能改变我们的国家。再接下来谁又知道呢。也许我连整个世界都能改变。”&#8195;&#8195;思维定势告诉我们，大家会认为自己的想法是对的，总是想着改变别人却很少想的先改变自己。所以我们如何突破障碍、超越自我？突破障碍就是突破自我，进一步说就是超越自我，超越是一个很高的境界，超越自我才是创新。所谓超越，实际上也是一种思维方式。这种思维方式就是站在时代的制高点，超越时空的限制，根据对客观规律的正确认识，对事物的发展趋势进行正确的判断，从而做出科学的决策。只有超越才有创新，超越既不是拘泥于现实的墨守成规，也不是脱离实际的凭空幻想。&#8195;&#8195;突破障碍，超越自我。一、超越理论：理论是非常重要的，没有理论的实践就是盲目实践。但是任何理论都是一定实在的产物，再正确、再伟大理论也需要在实践中丰富和发展。二、超越习惯：习惯成自然。习惯一旦形成，是很难改变的，特别是思维上的习惯，让你不知不觉的就按老一套去办事。思维上的老习惯，对于创新是无形的阻力。我们实现思维创新的过程，实际上就是破除和超越习惯的过程。三、超越经验：经验是以往阅历与感性认识的积淀与凝结，无疑是很宝贵的。在总结经验的基础上实现创新，也是许多有成就的创新者的必由之路。所以我们应当善于总结自己的经验，也应当善于学习他人的经验。超越经验，实际上就是解放思想、实事求是，就是打破常规、与时俱进。四、超越自满：自满才是成功的天敌，也是创新的大敌。超越自满才能知道天外有天，强中更有强中手，才能够不断的学习，不断实践，不断创新。五、超越现实：创新思维既要立足现实，又要超越现实。我们需要一种“超前思维方式”，不能满足于“应急式”思维方式。超前思维就是超越现实的思维。有这样一句话：“改变别人难上难，调整自己最简单。”下面我们来举例，如何打破创新的思维障碍。练习：一个人用600元买了一匹马，以700元卖出去，又用800元买了回来，以900元卖出去，请问他赚了多少钱？一、不赔不赚；二、100元；三、200元。请大家自己思考。&#8195;&#8195;讲到这么多，然后你会问我有没有创造力呢？人人是创造之人，揭示出创造力，不是极少数天才所具有的特殊天赋，而是人人都具有的创造潜力。如何开发你的创新思维？我们把这个问题留到下节课。&#8195;&#8195;本次课的内容讲到这里，主要给大家介绍了创新思维的基本知识。感谢大家收看，我们下期再见。  \n创新思维&#8195;&#8195;各位同学大家好，上节课我为大家介绍了创新思维的基本知识。本讲，我们将围绕着创新思维中的发散思维、收敛思维和形象思维，进行展开。&#8195;&#8195;创新思维包括发散思维、收敛思维、形象思维、直觉思维、灵感思维和逻辑思维。&#8195;&#8195;发散思维。定义是从一个问题或信息出发，突破原有的知识圈，充分发挥想象力，经不同的途径与不同的视角去探索，重组眼前和记忆中的信息，产生新信息，使问题得到圆满解决的思维方法。&#8195;&#8195;发散思维的特征。一、流畅性：发散思维“量”的指标，流畅性衡量思维发散的速度（单位时间的量），是基础。二、变通性：发展思维“质”的指标，表现了发散思维的灵活性，是发散思维的关键。三、独创性：发散思维的本质，表现发散思维的新奇成分，是思维发散的目的。&#8195;&#8195;下面我们来了解发散思维的特征练习。一、语言流畅：请在5分钟内尽可能多的写出带有数字一至十的词汇，如一心一意等。写得最多的又无错为优胜。这个练习，请同学们课后自己练习。二、词的流畅。请尽可能多地的写出含有 “马”字的成语， “马”字分别写在一、二、三、四位。比如“马”放在第一位：马到成功；“马”字放在第二位：老马识途；“马”放在第三位：人仰马翻；“马”放在第四位：立兵木马等等。其他的成语，请同学们自己课后练习。三、图形变化的流畅，如左图16根火柴构成了5个正方形，如何移动2根火柴，使16根火柴构成4个同样大小的正方形？二、左面有8根火柴组成2个正方形，如图，如何移动4根火柴组成八个三角形，请同学们思考。这里给出了答案，你做对了吗？四、观念的流畅：尽可能多的说出帽子的用途、领带的用途、红砖的用途、乒乓球的用途、曲别针的用途。下面以红砖的用途为例。常规组合：砌墙、铺路、花坛、水池、烟囱、桥、碉堡等建筑；非常的组合：家具，如桌、椅、凳、箱、柜、体育器材、乒乓球台等艺术作品、道具。红砖的性质：坚硬、粗糙、耐热、可垫脚、登高、做防身武器、代替锤子，可以用于摩擦、砌炉灶、防火。化学性质：耐腐蚀。改变：粉碎，碎块可以铺路面，粉末可以做涂料，雕刻则可以做工艺品、玩具等。小结：同一类用途列举——流畅性；迅速转换到其他的用途——变通性；组合或改变，艺术性强——新颖性。&#8195;&#8195;三、发散思维形式。立体思维。思考问题时，跳出点线面的限制，立体式进行思维。如立体绿化：屋顶花园，增加绿化面积，减小占地，改善环境，净化空气；立体农业：间作，如玉米地种绿豆、高粱地里种花生、温室大棚；立体渔业：网箱养鱼，充分利用水面水体；立体开发资源：如煤、石头、开发产品等等。你还能想到什么样的立体思维呢？发散思维的第二种形式：逆向思维。背逆通常的思考方法，从相反方向思考问题的方法，也叫反向思维。因为客观世界上许多事物之间，甲能产生乙，乙也能产生甲。如化学能能产生电能，据此意大利科学家伏特1800年发明了伏打电池；反过来，电能也能产生化学能，通过电解，英国化学家戴维1807年发现了钾、钠、钙、镁、锶、钡、硼等七种元素。例如说话声音高低能引起金属片相应的振动，相反金属面的振动也能引起声音高低的变化。爱迪生在对电话的改进中，发明制造了世界第一台留声机，如图，开启了人类记录声音的历史。如何进行逆向思维？一、就事物依存的条件，逆向思考。如小孩掉进缸里，把人从水中救起，是使人脱离水，司马光救人就是打破缸，使人脱离水。二、就事物发展的过程逆向思考。如人上楼梯是人走路，而电梯是路走，人不动。三、就事物的位置面向思考。如开展“假如我是某某”的活动。四、就事物的因果关系逆向思考。如磁场产生电，电场产生磁。在商业营销运作中，也常用逆向思维的应用。如做钟表生意的都喜欢说自己的表准，而一个表厂却说他们的表不够准，每天会有一秒的误差，不但没有失去客户，反而大家非常认可，踊跃购买。发散思维方式三、横向思维。向思维主体两侧展开思维方式。如做计划生育工作（多养猪，少生娃）。发散思维方式四、颠倒思维。指思维主体发生置换的思维方式。例如郭冬临演的小品《父与子》，父子互教。&#8195;&#8195;创新思维的第二种、收敛思维。收敛思维就是集中、求同、聚敛。定义是人为了解决某一问题而调动已有的知识、经验和条件去寻找唯一的答案。说明几个问题：一、只注意收敛思维不利于创新；二、收敛思维要在发散思维的基础上运用；三、二者并用才能完成创新活动。&#8195;&#8195;收敛思维的特征。一、集中性：收敛思维就是针对一个集中的目标，将发散了的思维集中指向这个目标，通过比较、筛选、组合、论证得到解决问题的答案。二、程序性：因为收敛思维有明确的目标，因此利用现有的信息和线索解决问题，就必须有一定的程序，先做什么，后做什么都有一定的步骤。三、比较性：尽管收敛思维有一定的目标，但毕竟还有多种路径和方法，因此要在其中进行比较选择，最后以达到目标与其归宿。四、最佳性：收敛思维解决问题，需要寻求最佳方案和最佳结果。&#8195;&#8195;收敛思维的形式。一、目标确定法。这个方法要求我们首先要正确的确定搜寻的目标，进行认真的观察并做出判断，找出其中关键的现象，围绕目标进行收敛思维。例一、一战时，德法交战，德国依据猫判断法司令部的所在地。例二、商船架高射炮的例子。二、求同思维法。如果有一种现象，在不同的场合反复发生，而在各种场合，只有一个条件是相同的，那么这个条件就是这种现象的原因。寻找真的条件的思维方法，就叫求同思维法。例如某山区牧羊人发现怪洞，小动物死而大动物生。三、求异思维法。如一种现象在第一场合出现，在第二场合不出现，而在这两个场合中，只有一个条件不同，这个条件就是现象原因。寻找这一条件，就叫求异思维法。聚焦法。聚焦法就是围绕问题进行反复思考，使原有的思维浓缩、聚拢，形成思维的纵向深度和强大的穿透力。在解决问题的特定指向上思考，积累一定量的努力，最终达到质的飞跃，顺利解决问题。如隐形飞机的制造是难度比较大的问题，它是一个多目标聚焦的结果。五、分析综合法（见后面的逻辑思维）。案例分析：下面是金、银、铅三个盒子，其中一个盒子里有宝石。每个盒子外面贴一句话，但其中只有一句话是真话，请你找出盛宝石的盒子。为什么？金盒子上贴了：“宝石在这个金盒子里。”银盒子上贴一句话，说：“宝石不在这个银盒子里。”铅盒上贴一句话：“宝石不在金盒子里。”请大家根据以上的提示来进行分析。&#8195;&#8195;发散思维与收敛思维的关系。二者要保持适当的张力，发散要充分，不充分就匆忙结束，就可能挂一漏万。但也不能没有止境，一味发散，不及时收敛，就没有思维的效率。&#8195;&#8195;创新思维三、形象思维。形象思维的定义：形象思维是凭借事物的表象，运用想象，进行的多回路、多途径的思维。表象：有感觉、认知而形成了记忆形象，往往是一个个画面。&#8195;&#8195;形式、想象思维。定义：把大脑中的记忆表象进行加工、改造、重组，形成新的表象的思维过程。它的特征是形象性、概括性、超越性。想象在创新思维中起着主导、主干作用。爱因斯坦说：“想象比知识更重要，因为知识是有限的，而想象力概括着世界上的一切，推动着进步，并且是知识进化的源泉。严格的说，想象力是科学研究中的实在因素。”著名物理学家普朗克说：“每一种假设都是想象力发挥作用的产物。”列宁（第一个社会主义国家的缔造者）曾说过：“有人认为只有诗人才需要幻想，这是没有道理的。……甚至数学也需要幻想的，……没有它就不可能发明微积分。”想象思维的类型。一、无意想象。二、有意想象。无意想象是没有特定的目的，不需做意志努力的想象。有意想象是受主题意识支配的，还需要做一定意志努力的想象。那么如何发挥自己的想象力呢？德国的一名学者曾经说过这样的话：“眺望风景，仰望天空，观察云彩，常常坐着或躺着什么事情也不做，只是静下来思考，让幻想力毫无拘束的奔驰才会有冲动。否则任何工作都会失去目标，变得繁琐空洞。谁若每天不给自己一点做梦的机会，那颗引领他工作和生活的明星就会黯淡下来。”&#8195;&#8195;二、联想思维。定义：在创新过程中，运用概念的语义、属性的衍生、意义的相似性，来激发创新思维的方法。它是打开沉睡在头脑深入记忆的最简便、最适合的钥匙。特征：具有连续性、概括性、形象性。类型：一、接近联想。时间和空间上相互接近的事物，形成了联想。科学发现的例子：门捷列夫发现元素周期表对未知元素的位置的判断；卢瑟福研究原子核时提出质量与质子相同的中性粒子的存在。诗歌中时空接近联想的佳句有很多：“春江潮水连海平，海上明月共潮生。滟滟随波千万里，何处春江无月明。”春江、潮水、大海与明月（既相远又相近）联系一起。相似联想。性质或形式上相似的事物间所形成的联想。如“春蚕到死丝方尽，蜡烛成灰泪始干”、“床前明月光，疑是地上霜”等等，以及响尾蛇导弹。三、对比联想。相反特征的事物或相互对立的事物间所形成的联想。文学艺术的反衬手法，就是对比联想的具体运用。比如描写岳飞和秦桧的诗句：“青山有幸埋忠骨，白铁无辜铸佞臣。”这里面就用到了色彩对比、大小对比、强度对比、方向对比和好坏对比。四、因果联想。从某一事物的出现某些现象，从而联想到他们的因果关系的思维方法。如由因到果，或者由果到因。比如我们发现火灾就会想到报警。由结果想到原因，比如事故，然后我们会考虑事故的原因是什么；出现异常现象，我们会考虑到是否是地震的前兆等等。五、类比联想。类比法就是通过对一种事物与另一种事物对比而进行创新的方法。其特点是以大量联想为基础，以不同事物间的相同类比为纽带，根据不同的类比形式可以分为多种类比法。如直接类比法：鱼骨到针、酒瓶到潜水艇等等。&#8195;&#8195;三、形象思维训练。闭上眼睛，做下列想象（清晰性练习，想象的形象越清晰越好）。大家闭上眼睛，想象一匹正在飞奔的马：一匹马开始奔跑——越跑越快——蹄下尘土飞扬——风驰电掣——开始减慢速度——小跑——越来越慢——原地踏步——停下来。&#8195;&#8195;人的大脑有一个重要功能，就是凭借视觉想象力进行思考。也就是说，人在思考时能够根据需要在人脑中构造出某种图形或抽象概念、感性外观的视觉想象。人的大脑就像长在眼睛，这些视觉想象物能移动、旋转、变化，并且被分析。&#8195;&#8195;本次课的内容就讲到这里，主要给大家介绍创业思维中的发散思维、收敛思维、形象思维等相关知识。感谢大家的收看，下期我们再见。  \n创新思维-直觉思维&#8195;&#8195;各位同学大家好，上节课我为大家介绍了发散思维、收敛思维和形象思维的相关知识。本讲，我们继续探讨直觉思维、灵感思维和逻辑思维。&#8195;&#8195;直觉思维。定义：人脑对于突然出现在其面前的新事物及其判断。例如达尔文直觉向日葵背后肯定有可怕的物质，X射线由此诞生；居里夫人发现，元素镭的经过都是靠直觉：居里夫人，法国籍波兰科学家研究放射性现象，发现镭和钋两种放射性元素，一生两度获诺贝尔奖。科学发现和科技发明是人类最客观最严谨的活动之一。但是许多科学家还认为，直觉是发现和发明的源泉。诺贝尔奖获得者、著名物理学家玻恩说：“实验物理的全部伟大发现，都是来源于一些人的直觉。”美国化学家普拉特和贝克曾对许多化学家进行填表调查。在收回的232张调查表中，有33%的人说，在解决重大问题时有直觉出现。有50%的人说偶尔有直觉出现，只有17%的人说没有这种现象。&#8195;&#8195;直觉思维的特征。一、直观性：直觉是对具体对象的直观，从整体上把握对象。没有直观的对象是难以产生直觉的。它既不同于灵感，也不同于罗辑思维。二、豁然性与快速性：直觉凭以往的经验、知识，直接对猜度问题的精要。是用敏捷的观察力、迅速的判断力，对问题做出试探性的回答，结论不一定十分可靠，必须在用经验思维、理论思维进一步证明。三、跳跃性：直觉产生的形式是突发的和跳跃式的。直觉思维的出现是在大脑的功能处于最佳状态的时候。&#8195;&#8195;直觉思维类型。一、艺术直觉：艺术家在创作过程中，有某一个形象一下子上升到典型形象的思维过程。二、科学直觉：科学家在科学研究过程中，对新出现的某一事物非常敏感，一下就意识到其本质和规律的思维过程。&#8195;&#8195;训练。怎样培养直觉能力？一、要有广博而坚实的基础知识。直觉判断不是凭主观意愿，而是凭知识和规律。二、要有丰富的生活经验。产生直觉仅凭书本知识是不够的，直觉思维迅速、灵活、机智，需要有较多的经历，经历过困难解决过各种复杂的问题。三、要有敏锐的观察力。要有审查全面的能力，较快地看清全貌。然后是直觉测验。这部分内容由同学们课后自己测验。&#8195;&#8195;创新思维第五部分、敏感思维。定义：人在不知不觉中突然发生的特殊思维形式。在人类历史上，许多重大的科学发现、杰出的文艺创作往往是灵感这种智慧之花闪现的结果。灵感与创新可以说是休戚相关的。灵感不是神秘莫测的，也不是心血来潮，而是人在思维过程中，带有突发性的思维形式长期积累艰苦探索的一种必然性和偶然性的统一。如美国福斯贝里的背跃式跳高的产生、阿基米德解决金黄冠之谜的故事等。&#8195;&#8195;灵感的特点。灵感具有通常思维活动所不具有的特殊性质，主要有以下几点。一、突发性：灵感的出现不期而至，突如其来，灵感什么时候出现、怎样出现、由什么事物刺激而产生，这都是难以预先知道的。二、兴奋性：灵感的兴奋性是指处于兴奋中，它使人脑处于激发状态，伴随而来的是情绪的高涨，使人进入如痴如醉的忘我状态。三、跳跃性：灵感的跳跃表现为它是一种直觉的非逻辑的思维过程。它出其不意的刹那间（如散步、闲谈、看电影等）触景生情，冥思苦想的问题突然得到解决。原因是创造者在创造活动中，对问题长期的探索使创造者的智力活动达到白热化状态。在这种状态下，或因外界的某一刺激而受到启发。或由于某种联想触类旁通，使创造者的记忆存储的材料重新组合。四、创造性：灵感所获得的成果，常常是新颖的、创造性的知识。它所闪现的往往是模糊、粗糙、零碎的，还要用通常的思维活动加以整理。所以灵感的创造性与抽象思维、形象思维以及其他种种因素在一起，才能发挥作用。&#8195;&#8195;灵感思维的训练。一、灵感的捕获。①长期的思想活动准备。灵感是人脑进行创作活动的产物，长期思考是基本条件。②兴趣和知识的准备。广泛的兴趣、丰富的知识经验有利于借鉴，容易得到启示，是捕捉灵感的另一个基本条件。③智力的准备。主要包括观察、联想、想象。④乐观镇定的情绪。愉快的情绪，能够增强大脑的感受能力。⑤注意摆脱习惯性思维的束缚。⑥珍惜最佳时机和环境。⑦要有及时抓住灵感的精神准备和及时记录下灵感的物质准备。许多有创造性精神的人，都曾体验过获得灵感的滋味。但因为事先没有准备，而没有及时进下来这些灵感，事过境迁就再也记不起来了，但记录下来以后在慢慢琢磨，决定取舍。二、灵感的诱发。（1）通过外部机遇诱发。①思想点化。一般在阅读或交流中发生。如达尔文从马尔萨斯人口论中读到“繁殖过盛而引起的竞争生存时”，大脑里突然想到在生存竞争条件下，有利的变异会得到保存，不利的变异则会被淘汰。由此促进了生物进化论的思考。这就是思想点化。②原型启发。这是根据自己要研究对象的模型启发而产生的灵感。例如英国工人哈格里沃斯发明纺纱机的经过，就是受到原来水平放置的纺车偶然被他踢翻变成垂直状态的启发才研制成功的。③形象发现。如意大利文艺复兴时期的著名画家拉斐尔，想构思一副新的圣母像，但很久难以成形。在一次偶然的散步中，看到一位健康、淳朴、美丽、温柔的姑娘在花丛中捡花，这一富有魅力的形象吸引了他，他立刻拿起画笔，创作了《花园中的圣母》，以及后来的《大公爵圣母》和《西斯廷圣母》。④情景激发。我国作家柳青经过农村生活的体验，写出了《创业史》。但七年后，当他想改写时却找不到感觉。只能又回到长安县后，那些农民的言语、感情以及对农村生活的冲动，才一起被激活，产生了创作灵感。（2）灵感思维通过内部积淀意识引发。①无意遐想。这种遐想式的灵感在创造中也很常见的。②潜意识。这种灵感的诱发情况更为复杂，有的是潜意识的闪现，有的是潜能激发，有的是创造性梦境活动，有的是下意识的信息处理活动。如潜知的闪现、潜能的激发（这就是我们通常所说的急中生智。这种灵感现象是人脑中平时未发挥作用的那部分潜能在危机状态下突然激发。）、创造性的梦境活动。&#8195;&#8195;下面我们来讲，创新思维中第六个、逻辑思维部分。逻辑思维的定义：人脑对客观事物抽象地、概括地反映。逻辑的形式：如概念、判断、推理。逻辑结构：如三段论。&#8195;&#8195;二、逻辑思维的一般作用：帮助我们正确的认识客观世界，解决常规问题，表达思想。&#8195;&#8195;三、逻辑思维与创新思维的关系。逻辑思维渗透于一切创造过程中。逻辑思维的过程形式与创新、创造过程密切相关，一切创造活动都是以罗辑思维为基础，运用逻辑思维，对创造成果条理化、系统化、理论化。创新活动需要运用逻辑思维的各种形式（如形式、辩论）。运用得好本身就可以创新。下面举例。伽利略推翻亚里士多德的物体下落速度与其重量成正比的错误结论就是很好的例证。下面开始证明。因为A和B两个的重量大于A的重量，所以A和B两个的速度大于A的速度，但是因为A的速度快、B的速度慢，把A和B绑在一起的速度肯定比A的速度慢，显然与证明的结论相违背。所以亚里士多德“物体下落速度与其重量成正比”是错误的。&#8195;&#8195;四、逻辑思维的方法。一、分析与综合是逻辑思维与辩证逻辑共同研究的方法。二、分类与比较。三、归纳与演绎。四、抽象与概括。五、系统化与具体化。一、分析与综合。分析是在思维中把对象分解为各个部分或因素，分别加以考虑的逻辑方法；综合是在思维中把对象的各个部分或因素结合成为一个统一体加以考察的逻辑方法。分析与综合是思维方向相反的过程。举例，桌上摆放着三张卡片，变换它们的位置使其成为能被43整除的三位数，该如何变？分析每张卡片的特性。二、分类与比较。分类，就是根据事物的共同性与差异性，就可以把事物分类，具有相同属性的事物归为一类，具有不同属性的事物归为不同类；比较，就是比较两个或两类事物的共同点和差异点，通过比较就能更好的认识事物的本质。分类是比较的后继过程，重要的是分类标准的选择，选择的好还可以导致重要规律的发现。三、归纳与演绎。归纳是从个别性的前提推出一般性的结论，前提与结论之间的联系是偶然性的；演绎是从一般性的前提推出个别性的结论，前提与结论之间的联系是必然性。四、抽象与概括。抽象就是运用思维的力量，从对象中抽取它的本质的属性，抛开其他非本质的东西；概括是在思维中，从单独对象的属性中推广到这一类事物的全体的思维方法。抽象与概括和分析综合一样，也是相互联系不可分割的。五、系统化与具体化。&#8195;&#8195;下面进行逻辑思维训练。举例，在8个同样大小的杯中，有7杯盛的是凉开水，1杯盛的是白糖水。你能否只剩3次就找出盛白糖水的杯子来？下面同学们进行思考。下面给大家分析。首先，把每个杯子进行标记1、2、3、4、5、6、7、8。把2、3、4的水倒入于1里，尝一下，如果甜，糖水就在1、2、3、4。第二步，把2倒入3尝一下。如果不甜，就是在1或4，再尝4就可以了。如果甜，再尝2，如果甜，就是2；如果不甜，就是3。第三步，现在假设1、2、3、4不甜，肯定在5、6、7、8中，还有两次机会。我们把6倒入5中尝一下，如果甜，尝一下6就知道是在5中还是6中。第四步，如果5、6不甜，就在7、8中，我们任意尝试7或者8，就可以知道是7还是8了。&#8195;&#8195;逻辑思维可以直接创新。只注重逻辑思维，不注重非逻辑思维会阻碍创新。在创新活动中，逻辑思维要和非逻辑思维交替使用。逻辑思维有重要作用。逻辑思维的更高层次是辩证思维，包括系统思维。下面有测试是与实训。课后同学们自己练习。&#8195;&#8195;每个人都具有创新能力，请坚持：用熟悉的眼光看熟悉的事物——不放过任何细节；用陌生的眼光看熟悉的事物——发现问题；用熟悉的眼光看陌生的事物——进行类比、联想；用陌生的眼光看陌生的事物——探索、深思。&#8195;&#8195;本次课的内容到这里就结束了。主要要给大家介绍了直觉思维、灵感思维和逻辑思维的相关知识。感谢大家的收看，下期我们再见。  \n创新方法&#8195;&#8195;各位同学大家好。上节课我跟大家介绍了创新思维。本节课，我们继续共同探讨创新方法。&#8195;&#8195;笛卡尔说：“人类历史上最有价值的知识是方法的知识。”著名数学家庞加莱说：“科学发明需要创造方法。”传统的创新方法分类，我们主要从主要思维形式、方法原理、具体方法名称这三个方面进行分类。主要思维形式包括逻辑思维和非逻辑思维。方法原理：逻辑思维包括科学推理型、组合型、有序思维型；非逻辑思维包括联想型、形象思维型、列举型；具体方法名称如右图所示。&#8195;&#8195;在这里，我们重点讲有序思维型里面的5W2H法和联想型里面的智力激励法，又叫头脑风暴法。由于创新方法种类较多，本节课程将主要介绍逻辑思维方法中的5W2H法和非逻辑思维方法中的智力激励法，即头脑风暴法。&#8195;&#8195;首先，5W2H是什么。5W2H法是第二次世界大战中美国陆军兵器修理部首创的，简单、方便、利于理解使用、富有启发意义，广泛用于企业管理和技术活动，对于决策和执行性的活动也非常有帮助，也有助于弥补考虑问题的疏漏。5W2H的英文翻译：一、Why：说明为什么需要创新。二、What：指出创新的对象是什么。三、Where：从什么地方着手。四、Who：谁来承担创新任务。五、When：什么时候完成。六、How：怎样实施。七、How much：达到怎样的水平。&#8195;&#8195;第一个，为什么：我们思考问题可以考虑为什么会发光、为什么漆成红色、为什么要做成这个形状、为什么不用机械代替人力、为什么产品制造的环节这么多、为什么要这么做；做什么：做一件事情的时候考虑条件是什么、目的是什么、重点是什么、功能是什么、规范是什么、要素是什么等等；谁：思考谁来办合适、谁能做、谁不宜加入、谁是顾客、谁支持、谁来决策、忽略了谁等等；何时：思考何时完成、何时安装、何时销售、何时产量最高、何时最切时宜、需要几天为合适；何地：思考何地最适宜种植、何处才最经济、从何处去买、卖到什么地方、安装在哪里最恰当、何地有资源；怎样：怎样做最省力、怎样做最快、怎样效率最高、怎样改进、怎样避免失败、怎样求发展、怎样扩大销路、怎样改善外观、怎么样方便使用。对于最后一问How，有时也可以拓展成两个问题：How to是怎么样、How much是多少。对于How much：思考功能如何、效果如何、利弊如何、安全性如何、销售额如何、成本多少等等。&#8195;&#8195;5W2H法的应用：例如社区治安根本好转有无可能。沈阳市某住宅小区社会治安不好，入室盗窃案一直居高不下。物业管理委员会主任。因为5W2H法使本地区社会治安得到了根本好转。经分析，发现问题出在三个方面。一、何人。根据以往做的脚印、指纹分析，是几个团伙作案，初步判断是外地流窜于本市的无业游民组成了盗窃团伙。二、何时。基本上借着夜色、三更半夜从窗户的铁丝防护网为攀登物，再进入厨房窗、厕所窗入室盗窃。窃贼有明确的分工，有望风的、有专门转移巡逻人视线的、有传递赃物的。三、如何。①由于住宅区四面全有出入口，现在改为半封闭式管理。②专业保安与“业余”保安相结合，青年、报警器在窃贼必经的出入口安装。③一旦有事，区内亮起强光。④装上电子眼予以监控。三个月内破获了三个盗窃团伙，半年后入室盗窃绝迹。案例二、某商店改变生意清淡的方法。我们将5W2H进行排序。提问项目：为什么；提问内容：在此处设这个店行不行；情况原因是有需求；改变措施是应保留。做什么；提问问题：批发还是零售、百货还是专营、做不做维修服务；情况分析：本处适合零售；改进措施是零售为主、增加服务项目。提问项目：何地；店设何处、离车站近、还是离居民区近；情况原因是为旅客服务；改进措施：增加旅客上车前后所需的商品。何时；提问内容是何时购物、旅客如何寄存行李；情况分析：无处寄存；改进措施：办理托运，特别是晚上。提问项目：何人；谁是顾客，旅客还是居民；情况分析：未把旅客当做主要顾客；改进措施是增加为旅客服务的项目。提问项目是怎样；请问内容是怎么样招来更多的旅客；情况分析是此店不醒目；改进措施是①增加路标②增加购物指示牌。提问项目：多少；提问内容是改进需要投入多少、能得到多少效益；情况说明：本店有投资能力；改进措施是装修扩大需要1.5万，预计增长20%。以下的四个思考题，请同学们课后尝试处理。&#8195;&#8195;下面我们讲智力激励法，也叫集智类的方法。这是根据某种技术需求，设立一个特定的技术论题，聘请十个左右对所设定的技术议题有独特的见解的专家进行讨论。席间可以畅所欲言、各抒己见，使与会者相互启发，取长补短，思想共鸣，从而引起创造性的思想的连锁反应，产生许多新颖的设想和方法，最后由决策者进行综合和选择的一种创新方法。这种方法是由美国学者、创造工程的奠基人奥斯本在20世纪30年代创立的，后经过一些科学技术学家的丰富和发展，形成了一种具有一定规则的方法。其主要规则有：在思想形成阶段不允许批评别人提出的设想，以防节外生枝、转化论题；提倡无拘束的自由思考，无论多富于幻想的怪诞意见都需要记录在案；尽量多提设想，多多益善，会上不做任何结论；鼓励把各种设想结合起来，并加以引申和发展。由于这种方法创造了健康的自由讨论氛围，与会者思想自由、奔放，相互激励，往往一次会议就可以提出上百个方案。所以这种方法有时也称为“智裹团法”或“头脑风暴发法”。&#8195;&#8195;现代科学技术发展史表明：一项技术革新或科技成果，大都有一个创造性的设想，一般来说，创造性设想越多，发明也越容易获得成功。那么怎样才能获得大量的创造性的设想呢？中国有句俗话叫做“集思广益”，在创造活动中。应用集思广益的例子是屡见不鲜的。例如日本三菱树脂公司随着生产的发展，急需沿着一种新型净化池，公司领导召集了11名技术人员，在短短的半年里就提出了70种方案，并从中选择了10个最优秀的方案，然后根据10种最优方案设计的净化池的结构，画成图纸，贴在黑板上，再将个人对新方案提出了改进设想写在纸条上，贴在净化池结构图的相应位置。通过公司内部科技人员的评审，最后得出了一种研制新型净化池的最佳方案。由此可见，集思广益是一种有效的创作方法。创造学家在此基础上创造了一种科学的开发创造性设想的创造方法——智力激励法。&#8195;&#8195;奥斯本智力激励法：智力激励法是世界上最早付诸实用的创造方法。它由美国创造学家奥斯本首先提出，以后各国创造学家又作发展，先后提出了默写式智力激励法、卡片智力激励法，三菱式智力激励法等。奥斯本智力激励法采用这种方法，一般通过一种特殊的会议，使参加的人员相互启发，填补知识空隙，从而引起创造性的设想的连锁反应，产生众多的创造性设想。智力激励会议的具体组织方法是：参加会议的人数不超过10个，会议的时间掌握在20分钟至1小时之间，每次会议目标要明确，到会人员围绕议题可以任意发表自己的想法。为了使会议参与者都充分表达和发挥自己的设想，还必须做以下几项规定：一、绝不允许批评别人提出的设想；二、提倡任意自由的思考；三、任何人不能做判断性的结论；四、提出的设想越多越好；五、集中注意力，针对目标；六、参加会议的人员不分上下级，平等相待；七、不允许私下交谈，以免干扰别人的思维活动；八、不允许用集体提出的意见来阻碍个人创造性的思维；九、各种设想不分好坏，一律记录下来。在智力激励会议上，每个人都可以充分利用别人的设想，来激发自己的灵感，或者结合几个人的设想，产生新的设想。所以要比单独思考更容易得到数量众多、有价值的设计。一般说来，讨论一个小时可以产生十至几百个设想。智力激励法的应用非常广泛，不仅可以用于创造发明，而且可以用于企业管理。&#8195;&#8195;635法模式：每个会议请6个人参加，每人在卡片上默写3个设想，每轮历时5分钟。一、会议的准备：选择会议组织者，确定会议的议题，并要求6名与会者参加。二、进行轮番性默写激励：主持人宣布议题（创造目标）并对与会者提出的质疑解释后，便可开始默写激智。组织者给每个人发几张卡片，每张卡片上标着1、2、3号，在每两个设想之间留出一定的空隙，好让其他人在填写新设想在。第一个5分钟内，要求每个人针对议题，在卡片上填写3个设想。然后将设想卡传递给右邻的与会者。在第二个5分钟内，要求每个人参考他人的思想后，再在卡片上填写3个新的设想，这些设想可以是对自己原设想的修正和补充，也可以对他人设想的完善，还允许将几种设想进行取长补短式的综合。填写好后再右转给他人。这样半小时内传第5次可产生108条设想。三、筛选有价值的新设想：将各种设想进行分类整理，根据一定的评判准则，筛选出有价值的设想。&#8195;&#8195;默写式智力激励法：奥斯本的智力激励法传入西德之后，西德的创造学家荷立根据德意志民族的习惯——沉思的性格，进行改良，创造了一种默写式智力激励法。默写式智力激励法规定：每次会议有6个人参加，每人在5分钟内提出3个设想，所以它又称“635法”。默写式智力激励法，可以避免出现由于数人争着发言而使设想遗漏的情况。&#8195;&#8195;卡片式智力激励法：卡片式激励法，这种方法又可分为CBS法和NBS法两种。CBS法由日本创造发明研究所所长高桥诚根据奥斯本的智力激励法改良完成；NBS法是日本光播电台开发了一种智力激励法。CBS法的具体做法是：会前明确会议主题，每次会议由3至8人参加，每人持五50张名片大小的卡片，桌上另放200张卡片备用。会议大约举行一个小时，最初10分钟为“独奏”阶段，由到会者各自在卡片上填写设想，每张卡片上写着一个设想。接下来的30分钟，由到会者按照座位次序轮流发表自己的设想，每次只能读一张卡片，宣读时将卡片放在桌子中间，让到会者能清晰看到。在宣读后，其他人可以提出质疑，也可以将启发的新设想填入备用的卡片中，余下的20分钟要到会者相互交流，探讨各自提出的设想，从中再诱发出新的设想。NBS法的具体做法是：会前必须明确主题，每次会议由5至8人参加，每人必须提出5个以上的设想，每个设想填写在一张卡片上。会议开始后，每个人出示自己的卡片，并依次做说明。在别人宣读设想时，如果自己产生了“思维共振”，产生新的设想，应立即填写在备用卡面上。但到会者发言结束后，将所有卡片集中起来，按内容进行分类，横排在桌上，在每类卡片上加一个标题，然后再进行讨论，推选出可供实施的设想。&#8195;&#8195;智力激励法原理就是集思广益，如中国传统的说法：“三个臭皮匠，顶个诸葛亮。”萧伯纳曾经说过：“倘若你有一个苹果，我也有一个苹果，而我们彼此交换这个苹果，那么你和我仍然只有一个苹果。但是倘若你有一种思想，我也有一种思想，而我们彼此交流这种思想，那我们每个人将有两种思想。”&#8195;&#8195;下面讲头脑风暴法的应用条件。对主持人的要求：一、对主体有深刻的理解；二、不独断；三、有激情；四、能控制场面和进度；五、会戴两顶帽子，一顶帽子充当主持人，一顶帽子充当参与者；六、有引导能力。技巧：一、引导技巧；二、随时记录不漏；三、打乱循环，从一点开始讨论；四、思维发散，但主题不发散；五、鼓励发言；六、禁止评论；七、限制时间为10到60分钟。之后合并问题的同类项，对于问题进行排序，组合问题，评论问题，认证问题的可行性。对于开放性问题，头脑风暴法的应用。如产品或市场创意：新的消费观念、未来市场方案、新技术商业化；广告创意的创作方法：头脑风暴法、检核表法、联想法、组合法；管理问题：如人力资源、拓展就业面等；规划问题：未来可能增加困难的预期、SWOT分析；改善流程方面：生产流程的价值分析；故障维修方面：寻找故障原因。&#8195;&#8195;智力激励会的准备。选择会议主持人：主持人应熟悉智力激励的基本原理和召开经理会的程序及方法，有一定的组织能力；确定会议主题；确定参与会议的人选：5到15人为宜。人员的专业构成要合理。大多数与会者都是对议题熟悉的行家，但并非局限于同一专业，而是考虑全面多样的知识结构；提前下达会议通知：比如“某某产品的研发方案论证会”；热身活动：使参会者加快进入角色；明确问题：与会者对会议所解决的问题，要有明确的全面的了解，以便有的放矢地去创造性思考。主持人介绍问题要注意掌握简明扼要原则和启发性原则。简明扼要原则是主持人只要向与会者提供有关问题的最低数量信息，切忌将背景材料介绍的过多，尤其是不要将自己的初步设想也和盘托出。启发性原则是指介绍问题时，要选择有利于开拓大家思路的方式；自由畅谈：与会者能够突破种种思维障碍和心理约束，自由地思维，借助与与会者之间的知识互补、信息刺激和情绪鼓励，提出大量的有价值的设想；加工整理：会议主持者应组织专人，对设想记录进行分类整理，并进行去粗取精的提炼工作，如果已经获得解决问题的满意答案，智力激励会就完成了预期的目的。&#8195;&#8195;实现创新的途径。有创造欲望的人必须有相关的基础知识。如何实现创新需要在创新理论和规律的基础上，运用有效的创新方法来实现创新，创新方法来自实践。如鲁迅所说：“地上本无路，走多了变成了路。”创新等无法，用多了变成了法。每个人都具有创新能力，请坚持：用熟悉的眼光看不熟悉的事物——不放过任何细节；用陌生的眼光看熟悉的事物——发现问题；用熟悉的眼光看陌生的事物——进行类比、联想；用陌生的眼光看陌生的事物——探索、深思。&#8195;&#8195;本次课的内容就讲到这里，主要给大家介绍了创新方法，感谢大家的收看。  \n创业意识与创新精神创新精神与企业家精神&#8195;&#8195;同学们好，今天我们来讲一下这一章的内容。创业精神、动机与行为。为什么把精神动机与行为放在一起呢？因为我们在开展具体的创业活动之前，你可能需要先考虑一下你是否具有充足的创业精神、你为什么要创业或者为什么不愿意创业，然后我们才会可能碰到你所见的可以别人看见的创业行为。所以我们今天来了解一下精神、动机与行为。&#8195;&#8195;在这章内容里面，我们主要介绍以下六个知识点：创业精神，我们需要辨析一下创业精神与企业家精神之间的关系；然后关于创业动机，我们需要了解一下他的基本概念，以及有哪些因素会影响你的创业动机；然后我们需要介绍一下基本的创业活动，并且了解一下领导力在创业活动中的重要内容。&#8195;&#8195;首先我们来看一下创业精神。创业精神是什么？有些同学说：“我并不想创业，创业很辛苦。”这句话说对了，真的创业是什么？创业就是以有限的资源追求无限的理想。当你的资源有限，但你有想去做一些很大、很美好的事情的时候，这个我们说就是有一定的创业精神了。也就说，创业精神是一个人会以当前有限资源为基础，但要去追求商机的这么一种精神，那么会造就成一种突破资源限制，通过创新来创造机会的行为。这个叫创业精神。&#8195;&#8195;进一步呢，我们把创业精神定义为“企业家精神”。这个词可能同学们有时候没有太注意，entrepreneurship，这个词叫企业家精神，我们在概念上把这两种精神认为是对等的。企业家精神是着重于一种创新活动的行为过程，通过创新手段，把资源更有效的信息利用，为市场创造出新的价值。所以我们在讨论创业精神的时候，经常会说企业家精神。同时也请大家要了解企业家精神到底是什么内容。&#8195;&#8195;那么关于企业家精神，我们先来看一下有几个大师级的人物，他们的定义。首先是熊彼特，熊彼特是我们经济发展史上的最有名的一位经济学家，那么他曾经在他的成名作《经济发展理论》那本书中提到过：“企业家的核心就是创新，是一种创造性的破坏，也就说要做不同的事情，而不是把已经做过的事情做的更好。”这句话的核心意思是，你需要有所新的意义、新的形式、新的内容。那么另外一位大师，彼得·德鲁克，他对创新企业家精神的定义是这样的：是有目的的、有组织的创新，是一种行动，而不是人格特征，是踏踏实实的工作，是实践。德鲁克特别强调实践，他认为你再有创新思想，你不去把它落实到行动中，那不是创新。为此，他特别强调，企业家精神是通过创新活动来实现一些事情，实现一些理想，这个叫企业家精神。那么同学们如果有兴趣的话，可以去看一下他那本书《创新与企业家精神》。德鲁克的书特别也好懂，几乎没有任何数字，全是在阐述他的理念，并且列举出很多的案例，非常适合我们去学习。那么进一步在创新研究理论里面，有很多学者提出了企业家精神不同的内涵。我在这里列举了一些研究学者，他们对企业家精神的定义，我们可以看一下。由Miller在1983年说：“企业家精神有三个主要特征：创新、承担风险与主动进取。”Lynn在1991年说：“企业家精神是一种价值观体系，也是人们对待其他个体或各种事物的态度。” 他把企业家精神认为是一种价值观。还有学者认为，企业家精神是一种前瞻性，是一种渴望超越现有能力、解决争端的能力，并且提出需要明确在企业创业过程中，团队的位置和大家的学习。那么我们国家的学者也有对企业家精神进行了定义。比如吴向鹏与高波认为，企业家精神是一种文化资本的积累，是在特定文化影响下的企业家群体所具有的共同的价值观取向。那么还有学者认为，企业家精神是企业将在特定的社会环境、经济体制下，面对激烈的市场竞争环境所形成的独特的心理素质、思维方式、价值观与精神状态。他的这个定义更倾向于把企业家精神当作是一种创新的意识与拼搏。所以在这里呢，我们可以看出来不同的学者对企业家精神的这个定义角度不同，有的是从行为的角度，有的是从价值观的角度，有的是从心理的角度。那么还有中国学者李奇做了一件很有意思的事情。他在2016年调研了我们国家一些本土企业家，请他们自己对自己的企业家精神做的一些定义。他进行了归纳，我们可以看一下。一共有八点内容。中国的企业家自身认为，他们的企业家精神表现在第一还是创新，第二是敏锐洞察。第三是果断有魄力，即使是执行力，然后是冒险敢为、乐观自信、成就动机和组织能力。大家可以看一下针对这八点内容，你自己所具备的精神状态如何。所有的这些对企业家精神的描述中间，我们可以进行归纳，归纳出四点最为核心的内容。&#8195;&#8195;第一就是创新。什么叫创新？具有创新精神的企业家是什么样子的？更像一个充满激情的艺术家。创新有很多内容，大家首先都能想到的是技术创新。技术创新可以提高生产效率，降低生产成本。比如说最开始，我们用盒式磁带来记录计算机的信息，后来有了光盘，那我们就不用磁带了，再后来有了MP3我们也不用光盘了。技术是一代更新一代，把原有的东西给取代掉了，这是一种技术创新。再比如现在大家都知道，你很少去看传统的报纸，因为手机、互联网给了我们很多很多的信息；再比如你现在可能知道什么是AR虚拟现实头戴显示器设备，这个东西给我们的销售、给我们的购买可能带来什么样的颠覆的行为；再比如你可能知道人工智能，人工智能的兴起可能会以后取代一些员工的职位；再比如什么叫移动医疗，移动医疗可能会为我们以后的医疗行业带来颠覆性的技术创新。所以这是技术创新。还有一些创新，我们可以再进一步考虑，比如什么叫经营创新。经营创新是一种可以使组织保持长久的竞争力，灵活应对外部环境变化，这叫经营创新。如现在网络那么多，你可能会想到我们新的营销渠道用什么方式来建立，可能用网络上面的营销渠道比在实地的营销渠道建立更有效；比如我们现在特别强调什么叫客户服务，你能在客户服务里面，上面提出新的价值观的话，那就是你的一种经营创新；再比如什么叫大数据，大数据到底价值如何，大数据是怎么样帮助一个企业去实现精准营销；再比如你天天玩的微信，微信你虽然天天浏览新闻，但实际上它已经成为一个新的网络销售平台。那么这一切都是种经营创新，企业家都需要去考虑在这些技术中间、在这些模式中间、最新的平台中间，我怎么样去改变自己的经营模式。还可以有什么创新呢？比如体制创新。什么叫体制创新，就是以管理方法的创新。比如说原来我们有科层制，科层制的级别非常的多，那么带来的信息传递本的不通畅，那我们现在采用扁平化的组织结构，我们压缩组织的层级，我们利用技术去加强沟通和交流，这就是一种体制创新；或者在进一步我们现在用虚拟团队来进行项目管理，我们的团队成员可以分布在不同的地域，但是我们通过互联网可以进行项目管理、进行充分的沟通，这都是一种体制创新。更进一步还有管理思想的创新。这种创新在企业发展中所起的作用是非常重要的，因为思想的创新会推动企业的技术创新、经营创新和体制创新。比如说领导者的思想进行创新，觉得我需要去尊重员工的需求，让员工参与角色，那这样就会很好地提高员工的工作满意度，而不是仅仅通过薪酬去提高他们的工作满意度；或者领导觉得我现在要注重团队绩效，我把我的绩效考核方式由各级评定，改为团队评定，那样能够极大的鼓励团队运作的绩效；再比如，在GE中间有逆导师制，就是上层管理者能够向下层的员工进行学习，学他们新的思想、学他们对新的技术的应用方式，并且把这个东西融入到管理中间，那这就是一种思想的创新，它能觉得我们的学习需要向员工学习、上级需要向下级学习，都是一种思想创新。所以创新应该来说是体现在不同的层面，通过创新，我们可以发现新的经营模式，发现新的经营平台，发现新的利润点。这是企业家精神所需要的第一个要素。&#8195;&#8195;第二要素是冒险。什么叫冒险？我在这里列了一些数据，请大家看一下。美国做出一些调查，比如1999年到2002年之间存活的企业只有29%，那么这些企业大部分是因为哪些原因而倒闭的呢？一般是它的产品可能是非市场需求，资金短缺或者团队不合适。那么中国也有些数据，我们可以看一下。中国创业企业的失败率为80%左右，企业平均寿命不足3年，其中2013年成立的公司死亡率占比90.6%。我给你展现这些数据之后，你觉得你还需要去创业吗？你是不是觉得创业是一个很冒险的事情？你如果觉得是的，那就对了。创业必须得冒险，没有一个创业会告诉你既定的成果在哪里，你必须去挑战那种不准确性、不确定性。比如联想刚开始买一下IBM笔记本事业部、TCL进军欧洲市场，当时他们都付出了很大的冒险的代价，有高额的员工成本，市场对产品的不接受等等的，做了十几年下来才慢慢地稳定下他们的市场。这都是一种冒险。你不可能说因为最初的冒险，而且否定他的策略。那么冒险的境界我们会说有三个。第一个、比较乐观积极，能看到一些机会，但是看不到一些问题。第二个、认为成败是由自己决定的，认为中间能控制一些事情。第三个冒险程度是对风险迟钝，几乎看不到任何风险。那么我们每个人都会考量一下，你的冒险程度是怎样，你在做一件事情没有既定成果之前、看不到前景之前，你愿意冒险到什么程度。这是企业家精神的第二个要素。&#8195;&#8195;第三个要素是合作。我们为什么要合作？因为竞争，所以合作，而且合作需要源自、发自内心的对秩序的尊重。也就说，在现在这个知识大爆炸的年代，你很难说你是独个的英雄去闯出一片天下，你必须要和别人一起去组成一个团队，进行合作，才能成就一些事情。那么在这个合作中间有哪些互补？比如说有知识互补：技术、市场、管理知识可能都存在于不同的头脑中间，一个人很难在现在知识发达的基础上，把所有的知识都能学会，都能精通，所以必须需要知识互补。第二、角色互补：每个人的性格不同；有的人适合做领导者；有人适合做协调者；有的人是踏踏实实的实干家，听从命令；有的人善于去监督；有人善于去了解各种的信息……那么必须要做的角色互补，才能形成有效的团队。还有一种互补叫资源互补：运作一个企业，人力、资金、技术、客户资源可能分布在不同的地方，每个人都有一定的社会资本，那么我们需要把不同的那种社会资本汇集在一起，去充分的利用这些资源。所以要在现在的竞争中学会合作，只有通过合作才能够扩大团队的竞争力量。那么在这里给大家推荐一下，可以去了解一下什么叫合伙制。现在几个人在一起合作，创办一个企业，可以用合伙制的方式去构建相互之间的关系。这种合伙制每个人享有企业经营所得，并对经营所亏损承担相应的责任；并且每个合伙人都必须参与到经营过程中间，不能说只是出资金，不出力，就能获得经营分成；而合伙人的规模可以洽谈。所以现在比较合适的方式就是合伙制，通过合伙制去形成一种契约，进行合作。你们可以去了解一下新东方的俞敏洪、徐小平和王强之间，他们怎样的性格互补。俞敏洪是一个生性温和的人，坚韧，但是比较现实谨慎；徐小平充满激情，能充分的表达对理想的追求；而王强是理想主义色彩的，显得相对冷静。他们三个在一起，性格互补、能力互补，最最终造就了新东方的发展。同样，你们可以去看看马云。马云是学英语专业的，他对计算机、他对网络并不精通，那他为什么能够成就淘宝、成就阿里巴巴？你可以去看一下他的18个人的最初的创业团队，他们怎么在知识上进行互补。这种知识包括技术知识、金融知识、网络知识，方方面面的知识合在一起，最后才能造就阿里巴巴。&#8195;&#8195;第四个要素是学习。这里的 “学习”是一种真正的学习，甚至涉及到人之所以为人这个核心的含义，也就是说我们要成为一个真正的人，我们需要学什么。我们在课堂里面学知识，但是当面对创业的时候，学的不仅仅是书本上的知识，而是很多实践上的知识。而且怎么去学、向谁学，这是涉及到价值观的问题；需要向自己的成功或者失败的经验学习，需要善于反思；需要向合作伙伴学习、向竞争对手学习。同时学习什么东西呢？更有效的是学习思维方式。有的同学会说：“我看过马云的例子，看过新东方的例子，但是我不可能成为马云啊。我现在学习什么呢？”对了，你不可能成为马云，因为你所处的时代、你所处的社会情境和马云不一样。但要学习下什么呢？你学习的思维方式，学习他在面对困难的时候他怎么去考虑，学习他怎么去融资，学习怎么去整合资源。这个是你需要去学习的重点，那么我们需要通过学习达到什么样的效果呢？每个人的知识体系都需要一定的系统化。当头脑中的知识有逻辑的地摆放的时候，能进行系统化思考的时候，这个学习的效果就达到了。同时需要记住，我们需要终身学习。比如李开复，他是创新工厂的创始人。他曾经说过：“什么叫学习？首先学习知识。第二要思考进行反思学习的效果怎么样。第三需要把学习的知识应用到实践中间去体验。然后需要去悟，通过学习自己在思维方式上得到什么样的提升，这个才是学习。”&#8195;&#8195;所以在这里提炼一下企业家精神的核心四要素是创新、冒险、合作、学习。&#8195;&#8195;这一讲我们就讲到这里，谢谢大家。  \n企业家精神的新诠释&#8195;&#8195;现在我们来讲一下这个知识点，企业家精神的新诠释。在上节里面，我们讲过企业家精神就是创业精神。但是有些同学说：“我并不想创业，我为什么需要去了解企业家精神呢？”那么我告诉你，企业家精神现在的新诠释意义在哪里。&#8195;&#8195;我们可以看一下，在这张图里面，最上面一栏是创业精神，也就是企业家精神。那么他有两种具体的表现：第一是独立的创业精神，也就是我们前面说的，你可能需要去开办一个新的企业，进行一个新的公司的运营，那么你需要企业家精神；第二组织的创业精神，也就是说，你可能未必去创业，你只是一家公司里面或者一家组织里面的一员，但同时也需要你有一定的创业精神和企业家精神。为什么呢？我们再往下看。&#8195;&#8195;组织的创业精神，表现在，第一叫组织创新，第二叫组织更新。&#8195;&#8195;什么叫组织创新呢？创新是需要做一些颠覆性的工作，因而组织结构、运营方式和思想理念可能需要进行大幅度的变化，有的在组织内部，有的可能在组织外部。比如说你的公司和另外一家公司相互兼并形成一个新的公司，或者你们公司需要去去掉一些员工，砍掉一些部门。这些比较大幅度的创新需要具有创新精神。&#8195;&#8195;那么什么叫组织更新呢？更新，我们认为是一些小步伐的、逐步积累的创新。所以在一家组织里面，同样强调需要具有创新精神。因为无论是组织创新还是组织更新，都会面对一些新的事物，都需要去进行积极推进一些事情，可能都需要去解决一些来自人际之间的阻碍，那么这里的创业精神，连同前面说的创新、冒险、合作、学习，同样需要去具备这样的精神，才能顺利去进行这样的事情的变化。&#8195;&#8195;所以就说，创业精神、企业家精神同样也可以体现在组织内部的管理上，而不仅仅是那些独立创业的人需要具有，在组织内部的员工也需要具有企业家精神。同时，我们认为企业家精神在组织内部是传递的，由上级传递给下级，由企业高层传递给企业中层，由企业中层传递给一般的员工。当一家企业的员工都具有企业家精神的时候，那么这家企业的变化、这家企业的奋进是不容小看的，它一定会发展的很好。所以在这个意义上，请大家记住，也许你并不去创业，但是为了你的职业发展同样需要具备一定的企业家精神。&#8195;&#8195;我们在这里可以再具体再解释一下员工的企业家精神有哪些表现。创新精神：你需要在工作中主动积极进取，你需要采取一些有效的方式去解决工作中遇到的问题。同样，你也需要具有合作的精神：在工作中与同事积极配合，相互信任。第三，你可能需要去相当的求知精神，你需要努力学习，获取新的知识信息和技能。第四，你可能需要一定的责任精神，你对工作的责任心需要有一定的保障，并且敢于承担责任。当你具有这样一定的企业家精神的时候，首先你自己的自身职业成长会比较顺利，因为你会让你的上级感觉到你的能力、你的潜力和你的责任心。第二，你会对你们公司部门的绩效提升有所帮助，再进一步你会对你们公司整体创新会有所帮助。所以我们现在讨论企业家精神的时候，不仅仅是针对企业家高层，我们需要整体的员工、整体的员工队伍里面都具有一定的企业家精神。所以这个我们是说对企业家精神的新诠释。一种企业家创业的精神需要在公司整体里面进行推广，进行相互的影响。&#8195;&#8195;我们在这里稍微小结一下。什么叫创业精神？创业精神就等于企业家精神。企业家精神的核心要素是什么？创新、冒险、合作、学习。第三，企业家精神不是企业家独有的，优秀的员工也需要体验出这些特征，会有利于自身的职业发展。&#8195;&#8195;那么到这里，我们把创业精神这一小节内容就讲完了。  \n创业动机的基本概念和内涵&#8195;&#8195;接下来我们来了解一下创业动机，了解一下创业动机的基本概念和内涵，以及有哪些影响因素，会对创业动机产生作用。&#8195;&#8195;首先我们来了解一下什么叫动机。动机是个体唤醒其脑行为，并且朝向特定事物或者目标的一种内部状态。这是一个心理学的词。一般描述一些人的动机，典型的有成就动机、权力动机、亲密动机。成就动机是想把一件事情做得更好，并且获得更高的目标，在这个过程中不断去努力战胜困难。权力动机是影响别人、让别人听从你的指挥和安排，让别人对你的要求做出回应，控制别人。亲密动静的意思就是说，希望和他人之间建立良好的互动关系，彼此获取温暖，有融洽的交流。我们每个人心存在这个世界上做事情都会有些动机，不同的人在动机的表现程度上会有所不同。那么在做一些事情之前，确实需要去了解一下你在哪些方面的动机比较强烈。&#8195;&#8195;一般来说，我们把动机分成两大类，一类叫内在动机，一类叫外在动机。内在动机意思说因为对事情或活动本身比较感兴趣，是自发的去做的，力量是自内心的；做的好不好自己会有评价，也就是说，这种评价的收获并非是外部的而是内部的，具有较强的主观性；存在这种内在动机，做这件事情的持续性就会比较长。外部动机是因为外部的刺激或者诱惑而去做这件事情，比如说希望提高薪水，希望获得一定的社会名望，希望得到别人的评价，因为这个需求才去做一些事情；事情评价的标准来自外部，具有较强的客观性；会依据外部的标准进行判断，是不是还要继续做这件事情；在一件事上是有外部动机的话，行为会随着外部刺激条件变化而产生变化。这两类动机，我们一直是认为，在做一件事情的时候，内在动机越强，成就欲望可能就越高。&#8195;&#8195;同时我们去分析动机和行为之间的关系，你需要知道，有动机并不一定就会促成行为。也就说，它们并非是一一对应的关系。有的时候有动机，但不一定产生行为；有的时候一个行为背后并不有明显的动机，可能是无意识去做的；有的时候同样的一个动机可能产生不同的行为，因为在不同的场景下表现的方式可能不一样；同样的行为背后可能有多种动机存在。也就说考量一个人的行为，要去仔细推敲其背后的动机是什么。&#8195;&#8195;那么创业动机呢？创业动机是激发、引起、维持、调节人们自主地从事创业活动的一种内部心理过程，或者内在原始驱力，它使得创业活动始终朝着某一方向或者目标行进。从这个定义可以看出，创业动机是非常强调内在动机的，强调自发地、自主地去从事这个事情。对既定目标的向往、憧憬，内化为创业者内心的信念，激励其不断地去进行创业活动。然后就会努力去实践、去做、去辨识，抓住那些机会，朝着特定的目标坚持不懈，努力去实现创业梦想。所以创业动机很强调内在，是否因为内在的兴趣和执着去进行创业活动的。&#8195;&#8195;对于创业动机的描述，不同的学者同样也给了细致的划分。比如在这个模式下，一般认为创业动机存在四种动机形式：一是需要获得外部报酬：积累个人财富、增加收入机会，或者增加企业的销售额与利润；第二，追求独立自主：追求人身自由、个人保障、自我雇佣、做自己的老板，并且能够控制自己的职业命运；第三，获得内部报酬：获得公众的认可，或者享受乐趣的这种成长方式来证明自己的能力；第四，获得家庭保障：因为家庭的需求而从业创业活动，然后为家庭成员去获取一定的资金、安全方面的积累，并且想建立一个可以传承下去的家族企业，或者为自己的退休做准备。那么我们可以衡量一下，你如果具有一定的创业动机，在这四个方面，哪种动机最为强烈。&#8195;&#8195;也有中国学者对中国的创业行为进行的描述，把中国人的创业动机区分为两大类。第一是事业成就型，也就是说想通过创业活动，去获得一定的成就，实现自己的梦想，扩大自己的社会交际圈子，成为成功人士，并且向控制自己的人生发展。还有一种是生活需求型的创业动机，也就是说，对目前的薪酬收入不是很满意，想通过创业活动去提高自己的收入，给自己和记着家人带来经济上良好的保障，不会失业，不会贫穷。这是在中国现实的基础上，我们认为有两大类的创业动机存在。同样，你也可以考虑一下，在这两类中间，如果你去创业的话，可能偏重于哪一类。&#8195;&#8195;我们再来看一下大学生这个群体的创业动机。我先给大家一些关键词，在这些关键词中间，请你选四个，你认为如果你去创业的话，哪四个词是比较喜欢的。这里面有无畏失败、喜欢刺激、积极进取、就业形势不好、父母支持、拥有权利、自我实现、锻炼能力、学以致用……选择四个。我们了解一个人的动机，我们承认他的动机可能有多种因素，但是每个人需要去确认一下哪些因素，对你来说是最为重要的。那么有过一个调查，发现我国大学生的创业动机主要特征表现在四个方面。第一是冒险敢为：这样的学生特别想做一个充满活力、积极进取的人，他能够承受一定的挫折和失败的打击，把创业当作获得大家认可的一种途径，把创业当作一种自我挑战的方式，相对来说是一个善于识别并且抓住机会的人。第二是自我实现：有些同学认为创业能够更好的实现自我价值，能够更好的发挥自己的专长，并且把创业视为解决就业的一种途径，认为创业是自己实现自己人生理想的最佳途径，在这种机会下觉得可以锻炼自己的能力、积累经验。大学生创业动机的第三个表征是追求名富：有些同学希望通过创业来获得财富，认为创业能够为自己的家庭提供经济保障，并且能为自己获取一定的社会地位、社会名望，希望自己能够做老板做决策，能够控制他人。第四个大学生的创业动机是拥有支持：身边可能会有一定的资源，包括人脉资源、信息、资金资源，帮助你去实现你的创业，有成功的案例，或者你所在的学校有过创业的课程的讲座。或者在身边有同事、父母、亲友帮助下获取一些经验，也参加过一些相关的创业培训，因为这些你觉得有必要去做一些创业的事情，我们把这个认为是拥有支持。&#8195;&#8195;在这四个创业动机之前，有一项调查，一共考量了850位大学生的意见，最后得出的结果是这样：中国的大学生的创业动机排名第一位是自我实现，然后是冒险敢为，第三是追求名富，第四是拥有支持。整体来看大学生创业的内部动机略为高于外部动机。因为我们把自我实现、冒险敢为归纳为是内部动机，因为是喜欢做这个事情。而追求名富、拥有支持，相对来说是外部动机。那么我们每个同学都可以考量一下，在这四个方面，四个动机上，以哪个动机表现最为强烈。&#8195;&#8195;这一小节的知识到这里为止。  \n创业动机的影响因素&#8195;&#8195;接下来我们来了解一下创业动机的影响因素，也就是说，有哪些东西会影动机形成。我们从三个方面来进行剖析。第一是个体，也就是你自己。第二是原生家庭。第三是社会。&#8195;&#8195;我们首先来看一下个体。个体里面我们首先需要了解的是人格特质。心理学家提炼了很多人格特质的概念去描述人的个性、特征。在这里面，其中有一些会显著地影响创业动机，如第一个主动性，即做事情是不是自发的。具有一定的主动性会显著地正向影响创业动机。第二是自我控制点。自我控制点把人分成两类两位倾向，一类是内控型，认为自己的命运可以靠自己主宰，第二是外控型，认为自己需要随波逐流，没有办法去控制自己的命运。那么在这一点上，内控者将具有更强烈的创业倾向。第三，有自我效能感。自我效能感，是对自己的一种自信，相信自己能够成就一些事情。那么很明显，自我效能感高的人，他会显著正向影响他的创业动机。再比如，不确定性容忍，这个词理解起来可能需要倒过来，叫“容忍不确定性”。对不确定性情况越能容忍，创业动机将越强烈。除了这些之外，心理学家还刻画出其他的一些人格特质。我们都可以去描述去研究什么样的人格特质对创业动机能产生影响作用。&#8195;&#8195;第二块、人口特征。这一块，我这里列了一些相关的研究结论，大家可以了解一下。比如关于性别。男生创业动机更加强烈，男生追求名富的动机更高。第二，是否为独生子女。经过统计分析，非独生子女的创业动机更高。第三，教育背景。教育学历低的同学反而创业动机更强。第四，有专业。专业与管理学、经营相关，或者研修过创业课程、管理课程的学生，其创业动机更为强烈。大家都可以对比一下自己的性格特征、性别、是否为独生子女这些状况，自己是否相符，或者与身边的同学情况是否相符。这些统计学的定义、结论都是一些普遍意义上的结论，分析到具体个人的时候，可能需要去分析好几个影响因素，在自己身上最终发生什么样的作用。这是第一大块，对于你自己。&#8195;&#8195;第二，我们发现原生家庭对每个人的创业动机会产生影响。第一个是父母教养方式，也就说，父母在去带养孩子的时候，与孩子之间是怎么互动的。可以把父母教养方式分为两类，一叫自主支持型的父母。这一类的父母比较能够理解支持孩子的选择和决定，并且能站在孩子立场上去考虑事情应该怎么做；能够倾听孩子的观点，对孩子的行为、情感等方面给予积极的响应，亲子之间的互动是比较平等的；会给孩子提供较多的独立的自由的以及解决问题的机会。这类我们认为是自主支持性父母。很明显，这类父母会显著的正向预测孩子的创新精神、成就动机和社会创造力，对孩子的创业动机是有正向影响。第二类是行为控制型父母。这类父母喜欢通过主动询问和观察等方式，了解子女的行动，并向其施加规范、规则的要求；他们会对自己的行为进行监控和指导，甚至过度控制子女的活动；他们的出发点可能是爱心，但实际限制的孩子的实现目标的自理能力。我们把这一类父母定义为行为控制型父母。那么可以看出，这种类型的父母，他们的行为也会负向预测孩子的企业家精神、事物处理的执行力，会抑制孩子的创业动机。&#8195;&#8195;同样，父母的职业可能对创业动机也会产生一定的影响。比如在中国目前的现状下，父母拥有小公司的孩子可能更具有创业动机，他们在耳闻目睹的成长过程中间看到了父母创业的行为、创业的意愿，他们自己也会萌生出这样的愿望。再进一步，家庭的社会网络，越处于社会网络顶端家庭的孩子越不愿意创业。社会是存在一定的分级分层的，相对来说，家庭资源比较丰富，家庭经济状况比较好的孩子，可能并不太愿意去冒险，反倒是一般具有中下阶层家庭背景的孩子更愿意去创业。第三，在地区创业氛围上，所处于不同的地区的创业氛围会对创业动机产生影响。举些例子，比如说政府的政策、社会文化背景、经济状况、当地的基础设施、环境等。相对来说，经济越发达，政府的政策对创业活动越支持，以及所处于的社会文化背景对大学生的创业态度越好，人际关系越为和谐，那么人的创业动机就会被更多地激发出来。再进一步，所在的高校是否开设创业教育课程是，否有一定的、充沛的创业教育师资，以及学校是否提供了良好的校企合作平台，让学生有充足的时间、地点、资源去进行创业活动，并且能够得到充分的信息，那么创业动机也会被更多地激发出来。&#8195;&#8195;所以在这里，我们再小结一下创业动机。创业动机是激发创业行为的先决条件，内在动机的重要性程度绝对高于外在动机。大学生的创业动机表现在自我实现、冒险敢为、追求名富、拥有支持等方面。不同的人格特征、不同的父母教养方式、不同的社会创业环境等等，都会影响创业动机。&#8195;&#8195;这一小节到此结束。  \n创业活动的基本内容&#8195;&#8195;接下来我们来了解一下创业行为。我们了解了精神，了解了动机，那么现在具体的是需要去表现出创业行为的时候了。&#8195;&#8195;创业行为是近期我们对创业活动描述最为关注的地方。也就是说，再多的人格特质，再多的动机激发，最后都需要通过显性的行为来表征，到底创业活动怎么去做。&#8195;&#8195;创业行为有很多的描述框架。比如说我们国家的专家张玉利，他是在我国研究创业行为比较多的一个专家，他认为创业是一个具体的行为过程，包括感知机会、组建创业团队、获取创业资源这三个基本的环节。那么对创业活动的了解，我们可以把它放在一个大的社会背景的体系下去了解。因为创业活动涉及到四个方面的要素：第一是涉及到谁在创建新企业，也就是个体的人格特质、能力、动机等方面；第二是所处的社会环境是否有充足的创业条件；第三是拟创建新企业的性质、合伙方式、融资方式、人员构成等等；第四是具体的创立一个新企业的过程。所以对创业行为的描述，其内容是相当繁杂的，我们需要去具体地做一些了解和剖析。&#8195;&#8195;那么，不同的学者对创业行为的描述也会有不同的侧重。比如有些学者对创业活动的描述非常地具体，比如包括个人投资、结构商业模式、识别商业机会、组建团队、注册一个合法的组织、安装商业电话、采购主要办公设备、开银行账户、寻求资金等等。大家可以看出，真正要去做一家公司的时候，这些事情都需要去亲力亲为。也有学者把这些创业活动分为几个大类，比如包括发现和提炼商业机会、获取资源和帮助、经营业务、识别客户和销售、处理企业外部事宜等等。有的学者（Mueller et al.）也对比了初创型企业和成长型企业的企业家活动有什么差别（在这里初创型企业是刚刚成立的新企业，成长型企业是已经度过了生存关，开始逐步面向正轨进一步发展的企业），发现这两类企业中间，企业家的活动都主要集中在三个方面：人力资源和员工关系、销售和公关、内部运作事务管理。所以大家可以了解一下，一旦你真正准备去创业了，这些事情都需要在你的设想中，你需要去详细的勾画怎么去具体运作这些事情。&#8195;&#8195;在这里给大家介绍两个创业动态跟踪研究，一个是国外的，一个是我国的。&#8195;&#8195;1995年，美国学者提出了PSED研究构想，这是一项在全美范围内开展的创业动态追踪研究，详细地跟踪了很多企业在从创立到发展的过程中都做了哪些事情。我列举了一些问题放在这里，大家可以了解一下，比如说研究新生创业家是如何知觉技术变迁的，也就是说，他如何发现技术正在更新，需要不断地替换；新生企业家如何运用理性思维进行重要决策，在一些重要的事物面前怎么样及时地、理性地去做出决策；怎样作出终止企业规划和终止新公司营运的决策；怎样去知觉市场商机的经济效益；开发一个新的产品的时候，具体执行什么样的步骤，以及他的融资方式等等。从这些问题可以看出，这个研究对新生企业家的活动了解非常地具体，可以作为我们充分的参考依据。&#8195;&#8195;中国的研究学者从2009年开始，也开创了一个面向中国的新企业创业激励与成长模式的研究。在这个研究框架里面，把创业活动分为四大类。第一是前期计划，在这个活动里包括组建团队、准备创业计划、分析与预测投资风险、为创业开始存钱；第二是资源投入，包括申请专利、商标或者版权、采购原材料或者进货、购置或者租赁厂房、仓库这些大型资产、向其他人或者机构融资、把自己的资金投入创业、接触并联系供应商开始雇佣员工；第三是市场活动：开展营销推广工作、收集顾客、市场与竞争对手的信息、进行产品或者服务的开发与设计；第四是合法化活动：工商部门去登记注册、对外公布电话、网站信息。大家可以看一下，如果你真的需要创业了，这四类活动都是需要去做的。一共四大类活动，你怎么样有条不紊地去安排，去开展你的创业计划。在这研究中，研究者也发现有些活动是比较多的，有些活动是比较少的。比较多的活动包括开始攒钱创业、分析和预测财务风险、搜集顾客与市场信息。比较少的活动包括实施登记注册、进行外部融资、申请专利、商标。我们可以发现，事实上，就前面所说的这四大类创业活动来说，我们需要均衡地去安排自己的精力，然后合理地去推进自己的创业活动的开展。&#8195;&#8195;还有一些调查帮我们归纳目前中国青年者的创业行为包括哪些，我们可以看一下这边有一些数据。第一大类，关于市场前景、启动资金、创业风险、个人兴趣，都有一些相应的数据表征。我们的中国青年创业者首先考虑的事是前景的预测，在创业前期都会开展市场调研，考察创业环境，培养创业能力，筹集创业资金。在具体的创业启动资金方面，在10万元以下的占56.9%，10万到30万元的占22.8%，30万到50万元的占8.1%，50万元以上的占12.2%。那在创业团队构建方面，只有34.9%的创业者是选择团队创业，更多的是个人与夫妻的创业方式。那从这点上看，对于创业者的创业精神、企业家精神来说，合作是一个相当重要的要素，也就是说我们中国青年的创业行为，可能需要在合作方面做进一步的提升。&#8195;&#8195;这些都是关于创业活动的描述，从创业初期的创业成长期，可能会经历哪些创业活动，怎样合理安排自己的精神，合理安排自己的精力，这都需要去认真考虑的。&#8195;&#8195;这节内容到此结束。  \n创业活动中的领导力&#8195;&#8195;接下来我们再来了解一下创业活动中的领导力问题。为什么要提这个问题呢？我们前面说过，现在创业活动不是一个人单打独斗的，需要有团队，那么在团队中有一个领导，然后他需要带着几个人去做一些可能有些困难、用有限的资源去实现梦想的这么一件事情。为此需要了解领导力的建设很重要。&#8195;&#8195;创业是一个有计划的行为过程。创业中的领导者需要具备一定的知识，用以判断分析、并发掘潜在的创业机会，做出战略决策，通过协调创业活动所需要的人、财、物、信息等资源达成创业目标。也就是说，创业活动的领导者需要通过主动创造愿景来激励下属致力于发现和创造战略价值，并动员和赢得下属的支持。能做到这样的事情其实并不容易。&#8195;&#8195;创业领导力可以分为以下四个方面。第一是愿景能力：通过身份认同机制来开发关键相关利益者的愿望和能力。愿景是一件从上到下大家都认同的事情。愿景不同与目标，目标是管理者认同的，可能员工并不认同，而愿景是大家共同认同的。一个人认为他归属于这个团队，有身份认同感，然后他就去做这件事情。大家彼此都共同认可这个目标，我们把这个叫做愿景。那么作为创业的领导者，需要把这个目标让大家都理解，成为愿景。第二是分析能力：通过对行业机会发展把握来整合资源，形成行动的驱动力。第三是变革能力：通过学习机制来改变创业企业的关键知识开发领域。第四是整合能力：通过网络机制整合社会网络中的关键利益要素相关者。在这里可以考量一下马云。马云的愿景能力是相当强的，他的语言表达能力非常的好。他的分析能力表现在他对于行业的分析，他能够去把握住这个行业整体的发展脉搏。他的变革能力方面可以去考量一下阿里巴巴，他无论在技术创新上还是组织创业上都在进行不断的变革。以及他的资源整合能力，不仅仅表现在融资的整合能力，还表现在各种人才的整合能力上。那么当一个领导者具有这些能力的时候，他的创业团队的活动才会进行得比较有效、有序。&#8195;&#8195;那么再进一步，我们还会去考量创业团队领导力。加了“团队”两个字的意思就是说要考量几个人在一起，团队的整体的领导力如何。当企业发展壮大的时候，这个创业团队就可能成为高管团队，那么其领导力也会很大程度上决定企业的整体发展状况。在这里，我们同样从四个方面来进行描述。第一是风险共担的能力：当项目与实施遇到挫折的时候，是不是能够一起来分析原因；当遇到一些困难，没有取得预期的效果和收益的时候，是不是彼此不会相互指责。第二是分享认知：是不是彼此愿意采纳其他成员提供的有价值的新观点，愿意彼此采纳别人的不同意见，愿意把新的知识奉献出来让大家分享。第三是协作进取：大家是不是能够对外部环境的动态变化保持非常敏感的认知，能够比竞争对手更加重视市场开发机会，能够相互的共享信息资源，一起去进取，一起去合作。第四是集体创新：讨论问题的方式是不是喜欢用会议式的、分享式的或者头脑风暴的这种方式去进行决策，然后一起去商定多种资源，获取更加有效的方案。所以我们考量一个团队的领导力的时候，可以从这四个方面去考量，你和你的创业小伙伴们是不是能在这四个方面做的比较好。&#8195;&#8195;讲到这里，我们基本把创业活动这个小节讲完了。稍微小结一下。创业活动就是真实的实践，包括感知机会、组建创业团队、获取创业必需资源三类活动。创业活动中的领导力建设是创业成功与否的核心要素。&#8195;&#8195;这章节到此结束，谢谢大家。  \n创业团队创业团队的内涵&#8195;&#8195;同学们大家好，今天我们来给大家讲一下创业团队那些事儿。&#8195;&#8195;我们现在所处的是知识经济时代，对团队合作的要求越来越高。一个人的能力始终有限，单靠每个团队成员发挥“以一当十”的干劲是远远不够的，必须要提高自己团队的合作意识，对于创业团队而言更是如此。只有这样才能“三个臭皮匠，胜过诸葛亮”，使整个团队发挥出“以一当十”功效。马云就特别强调团队的力量。他在央视的《赢在中国》忠诚告诫过创业选手：“没有什么可以忌讳的。你们公司的核心竞争力就是你和你的团队，不要有什么难为情。”&#8195;&#8195;这边我们先给大家讲一个小故事，《三只老鼠偷喝牛奶》，希望给同学们带来一些启示。三只老鼠一同去偷牛奶喝，到了牛奶缸边一看：哇，缸里的牛奶只有底下一点点，并且缸身太高，谁也喝不到。于是它们集思广益，想出一个很棒的办法：一只老鼠咬着另一只老鼠的尾巴，吊到缸底去喝牛奶。他们取得一致的共识：大家轮流喝牛奶，有福共享，谁也不可以有自私独享的想法。第一只老鼠最先吊下去喝，它在下面想：“牛奶只有这么一点点，今天总算我幸运，可以喝一个饱。”第二只老鼠在中间想：“下面的牛奶是有限的，假如让它喝完了，我还有什么可喝的呢？还是放了它，自己跳下去喝吧。”第三只老鼠在上面缸边想：“牛奶那么少，等它俩喝饱还有我的份吗？不如早点放了它们，自己大饱口福吧。”于是第二只放了第一支的尾巴，第三只放了第二支的尾巴，都只管自己地争先恐后的跳下去。由于脚滑，缸深，结果它们都落在缸里，永远逃不出来了。&#8195;&#8195;马云对这个故事的评价是怎么样的呢？他说：“也许每一只老鼠都不希望有这样的结局，但是在这一结局之前它们为何就没想到呢？这就是自私的心理造成的后果。它们根本没有认识到团结合作的重要性，只想求得片刻的满足不顾及整体局面，将只会断送自己的前程和生命，而不可能有更好的结局。但很多公司中同样如此，团队信任与合作是至关重要的，而自私是团队信任的天敌。对于公司员工而言，也有不少员工目光短浅，为了个人私利，不顾公司和集体利益，利用公司资源炒单，或是收取回扣或贿赂，而失去公司的信任，断送了大好前程。优秀的团队精神人才是企业的核心竞争力。一个企业如果没有团队精神，将成为一盘散沙；一个民族如果没有团队精神，也将无所作为。相反，如果重视团队的力量，就能收到事半功倍的效果。”&#8195;&#8195;在创业途中，我们经常会听到一个词，“团队”。可以说，随着竞争的日趋激烈，团队的力量已经越来越受到企业和创业者的重视。因为这是一个团队的时代，所以要有高素质的创业团队，才可能创业成功。阿里巴巴的马云在自己的团队是一个教父级的人物。他用自己教父般的魅力，孜孜不倦在团队中传播着一种伟大的使命感和价值观，让这个团队里的每一个成员心往一处想，劲往一处使，拧成一股绳，牢牢地凝聚在一起。而一旦形成这样一种像磁场一样的强大凝聚力，马云就敢大胆的说：“天下没有人可以挖着我的团队成员。”团队创业的优势显而易见。我们常说：“一个篱笆三个桩，一个好汉三个帮。”一群志同道合的人齐心协力，各自拿出自己的优势来共同创业，所产生的群体智慧和能量，自然会大大超过个体的力量。&#8195;&#8195;那接下来我们就来讲述一下什么是创业团队，创业团队的内涵和作用又是什么呢？我们知道创业需要大量的资源，包括资金、设备、空间以及信息等。为了有效吸收外部资源，以团队的形式来创业各个团队成员及其不同的背景、经验以及社会关系，可以为创业活动带来多样化的资源。同时，团队也可以共同承担风险，降低企业失败的可能性。出于这些因素，现代的创业活动已不是一种追求个人英雄表现的行为了。成功的创业个案大多与团队运作密切相关。例如阿里巴巴的十八罗汉；新东方俞敏洪、徐小平、王强三人团队“十年磨一剑”，把一个始于违章建筑危楼里的培训学校打造成市值50亿美元的上市公司。&#8195;&#8195;所以创业成功有两样东西必不可少，一个是创意，一个是团队。&#8195;&#8195;让我们首先了解创业团队的内涵以及与创业活动的关系。团队，又叫team，不同的学者从不同的角度界定了它的含义。比较有代表性的学者路易斯就认为，团队是由一群认同并且致力于去达成某一共同目标的人所组成。这一群人相处愉快并乐于工作在一起，共同为高品质的结果而努力。在这个定义中，路易斯强调三个重点：共同目标、工作相处愉快和高品质的结果。我们依据大家观点，认为创业团队就是在创业初期（包括企业成立和成立早期），由一群才能互补、责任担当、愿为共同的创业目标而奋斗的人所组成的特殊群体。那么狭义的创业团体是指什么呢？狭义的创业团体是有着共同目标、共享创业利益、共担创业风险的一群创建新企业的人。广义的创业团队不仅包括狭义创业团队，还包括与创业过程有关的各种利益相关者，比如说风险投资家、专家顾问等的团队优势。&#8195;&#8195;那接下来大家可能要问那团队是不是群体呢？答案是No。团队team，是有一群有着共同目标、有着分工而又协同的人群形成的战斗团体。团队不同于群体group，群体可能只是一群乌合之众，并不具备高度战斗力，如羊群是群体，但是它不是团队，而狼群就是团队。具体而言，他们的差别在以下几个方面。第一，团队成员对是否完成团队目标承担成败责任，并同时承担个人责任，而群体成员则承担个人成败责任。其次第二点，团队的绩效评估与团队整体表现为依据，而群体绩效评估则是以个人表现为依据。第三，团队目标实现需要成员间彼此协调且相互依存，而群体目标却不需要成员间的相互依存性。最后一点，团队与群体的区别在于团队较之群体在信息共享、角色定位、参与决策等方面也进了一步。&#8195;&#8195;那这一讲的知识点我们已经讲完了。相信大家对什么是创业团队、创业团队的内涵已经有所了解了，而且也应该知道团队和群体的差别所在了。  \n创业团队的意识&#8195;&#8195;接下来知识点，我们将关注一下创业团队的意识。&#8195;&#8195;我们知道，作为团队必须满足自主性、思考性以及合作性三个条件。为了让团队目标的达成，成功的团队应该形成五种思想意识，也就是目标意识、集体意识、服务意识、竞争意识和危机意识。接下来我们一一给大家来讲述一下。&#8195;&#8195;首先第一个，目标意识。那么目标意识是什么呢？那就是需要我们强调目标到人，团队中每个人必须有明确的目标；强调个人目标与团队目标相结合，除了要完成项目任务之外，每个人还应该有明确的自身发展目标，并且将自己的发展目标和团队大目标有效的结合起来；强调各成员的责任心，按要求达到目标，需要每个成员高度的责任心。&#8195;&#8195;第二个，集体意识。要求我们形成集体成功观，将个人的成功融入集体的成功之中。另外，团队中形成有效的沟通文化，使团队中所有成员可以及时有效地沟通，相互理解。当团队中出现意见分歧的时候，分歧双方的基本态度应该是说服对方，而非强制对方。裁决两种不同意见的唯一标准，那就是看哪一种意见更有利于推动团队活动的正常进行。&#8195;&#8195;第三个，服务意识。服务有面向客户的服务和面向团队内部的服务。团队成员应该追求客户满意这一目标，而非技术高难、业界一流等指标，团队成员面向客户的态度，可以决定团队目标的成败。团队成员还需要具有面向团队内部的一个服务，具有完备的服务意识，才有精诚合作的可能。&#8195;&#8195;第四个，竞争意识。因为引入竞争机制，形成人人都努力向前的团队氛围，使贡献大、责任大的成员得到丰厚的报酬，这也是一个良好的风向标，从而形成良好的导向。&#8195;&#8195;最后一个是危机意识。看到人与人之间的差距，意识到环境的压力感，受到行业、市场的危机。居安思危，让团队和个人始终保持这种危机感。团队成员要清醒地认识到竞争对手正在虎视眈眈地盯着我们。在这种意识下，有助于团队维系其团结，长久地立于不败之地。&#8195;&#8195;那大家创业，总是想少走弯路。而一个好的创业团队对新创科技型企业的成功起着举足轻重的作用。新型风险企业的发展潜力与企业管理团队的素质有着十分紧密的关系。一个喜欢独立奋斗的创业者固然可以谋生，然而一个团队的营造者却能够构建出一个组织或一个公司，而且是一个能够创造重要价值并有益选择权的公司，创业团队的凝聚力、合作精神、立足长远的敬业精神会帮助新创企业渡过危难时刻，加快成长步伐。另外，团队成员之间的互补、协调以及与创业者之间的补充和平衡，对新创科技型企业起到了降低管理风险、提高管理水平的作用。大家熟悉的“腾讯五虎将”（马化腾、张志东、曾李青、许晨晔、陈一舟）、“百度七剑客”（李彦宏、徐勇、刘建国、郭眈、雷鸣、王啸、崔珊珊）、“阿里十八罗汉”（马云、孙彤宇、蔡崇信、彭蕾、张瑛等）等就是最好的佐证，就是创业团队的魅力所在。&#8195;&#8195;这个知识点，我们讲了一下创业团队应该有哪些意识，相信大家已经有所了解了。  \n创业团队的角色&#8195;&#8195;那一个完美的团队需要配备怎样的角色呢？学者们各有观点。我们就举一个有趣的例子来体验一下。《西游记》大家应该还蛮熟悉的吧。唐僧团队最大的好处就是互补性，领导有权威、有目标、有坚定的毅力。这个团队是个非常成功的团队，虽然历经九九八十一磨难，但最后修成了正果。阿里巴巴的总裁马云就非常欣赏唐僧团队，认为一个理想的团队就应该有这四种角色。&#8195;&#8195;一个坚强的团队，基本上要有四种人：德者、能者、智者、老者。德者领导团队，能者攻克难关，智者出谋划策，老者执行有力。&#8195;&#8195;德者居上。唐僧是一个目标坚定、品德高尚的人。他受唐王之命，去西天求取真经，以普渡众生，广播善缘。要说降妖伏魔他没有这个本事，但为什么他能够担任西天取经如此大任的团队领导呢？关键在于唐僧目光远大，目标明确，有组织设计能力，注重行为规范和工作的高标准。你看他的紧箍咒，如果唐僧没有紧箍咒，估计早被孙悟空一棒打死，或者使唤不动他。这也是领导的必备技能，一定要树立自己的权威，没有权威，也就无法成为领导。但是唐僧从来不滥用自己的权力，只有在大是大非的时候，才动用自己的惩罚权，所以他担任了团队的主管。如果这个团队中没有唐僧这个完美型角色，这样的团队就是一群乌合之众，不会有什么远大的前程。&#8195;&#8195;接下来我们来谈谈孙悟空。能者居前。孙悟空可称得上是老板最喜欢的职业经理人。之所以说老板最喜欢，不是因为孙悟空没缺点，很优秀，而是因为他能力很强，但有缺点。假设一个人能力很强，人缘很好，理想又很远大，这样的人往往不甘人下，或者直逼领导位子，或者很容易另起炉灶。而孙悟空有个性、有想法、干劲十足，崇尚行动，及时解决问题，执行力很强，注重工作的结果，能够迅速理解和完成当前团队的任务，是团队的业务骨干，也很敬业、重感情，懂得知恩图报，是个非常优秀的人才。如果一个团队中没有孙悟空，唐僧的远大抱负将很可能化为泡影。但孙悟空这样的员工只能是一个好员工，不能成为一个好领导，什么意思呢？孙悟空最大的乐趣是降妖伏魔，常说“抓几个妖怪玩玩”，这是一种工作狂的表现。他不近女色、不恋钱财、不惧劳苦，在降妖伏魔中找到了无限的乐趣。但是他天性顽皮、直言不讳，经常把玉皇大帝、各大神仙都不放到眼里，注定他无法成为一个卓越的领导。但作为一个团队的成员，有了唐僧，就不需要孙悟空有领导能力，否则唐僧的地位肯定要受到动摇。这也就是为什么团队成员的选择要非常慎重，要能够优势互补、能力互补、个性互补。孙悟空的另外一个缺点就是爱卖弄，有了业绩就在别人面前显摆显摆，而且得理不让人，这显然也影响了他继续发展的可能。作为一个领导，一定要非常清楚下属的优缺点，量才而用，人尽其才。之所以孙悟空是能者、力量型的角色，但是他不适合做领导。&#8195;&#8195;第三就是活泼型的猪八戒。他热情奔放、感情外露，善于制造工作气氛，他承担了团队的公共关系工作。他帮助每一位同事，并使工作变得有趣。他虽然总是开小差，吃得多、做得少，时时不忘香食，但是在大是大非上，立场还是比较坚定，从不与妖精退让妥协，打起妖怪来也不心慈手软。生活上能够随遇而安，工资待遇要求少，有的吃就行，甭管什么东西。而且容易满足，最后被佛祖封了个净坛使者，是个受用贡品的闲职，但他非常高兴说：“还是佛祖向着我。”更为重要的是，他成为西天枯燥旅途的开心果，孙悟空不开心了，就拿他耍耍，有些脏累差的活都交给他，他虽有怨言，但也能完成。如果没有猪八戒这个旅途还真无聊。另外，猪八戒的另外一个优点就是对唐僧非常的尊敬，孙悟空有不对的地方，他都直言不讳。从某种程度上也增加了唐僧作为领导的协调和管理作用。当然了，他也经常搬弄是非，背后打小报告。另外，在忠诚度方面也差，尤其是刚加入取经团队的时候，动不动就要散伙走人回高老庄娶媳妇，一点佛心都没有，而且影响了团队的团结和睦但是如果一个团队中没有猪八戒，这个团队将感到工作枯燥无味。之所以说猪八戒是个智者，完全是站在当今社会的角度。现代社会，员工的压力都很大。如何做一个快乐的人，就要用猪八戒的人生哲学了。当然，八戒的人生哲学，只是我们在遇到挫折失败时候的一种自我解脱，不能成为自己的主流价值观。&#8195;&#8195;最后一个和平型的沙和尚。沙僧平和、冷静、有耐心，承担了团队的事务性工作。沙僧包括白龙马是接近领导的工作人员。做大老板，手下各路“神仙”应该样样都有，智者提供智力服务，能者提供工作业绩，劳者提供后勤保障。沙僧和白龙马的后勤保障非常出色，如果说智者猪八戒和能者孙悟空还有缺陷的话，那么劳者沙僧完全可以打100分。劳者大多在领导身边的机会很多，最难做到的就是“观棋不语”。沙僧同志做到了，是非常难能可贵的。事实证明，他能够胜任这份工作并且持之以恒，而且能够在压力下保持冷静。别看他默默无闻，可每次到了最后关头都是靠他来稳定局面。&#8195;&#8195;所以我们说观音为唐僧配备的人才少而精，并建立了有效的制约机制。唐僧直接管理孙悟空，但只能在孙悟空突破底线时才动用紧箍咒，平时则让其充分发挥能动作用；孙悟空对猪八戒在具体工作上有管理权力，但他也限制不了猪八戒的言论自由，他自己的行为反而受到猪八戒的舆论监督；猪八戒虽然有“散伙回家”的思想，但有孙悟空的金箍棒，思想不能转化为行动；沙和尚作为后勤人员，关键时刻协调各方关系，起到很好的作用，而许多企业和团队之所以能够兴旺发达，就在于后勤保障有力，能取得事半功倍的效果。&#8195;&#8195;从这个故事，我们知道，有效的团队需要有不同性格的成员，而每一种性格都有其不可替代的优势，但同时也无法取代别人的长处。而以后每位同学都属于企业团队或者自行创业的一份子，你可知道自己是属于哪一类型的成员，你的长处和优势是什么了吗？&#8195;&#8195;这个知识点我们已经讲述完毕。  \n创业的5P模型与一般构成&#8195;&#8195;我们从之前创业团队的定义可以看出，创业团队需要具备五个重要的团队组成因素：目标Purpose、人员People、定位Place、权力Power、计划Plan。由于其英文单词的首个字母都是P，因此这五个要素被称为5P模型。具体我们分析一下什么是5P模型。&#8195;&#8195;第一，目标Purpose。创业团队的存在使得创业活动中各项事务依靠团队来运作而不是依靠个人。创业团队应该有一个既定的创业目标，该创业目标应成为团队共同的奋斗理想。缺乏共同的目标使得团队没有凝聚力，即使团队能够为了解决生存问题暂时走到一起，一旦没有生存的压力，团队成员就会分崩离析，这种分裂对于新创企业是致命的。因此，创业团队应该有一个既定的共同目标，为团队成员导航，知道要向何处去。目标在创业企业的管理中以创业企业的远景、战略的形式体现。&#8195;&#8195;第二，人员People。人是构成创业团队最核心的力量。三个及三个以上的人就形成一个群体，当群体有共同奋斗的目标就形成了团队，在一个创业团队中，人力资源是所有创业资源中最活跃、最重要的资源。应充分调动创业者的各种资源和能力，将人力资源进一步转化为人力资本。目标是通过人员来实现的，所以人员的选择是创业团队中非常重要的一个部分。在一个团队中可能需要有人出主意；有人定计划；有人实施；有人协调不同的人一起去工作；还有人去监督创业团队工作的进展，评价创业团队最终的贡献。不同的人通过分工来共同完成创业团队的目标。在人员选择方面要考虑人员的能力如何，技能如何互补，人员的经验如何。下面将利用角色定位的理论对团队成员各自承担的任务所起的作用进一步讨论。&#8195;&#8195;第三，创业团队的定位Place。创业团队的定位包括两层意思。一是创业团队的定位。创业团队在企业中处于什么位置，由谁选择和决定团队的成员，创业团队最终应对谁负责，创业团队采取什么方式激励下属。二是个体（创业者自身）的定位。作为成员在创业团队中扮演什么角色，是制定计划还是具体实施或评估，是大家共同出资，委派某个人参与管理，还是大家共同出资共同参与管理，或者是共同出资并聘请第三方（职业经理人）管理。这体现在创业实体的组织形式上，是合伙企业或是公司制企业。&#8195;&#8195;第四，权利Power。为了实现创业团队成员的良好合作，赋予每个成员一定的权力是必要的。在创业团队当中有两种权力。一是团队领导人的权力，团队领导人的权力大小与创业团队的发展阶段相关。一般来说，在创业团队发展初期，领导权相对比较集中，而团队越成熟，领导者拥有的权力相应越小。二是团队权力。要确定整个团队在组织中拥有什么决定权，比方说，财务决定权、人事决定权等等。&#8195;&#8195;最后一个，计划Plan。计划是创业团队未来的发展规划，也是目标和定位的具体表现。在计划的帮助下，创业者能够有效制定创业团队短期目标和长期目标，能够提出目标的实施方案，以及实施过程的控制和调整措施。只有在计划的操作下创业团队才会一步一步地贴近目标，从而最终实现目标。结合上述要素，一般创业团队由4个部分构成。首先是初始创建者：一些由于受教育程度创业经历、产业经验、社会网络关系影响下聚集在一起的创业者。二是核心员工：经猎头公司、人才市场、媒体广或者熟人介绍而进入公司，能够帮助企业实现公司战略目标和保持、提高公司竞争优势，或能够直接帮助主管提高管理业务能力、经营能力和抵御企业管理风险能力的员工。核心员工一般具有较高的知识或技能，对企业的发展至关重要，是各大企业争夺的目标。三是董事会：董事会保证公司战略目标的实现和经营决策的有效性，对高层院里团队进行选拔、监督和激励。这也是有效连接企业所有者与经营者利益，保证公司战略目标与经营者实践之间的一贯性，确保公司管理与运营处于正确的轨道之上的关键。四是专业顾问：专业顾问包括顾问委员会、投资者和贷款方、咨询师，能保证公司在各个环节有效率地开展实现公司利益最大化。&#8195;&#8195;这一节的知识点，我们主要关注了创业团队的5P模型和创业团队的一般构成。那么下一个知识点我们跟大家讲一下创业团队怎样来组建和怎样来开发。  \n创业团队的组建与开发&#8195;&#8195;那既然团队作用这么大，我们又基于什么原则来组建创业团队呢？这边我们简单介绍一下创业团队组建的原则。&#8195;&#8195;首先第一个，目标明确合理原则。目标必须明确，这样才能使团队成员清楚地认识到共同的奋斗方向是什么。与此同时，目标也必须是合理的、切实可行的，这样才能真正达到激励的目的。&#8195;&#8195;有了目标，接下来我们就要选成员了。那成员是怎么选择呢？我们要基于互补原则。创业者之所以寻求团队合作，其目的就在于弥补创业目标与自身能力间的差距。只有当团队成员相互间在知识、技能经验等方面实现互补时，才有可能通过相互协作发挥出“1+1&gt;2”的协同效应。&#8195;&#8195;第三个是精简高效原则。为了减少创业期的运作成本，最大比例地分享成果，创业团队人员构成应在保证企业能高效运作的前提下尽量精简。&#8195;&#8195;第四是动态开放原则。创业过程是一个充满了不确定性的过程。团队中可能因为能力、观念等多种原因不断有人在离开，同时也有人在要求加入。因此，在组建团队时，应注意保持团队的动态性和开放性，使真正完美匹配的人员能被吸纳到创业团队中来。&#8195;&#8195;讲了这么多，大家想，创业团队的内涵、作用、五要素、组建的原则我们已经初步了解，那接下来是不是想跃跃欲试，如何把创业团队组建起来，有没有一个现成完美的公式或者神奇宝典呢？显然啊，这一问题没有任何现成的神奇公式。创业团队成员能够走在一起，取决于人与人之间的协调和投缘。尽管如此，为了打造一个有向心力的良好团队，创业者也可以适当遵循一些通行的步骤来组建创业团队。&#8195;&#8195;第一，要明确创业的一个目标。创业团队的总目标就是要通过完成创业阶段的技术、市场、规划、组织、管理等各项工作实现企业从无到有、从起步到成熟。总目标确定之后，为了推动团队最终实现创业目标，再将总目标加以分解，设定若干个可行的、阶段性的子目标。&#8195;&#8195;第二，撰写创业计划书。在确定了一个个阶段性子目标以及总目标之后，紧接着就要研究如何实现这些目标，这就需要制定周密的创业计划。创业计划是在对创业目标进行具体分解的基础上，以团队为整体来考虑的计划，创业计划确定了在不同的创业阶段需要完成的阶段性任务，通过逐步实现这些阶段性目标来最终实现创业目标。&#8195;&#8195;第三，招募合适的人员。招募合适的人员也是创业团队组建最关键的一步。关于创业团队成员的招募，主要应考虑两个方面。一是考虑互补性：既考虑其能否与其他成员在能力或技术上形成互补。这种互补性形成既有助于强化团队成员间彼此的合作，又能保证整个团队的战斗力，更好地发挥团队的作用。一般而言，创业团队至少需要管理、技术和营销三个方面的人才。只有这三个方面的人才形成良好的沟通协作关系后，创业团队才可能实现稳定高效。二是考虑适度规模：适度的团队规模是保证团队高效运作的重要条件。团队成员太少则无法实现团队的功能和优势，而过多又可能会产生交流的障碍，团队很可能会分裂成许多较小的团体，进而大大削弱团队的凝聚力。一般认为，创业团队的规模控制在2到12人最佳。&#8195;&#8195;第四，职权的划分。有了人员，为了保证团队成员执行创业计划、顺利开展各项工作，必须对现在团队内部进行职权的划分。创业团队的职权划分就是根据执行创业计划的需要，具体确定每个团队成员所要担负的职责以及相应所享有的权限。团队成员间职权划分必须明确，既要避免职权的重叠与交叉，又要避免无人承担造成工作上的疏漏。此外，由于还处于创业过程中，面临的创业环境又是动态复杂的，不断会出现新的问题，团队成员可能不断出现更换，因此创业团队成员的职权也应根据需要不断地进行调整。&#8195;&#8195;第五，构建创业团队制度体系。创业团队制度体系体现了创业团队对成员的控制和激励能力，主要包括了团队的各种约束制度和各种激励制度。一方面，创业团队通过各种约束制度（比如纪律条例，组织条例，财务和保密条例等）指导其成员避免做出不利于团队发展的行为，实现对其行为进行有效地约束、保证团队的稳定秩序。另一方面，创业团队要实现高效运作需要有效的激励机制（包括利益分配方案、奖惩制度、考核标准、激励措施等）使团队成员看到随着创业目标的实现，其自身利益将会得到怎样的改变，从而达到充分调动成员的积极性，最大限度发挥团队成员作用的目的。要实现有效地激励首先就必须把成员的收益模式界定清楚，尤其是关于股权、奖惩等与团队成员利益密切相关的事宜。需要注意的是，创业团队的制度体系应以规范化的书面形式确定下来，以免带来不必要的混乱。&#8195;&#8195;第六，团队的调整融合。完美组合的创业团队并非一开始就能建立起来的，很多时候是在企业创立一定时间以后随着企业的发展逐步形成的。随着团队的运作，团队组建是在人员匹配、制度设计、职权划分等方面的不合理之处会逐渐暴露出来，这时就需要对团队进行调整融合。由于问题的暴露需要一个过程，因此团队调整融合也应该是一个动态持续的过程，那么在团队调整融合的过程中，最为重要的是要保证团队成员间经常进行有效的沟通与协调，培养强化团队精神，提升团队士气。&#8195;&#8195;这里我们尤其要重点讲一下第三个步骤，招募合适的人员，即创业团队的人员选择问题。创业团队必须在创业前就慎重选择成员。第一，要考察他加入的目的：团队成员是基于哪个需要层次而加入团队的，对他在组织中的行为方式，起着决定性的一个作用。因此，在组建团队的时候。要考虑那些有志于创业、关注企业未来发展、目标远大的合作伙伴。第二，要考虑成员的知识结构：在一支创业团队当中，成员的知识结构越合理，创业的成功概率就越大。纯粹由技术人员组成的创业团队，容易形成技术为王、产品为主的状况，从而使产品的研发到生产与市场脱节；全部由市场营销人员组成的创业团队，则会缺乏对技术的领悟力和敏感性，容易迷失发展方向。因此，创业团队在成员选择上一定要充分注意人员的知识结构，兼容技术开发、企业管理、市场营销等等不同的方面。其次，要兼顾兴趣爱好。创业团队在形成的时候，往往会被美好的创业前景所吸引，而忽略成员的个性特征。创业初期，大家同甘共苦，共患难，怀着满腔的热情而工作。团队成员在性格上的差异和处理问题的不同态度，很容易被掩盖。一旦企业发展到某个阶段的时候，由于个性冲突而导致的矛盾就会激化，使创业团队出现裂痕。所以在选择创业伙伴的时候，应该仔细判断慎重选择。最后我们要考虑的还有成员的价值观念，三观是否一致。创业团队成员的价值观和道德品质决定的企业文化形成。企业文化的源头是企业创始人自身的价值观念的体现。创业团队形成之前，成员之间必须通过深入的交流和充分的了解，只有价值观相近的人在一起组成的团队，企业才能发展得更好。&#8195;&#8195;这一节的知识点我们已经讲述完了。下一节我们将结合案例来讲一下创业团队。  \n创业团队的案例分析&#8195;&#8195;我们知道梦想是美丽的，实现梦想则需要更多的付出。如果不努力，梦想怎么能实现呢？所以我们要努力，说不定梦想就实现了呢。最后，我们结合案例来分析创业团队的相关知识点。&#8195;&#8195;大家知道要建造一流的非学历教育机构，单靠自己一个人是不够的，得有一支优秀的团队。而创业团队管理的关键是如何将创业团队成员各自的专用型资产整合成“共有专用型资产”，整合大家的意愿和力量。团队创业像一场足球赛，球星固然重要，更重要的是能否发挥集体的优势。&#8195;&#8195;新东方的创业团队可谓是典型的案例。&#8195;&#8195;俞敏洪，1962年10月出生于江苏江阴，1980年考入北京大学西语系，毕业后留校担任北京大学外语系教师，1991年9月，俞敏洪从北京大学辞职，开始自己的创业生涯。1993年，俞敏洪创办了新东方培训学校。创业一开始，俞敏洪单枪匹马，仅有一个不足十平方米的漏风的办公室。零下十几度的天气，自己拎着浆糊桶到大街上张贴广告，招揽学员。“任何事情都是你不断努力去做的结果，当你碰到困难的时候，你不要把他想象成不可克服的困难，在这个世界上没有任何困难是不可克服的，只要你勇于去克服它！”正是凭借着这种不怕困难，勇于克服困难的精神，新东方不断发展壮大着。俞敏洪还把“从绝望中寻找希望”作为新东方的校训。&#8195;&#8195;1994年，俞敏洪已经投入20多万元，新东方已经有几千名学员，在北京也已经是一个响亮的牌子。他看到了一个巨大而诱人的教育市场。俞敏洪喜欢教书，他曾经说过：我这辈子什么都可以离开，就是不可以离开讲台。对教师职业的热爱和新东方的发展壮大，让他决定他不仅要做个教师，一个校长，还要做一个教育家。在新东方创办之前，北京已经有三、四所同类学校，参加新东方培训的多是以出囯留学为目的。新东方能做到的，其他学校也能做到。就当时的大环境而言，随着出国热，以及人们在工作、学习、晋升等方面对英语的多样化要求，国内掀起了学习英语的热潮，越来越多的优秀教师加入到英语培训这个行业。如何先人一步，取得自己的竞争优势，把新东方做大做强，俞敏洪认识到英语培训行业必须要具备一流的师资。培训学校普遍做不大，是有原因的：由于对个别讲师的过分倚重，每个讲师都可以开一个公司，但是每个公司都做的不大。所以，俞敏洪需要找到更多的合作伙伴，帮他控制住英语培训各个环节的质量。而这样的人，不仅要有过硬的专业知识和能力，更要和俞敏洪本人有共同的办学理念。他首先想到的是远在美国的王强、加拿大的徐小平等人，实际上这也是俞敏洪思考了很久所做的决定——这些人不仅符合业务扩展的要求，更重要的是这些人作为自己在北大时期的同学、好友，在思维上有着定的共性，肯定比其他人能更好地理解并认同自己的办学理念，合作也会更坚固和长久。&#8195;&#8195;这时，他遇到了一个与他有着共同梦想、惺惺相惜的朋友，杜子华。杜子华像一个漂泊的游侠，研究生毕业后游历了美国、法国和加拿大，凭着对外语的透彻领悟和灵活运用，在国外结交了许多各色朋友，也得到了不少让人羡慕的机会。但是他在国外呆的时间越久，接触的人越多，就越是感觉到民族素质提高的重要和迫切。要提高一个人、一个民族的素质唯有投资教育。1994年在北京做培训的杜子华接到了俞敏洪的电话。几天后，两个同样钟爱教育并有着共同梦想的“教育家”会面了。谈话中，俞敏洪讲述了新东方的创业和发展、未来的构想、自己的理想、对人才的渴望。这次会面改变了杜子华单打独斗实现教育梦想的生活，杜子华决定在新东方实现自己的追求和梦想。&#8195;&#8195;1995年，俞敏洪来到加拿大温哥华，找到曾在北大共事的朋友徐小平。这时的徐小平已经来到温哥华十年之久，生活稳定而富足。俞敏洪不经意的讲述自己创办新东方的经历，文雅而富有激情的徐小平突然激动起来：“敏洪，你真是创造了一个奇迹啊！就冲你那一千人的大课堂，我也要回国做点事！”随后，俞敏洪又来到美国，找到当时已经进入贝尔实验室工作的同学王强。1990年，王强凭借自己的教育背景，三年就拿下了计算机硕士学位，并成功进入著名的贝尔实验室，可以说是留学生中成功的典型。白天，王强陪着俞敏洪参观普林斯顿大学。让他震惊的是，只要碰上一个黑头发的中国留学生竟都会向俞敏洪叫一声“俞老师”，这里可是世界著名的大学啊。王强后来谈到这件事时说：“自己当时很震惊，受到了很大的刺激。”俞敏洪说：“你不妨回来吧，回国做点自己想做的事情”。就这样。徐小平和王强都站在了新东方的讲台上。1997年，俞敏洪的另一个同学包凡一也从加拿大赶回来加入了新东方。&#8195;&#8195;新东方就像一个磁场，凝聚起一个个年轻的梦想。这群在不同土地上为了求学，洗过盘子、贴过广告、做过推销、当过保姆的年轻人，终于找到一个突破口，年轻人身上积蓄的需要爆发的能量在新东方充分得到了释放。就这样从1994年到2000年杜子华、徐小平、王强、胡敏、包凡一、何庆权、钱永强、周成刚等人陆续被俞敏洪网罗到新东方的门下。&#8195;&#8195;作为教育行业，师资构成了新东方的核心竞争力，但是如何让这支高精尖的队伍，最大程度的发挥作用？俞敏洪从学员需求出发，秉持着一种“比别人多做一点，比别人做得好一点”的朴素的创新思维，合理架构自己的团队，寻找和抓住英语培训市场上别人不能提供或者忽略的服务，使新东方的业务体系得以不断完善。比如，当时新东方就开辟了一块由一个加拿大人主持的出国咨询业务。学员可以就近咨询，获得包括基本申请步骤、各个国家对待留学生的区别、各个大学颁发奖学金的流程和决策有何不同、读研究生和读博士生的区别在什么地方等必要知识。1995年，俞敏洪逐渐意识到，学生们对于英语培训的需求已经不只限于出国考试。比如，1995年加入新东方的胡敏就应这种需求开发出了雅思英语考试培训，大受欢迎。胡敏本人也因此被称为“胡雅思”。徐小平、王强、包凡一、钱永强等人也分别在出国咨询、基础英语、出版、网络等领域各尽所能，为新东方搭起了一条顺畅的产品链：徐小平开设的美国签证哲学课，把出国留学过程中，大家关心的重要程序问题，上升到一种人生哲学的高度，让学员在会心大笑中思路大开；王强开设的美语思维训练法，突破了一对一的口语训练模式；杜子华的电影试听培训法，已经成为国内外语教学培训极有影响力的教学方法。新东方的老师很多都根据自己教学中的经验和心得著书立说，并形成自身独有的特色，让新东方成为一个有思想有创造力的地方。&#8195;&#8195;俞敏洪的成功之处是为新东方组建了一支年轻而又充满激情和智慧的团队，俞敏洪的温厚、王强的爽直、徐小平的激情、杜子华的洒脱、包凡一的稳重，五个人的鲜明个性让新东方总是处在一种不甘平庸的氛围当中。&#8195;&#8195;谈到团队的组建，《西游记》中由唐僧率领的取经团队被公认为是支“黃金组合”的创业团队。四个人的性格各不相同，却又同时有着不可替代的优势。唐僧慈悲为怀，使命感很好，有组织设计能力，注重行为规范和工作标准，所以他担任团队的主管是团队的核心；孙悟空武功高强，是取经路上的先行者，能迅速理解、完成任务，是团队业务骨干和铁腕人物；猪八戒看似实力不强又好吃懒做，但是他善于活跃工作气氛，使取经之旅不至于太沉闷；沙僧勤恳踏实，平时默默无闻，关键时刻他能稳如泰山，稳定局面。&#8195;&#8195;但是，创业路上并没有那么巧的机缘和条件，能幸运地集聚到这样四个不同性格的人。所以，如果只能从这四个人中挑选出两个人来作为创业成员的话，你会挑选哪两位？在一次活动中，牛根生客串主持人，向马云和俞敏洪提出了这样的问题。俞敏洪选沙僧和孙悟空，马云选择了沙僧和猪八戒。两人都选择了耿直忠厚的沙僧，但是关于另一个人选，两人的选择却很有意思。马云这样解释他为什么选择猪八戒：“最适合做领袖的当然是唐僧，但创业是孤独寂寞的，要不断温暖自己，用左手温暖右手，还要一路幽默，给自己和团队打气，因此我很希望在创业过程中有猪八戒这样的伴侣。当然，猪八戒做领导是很欠缺的，但大部分的创业团队都需要猪八戒这样的人。”俞敏洪不赞同马云的选择，他认为猪八戒不适合当一个创业伙伴。猪八戒是很能搞活气氛，让周围的人轻松起来，但是缺点也很突出，就是不坚定，需要领袖带着才能往前走。而且猪八戒既然没信念，哪好就会去哪，哪有好吃的就往哪去，很容易在创业过程中发生偏移，企业有钱时会大赚一笔后离开，企业没钱时也很可能会弃企业而去。而孙悟空就不会这样，他是一个很理想的创业成员。俞敏洪列举了他的理由：孙悟空的优点很明显，第一，有理念，知道取经就是使命，不管受到多大的委屈，都要坚持下去；第二，有忠诚，不管唐僧怎么折磨他都会帮助他一路走下去；第三，有头脑在许多艰难中会不断想办法解决；第四，有目光，能看到别人看不到的机会和磨难。当然，孙悟空也有很多个人的小毛病，会闹情绪，撂担子，所以需要唐僧必要时念念紧箍咒。但是，在取经路上，孙悟空所起到的作用是至关重要的。如果将西天取经比喻成一次创业过程，孙悟空就是其中不可或缺的创业成员。&#8195;&#8195;新东方的创业团队就有些类似于唐僧的取经团队。徐小平曾是俞敏洪在北大时的老师，王强、包凡一同是俞敏洪北京大学西语系80级的同班同学，王强是班长，包凡一是大学时代睡在俞敏洪上铺的兄弟。这些人个个都是能人、牛人。所以，新东方最初的创业成员，个个都是“孙悟空”，每个人都很有才华，而个性却都很独立。俞敏洪曾坦承：“论学问，王强出自书香门第，家里藏书超过5万册；论思想，包凡一擅长冷笑话；论特长，徐小平梦想用他沙哑的嗓音做校园民谣。他们都比我厉害。” 俞敏洪敢于选择这帮牛人作为创业伙伴，并且真的在一起做成了大事，成就了一个新东方传奇，从这一点来说，他是一个成功的创业团队领导者。他知道新东方人多是性情中人，从来不掩饰自己的情绪，也不愿迎合他人的想法，打交道都是直来直去，有话直说。因此，新东方形成了一种批判和宽容相结合的文化氛围。批判使新东方人敢于互相指责，纠正错误；宽容使新东方人在批判之后能够互相谅解互相合作。这就是新东方人的特点：大家互相之间不记仇、不记恨，只计较到底谁对、谁错、谁公正。这种源自北大精神的自由文化，是俞敏洪敢用“孙悟空”，而且是多个“孙悟空”的前提条件，这是新东方成功的关键因素之一。而另一个关键因素就是俞敏洪本人所具备的包容性，帮助他带领着帮比他厉害的“牛人”，不仅将新东方从小做大，还完成了让局外人都为之捏了一把汗的股权改制。最令人意料不到的是，俞敏洪居然还将新东方带到了美国的资本市场，成为中国第一个在海外成功上市的民营教育机构。这一份成绩虽然还不能定义为最终的胜利，但是仍然有着非同寻常的意义。它告诉了人们，对于中国教育来说，一切价值正有待重估。&#8195;&#8195;现在的创业不是靠个人英雄主义，而是靠团队。团队力量不是若干个体的简单相加，而是个体有机结合形成一种新的力量。只有优秀的团队才有优秀的个人，没有优秀的团体就没有优秀的个人。一个团队的业绩取决于最薄弱环节的改善程度与改善速度。企业的绩是所有部门工作结果的累积，一个部门的业绩为零相乘之后的结果就为零，不要让你或你的部门成为公司的零因子。&#8195;&#8195;最后总结一下今天的主旨。创业最直接的问题是要“创”的这个“业”是什么？这是项目选择的问题，也是创业过程的第一阶段，也是最重要的阶段。有了好项目不一定能成功，但没有好项目一定不能成功。而创业团队是大学生创业成功的关键所在。创业团队的凝聚力、合作精神、立足长远的敬业精神会帮助新创企业渡过危难时刻，加快成长步伐。另外，团队成员之间的互补、协调以及与创业者之间的补充和平衡，对新创企业起到了降低管理风险、提高管理水平的作用。大学生只有根据自己的特点找准“落脚点”，选择合适的创业团队才能闯出自己的一片新天地。&#8195;&#8195;那么这一章节的创业团队的知识点就到此结束。  \n创业机会创业机会及其类型&#8195;&#8195;同学们大家好。今天我们学习第五章创业机会。&#8195;&#8195;我们说，在创业过程当中寻找到一个合适的创业机会是非常重要的。也就是说，机会是创业成功的关键要素，那么怎么样去抓住机会？关键我们要认真的分析和了解机会，也就是所谓的“慧眼识珍珠”。其实我们说在创业过程当中可能会遇到许多的珍珠，关键是哪一颗珍珠，最有利于我们创业获得成功。这也就是我们今天主要学习的内容。在这一章，我们主要通过以下六个方面：创业机会以及创业机会的类型、创业机会的特征、创业机会识别的影响因素、创业机会识别的过程与技巧、创业机会的评价策略、创业机会的评价方法，来详细了解我们在创业过程当中如何去对创业机会呢进行认真地了解、分析以及评价。只有这样，我们才能够为我们创业取得成功奠定良好的基础。&#8195;&#8195;首先对于创业机会来说，它是种较为持久的、有吸引力的和适时的市场需求（或商务活动空间）并最终表现在为消费者或客户创造价值或增加价值的产品或服务供给过程中，同时能为创业者带来回报。一般我们认为创业机会应该是由三个部分构成的：第一个是创业机会，包含创业理念或者新企业想法；第二个方面是相信事物会产生有利的结果，或者相信创业理念或者新企业想法可能带来一个或更多的新产品或者新服务的产生；第三个方面，创业机会，它是有一系列具体的经济行为来完成最终的创业目标，创业机会也可以理解为一种商业机会或市场机会。通常来说，我们认为好的创业机会要符合五个方面的标准。首先第一个，要有利于实现我们推动的目标，也就是创业成功的目标；其次好的创业机会应该是存在某个市场的真实需求，也就是说消费者对于产品、服务，是有真实需求存在的（那么当然这一点，我想大家应该明白，如果没有需求，那我们的产品服务也就很难取得成功）；第三个方面，好的创业机会，也需要自身要有有效的资源和能力（可能我们都想做一件事，那么你有没有去做成这件事的资源和能力呢？在资源方面，比如像我们要有一定的人力资源，就像我们课程前面所介绍的要有创业团队。能力方面，包括我们的知识能力、我们的生理能力等等）；第四个方面，要有一定的市场竞争力（我们大家都知道，在这个社会，任何一个产品可能都会面临激烈的市场竞争，那么你的竞争力如何，这也是我们创业能否成功的一个关键因素）；最后一点，好的创业机会要能帮助收回创业成本，甚至于要能够获取理想的利润（如果这一点不能。保证的话，我们是也很难称得上是一个好的创业机会）。&#8195;&#8195;那么讲到创业机会，我们很容易联想到一个概念，也就是我们所说的创意。我们经常说“今天我有一个创意”、“我想去做什么”。那么在这，我们来看一看创意和创业机会是什么样的关系。通常，发现好的创意是识别创业机会的第一步创意即新的想法。这种新的想法是一种模糊的机会，这种模糊的机会如果具有明确的客户需求以及能给创业者带来利益，就有可能被开发成现实的产品或服务。我们也可以把它称之为是创业机会。所以，创业机会和创意可能在一定程度上会以实现转化。也就是说好的创意有可能带来成功。当然，光有好的创意也是不行的。好的创意仅是创业成功的一半。好的创意未必就能成为好的创业机会。事实上，新产品超过80%都是以失败告终的。有些创意看起来很美好，但经受不住市场的考验。如何将创意转化为创业机会？只有当创业收益超过成本，从而能够获取利润时，创意才能变成机会。这可以说是创意转变为创业机会的一个重要关键的因素。&#8195;&#8195;具体对于创业机会来说，有各种不同的类型。下面我们就来具体看看，可能会给我们带来创业机会的类型主要有哪一些。首先，我们从创业机会的可识别性来看。在这一点上可以把创业机会分为两大类，一类是显现创业机会，一类是潜在的创业机会。所谓的显现创业机会，也就是说，在市场上存在明显未被满足的需求，有些需求可能没有被充分满足。就像我们想要去买个东西的时候，可能你走到某一个商家，商家说这个东西卖完了、没有了；可能你走了很多商家都做没有，那么这个其实就是一种明显的、没有被满足的需求。第二类潜在的创业机会。那么所谓的潜在创业机会，也就是隐藏在某种需求背后的未被满足的需求。那么比如说，像20世纪80年代以来，我们国家化妆品市场日渐兴旺，我们很多女性甚至于很多男性现在也都有化妆需求，而这种需求呢啊。没有被充分的满足，可能大家都能够看到，那么这种就是一个显现的创业机会。而有一部分的创业者，他们找到了一个隐藏在化妆品市场背后的小市场。比如像工业护肤品细分市场，它主要是针对一些在高温场合、有毒的场所，还有像野外环境比较恶劣的场合下，对护肤的要求不同。那么这样一些创业者呢，针对这样一个潜在的创业机会，结果也获得了很大的成功。这是我们根据创业机会的可识别性来进行的分类。&#8195;&#8195;另外我们还可以根据创业机会的来源来进行分类。根据创业机会的来源可以分为行业创业机会和边缘创业机会。所谓的行业创业机会，它指的是出现在新企业经营领域内的创业机会。比如说一家企业是做钢铁冶炼的、是做计算机软件的，那么在其行业内出现的机会叫做行业创业机会。边缘创业机会指的是出现在不同的行业的交叉点、结合部的一些创业机会。如“太空殡葬业”、“中国铁画”、“药膳食品”等，这些都是处于不同行业的交叉边缘所出现的。&#8195;&#8195;第三个，我们根据创业机会影响时间来分，可以把创业机会分为两大类，一类叫做现实创业机会，一类叫做未来创业机会。现实创业机会是目前市场上存在的尚待满足的某种需求，当前就存在的。而未来的创业机会是目前市场上还没有或仅表现为少数人的消费需求，但预期在未来某段时间内会出现的大量需求。比如在20世纪60年代，像西欧和美国都热衷于制造大型的豪华汽车的时候，日本认为小型、低耗、低价的汽车会有比较大的市场需求。因此，日本汽车业开始着手研制小型汽车。到了80年代，日本小汽车已经在美国市场上形成了竞争优势，对当时美国的像福特、通用形成了巨大的冲击，也取得了很大的成功。&#8195;&#8195;其次我们还可以根据创业机会影响的空间来进行分类。根据创业机会影响空间来进行分类，我们可以分为全面的和局部的创业机会。所谓全面创业机会，指的是大范围内出现的未被满足的某种需求。这种大范围指的是全国的甚至是全球范围内的没有被满足的需求。那么这种创业机会，对创业者具有普遍意义，可能所有的创业者都能够受益。局部的创业机会指的是在某一时间、某一区域出现的未被满足的某种需求。那么这种局部，比如说只是我南京市，或者是我们南京市的江北新区甚至于只是在我们校园周边这样一个区域。那么这种局部的创业机会就只对进入该市场的创业者有特殊意义。比如说像1988年在温州的服装市场，出现了外国高档服装热。名牌进口西装，每一套可以卖到数千元，甚至上万元。如果其他城市的创业者都将此机会看作是全面创业机会，那么很可能会失败。因为这个创业机会可能只是针对温州这样一个特殊的区域。&#8195;&#8195;那么这就是我们对于创业机会的类型所进行的分类。对于创业机会及其类型，我们先讲到这，谢谢各位同学。  \n创业机会的特征1&#8195;&#8195;接下来我们看看创业机会具有哪些特征。作为一个好的创业机会，其具有的特征是多方面的。&#8195;&#8195;首先第一个，创业机会具有客观性。所谓客观性，也就是说，创业机会是不以我们人的主观意识而改变的。就像我们所说，机会对于大家都是均等的，而且都是现实存在的。无论是新企业有没有意识到，它都会客观存在于一定的市场环境当中。而且通常来说机会是多种多样的，多种机会同时并存。一个创业者没有能够发现的创业机会，有可能会被另外一个创业者捕捉和利用。就比如说现在我们的大学周边可能就会有各种各样的创业机会。像大家所熟知的眼镜店、奶茶店，创业者都是因为发现了这样一个创业机会，从而利用这样的创业机会。但是这个创业机会，即使没有去发现、利用它，它也是客观存在的。&#8195;&#8195;第二，创业机会具有偶然性。所谓的偶然性，是创业者没有办法去事先预见创业机会，没有预料到的、不定时的、意外发生的一些创业机会，可能还会相当多。也就是说，创业机会并不是每时每刻都显露。机会的发现具有一定的偶然性，关键是新企业要努力寻找，从市场环境变化的必然规律中预测和寻找创业机会。有可能一个不经意的过程当中，就能够发现一些新的创业机会。&#8195;&#8195;第三，创业机会还具有时代性的特征。所谓的时代性，就是时代性指各种机会打上的时代烙印和赋予的社会的、民族的、时期的色彩。就像我们现在很多同学一想到创业，首先就想着去做微商，就是因为我们现在这个社会出于移动互联网时代，微信大家运用得很多，所以说大多数都考虑到了这样一个时代的特性，运用微信这个渠道去开展创业。所以时代是创业机会的土壤，好的时代能孕育出大量的创业机会，为创业者或创业团队的成功创业提供了条件。像改革开放之前，那个时候是计划经济时代，没有市场，需求都是按照计划来进行分配。那么那个时候，对于创业者来讲，想要去创业，可能就没有相应的创业机会。而相反，现在信息社会网络时代，那么创业机会就有很多，这也给我们的创业成功提供了很好的保障。&#8195;&#8195;第四个方面，创业机会具有差异性的特征。创业机会在一定范围内对同类新企业是均等的，但不同新企业和创业者对同一创业机会的认识会产生差别。由于新企业和创业者的素质和能力不同，利用同一创业机会获益的可能性和大小也难免产生差异。就像马云在创业过程中，这样的创业机会可能很多人都看到了，但是他们有没有马云那样的素质、能力去抓住创业机会呢，这就很难说了。&#8195;&#8195;创业机会所具有的特征主要有这四个方面。好，谢谢各位同学。  \n创业机会的特征2&#8195;&#8195;各位同学大家好。接下来我们来看看创业机会识别的过程中有哪些影响因素.&#8195;&#8195;因为创业机会识别主要就是要从创意中去筛选出具有市场需求的创意，然后把它作为我们的创业机会，并付诸于创业实践。所以创业机会识别本质上是对市场需求的识别，由市场需求的复杂性、多元化和动态性，使得创业机会识别也成为个复杂的过程。在这个复杂的过程中，具体的影响因素主要有两大类。一类是内部影响因素，另外一类是外部影响因素。&#8195;&#8195;内部影响因素包括创业者和创业团队。对于创业者来说，其人格特征是一项会影响创业成败的关键因素。就像前面所说到的创业机会，有的人就能够抓住，能够成功，而对于有些人来讲，就很难成功。这跟每一个人的性格、知识、能力都是相关的。同时，创业过程中也需要具有相当的人脉基础。创业过程中也会遇到诸多的困难。这就需要创业者能够积累一定的人脉，而且去面对困难，解决困难的。其次，创业团队也是影响到创业机会能够取得成功的关键因素。我们现在做任何一项工作，可能单个人去做都很难取得成功。我们要有一个好的团队。当然，什么样叫好的团队呢？要有相当的凝聚力和战斗力。对于好的团队的评价标准，我们课程前面的相关内容中已经做了一定的介绍，这里就不再赘述了。&#8195;&#8195;影响到创业机会识别的外部因素，相对来说要更多一些，因为外部环境是纷繁、复杂的。&#8195;&#8195;首先，技术环境。技术的变化是最为剧烈的。技术进步，往往意味着创业机会的不断涌现。现在的IT技术，我们的手机、电脑更新换代的速度是非常快的，可能隔个半年、几个月，新一代的产品就会出现。像大家用到的手机前几年还是iPhone4，现在iPhone5、iPhone6、iPhone7都已经出现了。还有技术环境中，早年有一个产品，是湖北的一个产品叫做“红桃K”，它的创始人在创业之初，就运用了市场上早已存在的生命科学技术，这也是一项重要的技术，对它进行新的组合，开发出了当时可以说是红极一时的“红桃K” 补血产品，获得了巨大的成功。这就是创业机会中运用的技术的发展来取得成功的一个典型的范例。&#8195;&#8195;第二，市场环境。在现有的市场当中去发现创业机会，往往是创业者最先做出的选择。所谓现有的市场，比如说我们这个企业原来就是做计算机的、原来就是做手机的，那么这个市场有没有一些新的需求，消费者又有哪些新的需求没有得到满足，我们可以去进行一个充分的挖掘，挖掘出来以后，这也是我们创业能够取得成功的一个重要关键的因素。可以说，对现有市场的深入分析和认识，有助于创业者降低创业机会信息的搜寻成本，进而减少创业的风险，增加成功几率。所以大家在学习管理学的过程中，我们学到的一个概念叫做多元化、集团化。这个多元化和集团化并不是每一个企业都能够去做的，实行多元化和集团化可能也会面临相当大的风险。就比如说前几年有一个媒体去采访微软的比尔·盖茨，当时就问他说：“比尔·盖茨先生，你做电脑软件做的这么成功，为什么不卖电脑呢？”我们都知道，我们现在我们的电脑用的都是Windows操作系统，我们的应用软件用的都是包括Office，包括Word、Excel、PPT等，但是我们没有看到市场上有卖微软电脑的。大家知道比尔·盖茨先生怎么回答的？他的回答是“No，软的和硬的相差太大了。”也就是说，像比尔·盖茨这么有实力，这么有资源的人，都认为从电脑软件转变去做电脑硬件这个风险非常大，成功的概率对他来讲也是把握性不足，所以他不去做。对于现有市场去进行深入的分析和认识，这样才能提高创业成功的概率，更容易把握住机会。&#8195;&#8195;第三，经济环境。如何认识和把握国内外经济发展趋势与经济政策，是发掘和识别创业机会的关键方面。最近几年国内外的经济形势都不是太好，需求都是处于一个疲软、下降的趋势。那么在这种环境下，怎么样去创业成功，创业机会如何去把握住，这就显得至关重要。比如说在前几年，房地产行业处于一个快速发展的时期。这个过程当中，我们如果能够把握这个机会，做房地产，那么相对来说取得成功的概率就更高。而最近几年，特别是2017年以后，房地产市场遇到了比较严峻的挑战。如果我们现在再去做房地产，想要取得成功，这个挑战就更大了。再比如说，大家知道有一家保险公司的叫做泰康人寿。泰康人寿的创始人陈东升，他在当年选择保险业作为创业领域的时候，就是通过长期跟踪国际经济发展趋势来做出决定的。经过他的观察和研究，他发现凡是在美国流行的产品和服务，大致五年之后在中国也会流行起来。所以他发现人寿保险在美国，五年前、十年前是比较流行的，而且创业是比较容易成功的。所以，他提前在中国布局，从而确保了他后续的创业成功。&#8195;&#8195;好，对于创业机会识别的过程中具有哪些影响因素，主要就是这两大方面。谢谢各位同学。  \n创业机会识别的过程与技巧&#8195;&#8195;各位同学好，接下来我们看看创业机会识别的过程中，通常要经历哪些步骤，同时有哪些技巧需要掌握。&#8195;&#8195;在创业机会的识别过程中，第一步，掌握相应的信息。信息是多种多样的，有多个来源渠道的。&#8195;&#8195;首先，创业机会的信息主要可以通过消费者获取。创业机会的好与坏，新产品的市场大与小，消费者具有最终的决定权。创业者需要从消费者对新企业的产品评价甚至抱怨中获得创业机会的信息。消费者对现有的产品有哪些地方不满意？有哪些需求没有得到满足？所以现在很多企业在创业之前，首先要进行消费者调查的工作。我们很多同学也遇到过，别人拿一个问卷来让你来进行回答。这个其实就是对我们消费者通过问卷调查来发掘市场机会。&#8195;&#8195;第二，可以通过现有的企业。创业者对产业内现有企业的产品或服务进行追踪和评估，找出其存在的可能缺隙，从而有针对性地制定改良手段或者发掘产业内现有企业尚未涉足的领域。比如作为一家汽车的整车厂商，往往就能够提供零配件产业、物流业，甚至人力资源产业等创业机会。再比如说一家商场的开业，那可能就意味着周边地区的如餐饮业、娱乐业，甚至房地产业，这样一些配套产业的创业机会。&#8195;&#8195;第三，我们还可以通过政府机构来发掘创业机会。政府的发来吧和政策是创业者识别创业机会的指针，创业者更是要顺应法律和政策的动向去寻找和把我创业机会。比如政府电信管理部门对于3G、4G通信技术的发展规划，它就使得华为、中等这样一些通信产品厂商得到3G、4G等通信设备的良好发展机会，同时移动供应商像中国移动、中国联通、中国电信也可以很好的去发掘这样的机会。还有像我们国家现在推动的一带一路发展规划，很多企业也可以去把握这样的创业机会。像今年我们学校的互联网＋创业项目中有一个就是抓住了这样一带一路的机会去进行创业。第四个信息的来源渠道是研发机构。很多科研机构或者大学都拥有很强的研发能力，但缺乏产业化能力，创业者将其重新包装和推出，往往可以取得出人意料的效果。比如现在很多地方的政府也发现了这一点，像我们的南京原来的 “三二一”创业计划，现在的“创业南京”项目，都是推动研发机构和企业的开展合作，或者是研发机构自身人员来进行创业。还有现在江苏省的科技成果转化项目也是推动大学和企业来进行合作创业。同时，比如美国的施乐公司最早是提供一些像鼠标、复印机，还有以太网等等，是IT技术的发明者和标准的制定者，是个实力很强的公司。但是，它对于这些领域没有给予足够的重视，导致错失良机，反倒是像日本的佳能、美国的微软等这样一些企业，它们是后来者，但更好得利用了这些研究成果，在这些方面取得了比施乐更好的成绩。&#8195;&#8195;第二步，善于观察。&#8195;&#8195;第一个方面，我们要善于去观察他人的经验，善于去观察市场的竞争状况。虽说成功创业者的经验不能放之四海而皆准，但学习成功创业者的优点与长处却可以使其他创业者的思维更开阔，遇到创业机会也能更容易把握。成功的经验要学习，失败的经验一样也要去学习。说有一句话叫做“失败是成功之母”，别人怎么去失败，我们如何去避免这样的失败，这需要我们去充分地学习、分析他人的失败的经验和成功的经验。&#8195;&#8195;第二个方面，我们要善于观察市场竞争情况。观察分析潜在竞争者、替代品竞争者、行业内原有竞争者的基本情况。比如可以利用迈克尔·波特的五力模型，从五个方面来分析竞争。了解新企业是否能赢得赖以维持经营所需的足够数量客源、销售额，乃至利润。&#8195;&#8195;第三个方面，我们还要善于去观察创业机会的现实性。机会可能有很多，这个机会是否能够实现，它的可行性到底有多大呢？第一，观察自身是否拥有创业机会所需的关键资源和能力。观察人财物资源是不是能够足够支撑去创业。第二，观察自身是否能够“构建网络”，跨越“资源缺口”。虽然说没有资源，但是可不可以通过一定的方法去弥补资源缺口？比如可以借助他人的力量、资源，弥补自身的缺陷。&#8195;&#8195;第四个方面，观察利用特定机会存在的风险是否是可以承受的。通常说机会与风险是并存的，机会越大，所面临的风险也越大。那么一旦出现风险，是否可以承受，也是必须要考虑和观察的。&#8195;&#8195;第三步，及时捕捉机会。机会出现了，能不能够把握住，如何去捕捉？&#8195;&#8195;首先要从市场供求差异中去捕捉创业机会。市场需求总量与供应总量的差额是企业可以捕捉的创业机会。假如城市家庭中洗衣机的市场需求总量为100%，而市场供应量只有70%，那么，对企业来说就有30%的机会可供选择和开拓。同时，产品的市场供应结构和需求结构的差异，也是企业可以捕捉到的机会。大多数产品在供应结构和需求结构上都是存在差异的。比如最简单地分类，可以把供求结构分为三大类：高档需求、中档需求和低档需求。虽然说总的需求可能已经满足了，但是在一些层次上，在一些结构中可能没有得到满足，那我们可以去把握住这样的一些机会。甚至，我们可以进行更加细化的分类，比如我们学过马斯洛的需求层次里，消费者的需求层次是不同的。有一些消费水平极高，社会上却没有可供消费的高档商品、服务。如果能够把握做的话，也能够给创业带来成功。比如天价年夜饭的出现就是一个对市场需求的满足。同时还有的消费水平低，但社会忽视了他们的需求，低档商品缺乏。比如我们都知道，非洲有很多地方相对来说经济发展比较落后，那么像我们国家一些已经淘汰的低档的商品可能现在很多同学都很少见到了，但这些产品拿到非洲一些落后欠发达地区，照样有市场。&#8195;&#8195;第二，我们还可以从市场的“边边角角”去捕捉创业机会。边边角角往往容易被人忽视，而这也正是创业者可以利用的空隙。这在市场营销中把它称之为利基机会，营销策略中也叫做差异化策略。因为通常在创业的初期，可能每一个创业者的创业企业资源实力相对来说比较薄弱。那么找到这样的利基机会，把它作为打开市场的一个突击点，从这点上先取得成功，再逐步覆盖到更广阔的市场。比如在日本东京有一家规模很小的不动产公司，有一次有人向他们公司推销一块几百万平方米的山间土地，其他不动产公司都不感兴趣，因为那块地山间土地，很少有人去，也没有公共设施。但这家公司的老板却认为现在城市“人挤人”，回归大自然将是不可遏制的潮流。当时，他就毫不犹豫地拿出全部的财产，又大量借款，将这块土地买了下来，并且将它细分为能源用地和别墅用地。后来大做广告，结果不到一年，这块土地就卖出了415亩，净赚50亿日元。这也就是注意到了一些别人没有发现的机会，因为虽然说是边边角角，但能够取得成功。&#8195;&#8195;第三，我们也可以从竞争对手的缺陷中去捕捉机会。研究竞争对手，从中找出其产品的弱点及营销的薄弱环节，也是企业捕捉机会的有效方法之一。我们都知道，在创业之初要进行SWOT分析。有些人可能没有注意到SWOT分析对创业的重要性，只是为了SWOT分析而做SWOT分析。要分析什么？分析别人的弱点、别人的优势、自己的特长、自己的优势。通过SWOT分析，找到其他产品的弱点，这也是可以开展创业的一个重要的突破口。没人做不到的，如果你能做到，不就可以取得成功吗？比如在美国有一家橡胶用品公司的成功的秘诀就是“采竞争者之长，补竞争者之短”。在竞争对手开发出储存食物的塑胶容器以后，这家公司认为这个产品品质虽然很高，但放在冰箱里会造成许多小的空间没有办法利用。于是它对其进行改进，开发出了性能更好、价格更低、又能节省存放空间的塑胶容器。&#8195;&#8195;第四，我们还可以从市场发展的趋势中去捕捉商机。市场总是在不断发展变化的。创业者要善于从市场发展变化的趋势中，捕捉创业机会。像我们国家的大众城市中，现在人口已经出现了老龄化的趋势，那么这也就意味着老年人市场的增幅扩大。创业者可以把握这一创业机会，深入、细分老年人市场，开发出能够最大程度的满足他们要求的各种产品。很多创业者也意识到了这一机会。像现在很多老年人的保健品、旅游市场等。很多企业都想分一杯羹。&#8195;&#8195;最后，可以在行业交界处去发现创业机会。由于各企业都比较重视行业的主要领域，因而在行业与行业之间有时会出现夹缝和真空地带，无人涉足。当然，可能也是因为这部分市场相对来说比较小。虽说也意识到了，但大企业看不上它。所以从这一点上我们也可以看到，作为创业者来说要注重去开拓视野，走出去看一看，那么就能够发现更多的机会。&#8195;&#8195;好，这部分内容我们就先讲到这，谢谢大家。  \n创业机会评价策略1&#8195;&#8195;同学们好，接下来我们来看创业机会的评价策略。一个创业机会到底好与不好，有没有利用它的价值，我们要对它进行评价，过程中要运用相应的策略和方法。&#8195;&#8195;创业机会评价是创业者从效益、市场、策略等方面对创业机会的价值迸行综合评估，并决定下一步是否对创业机会开发和利用的过程。&#8195;&#8195;创业机会评价的目标就是在众多的创业机会中，通过分析、判断和筛选发现有力的并能加以利用的创业机会。创业机会虽然是存在，但是并不代表成功，只有去找到适合我们的创业机会，才能够提高成功的概率。那么对于创业机会如何评价，我们一方面要认识到创业机会的价值的大小，同时另一方面也要去减少创业的风险。一个创业机会是否能够成为可以开发的机会，其根本标准是创业机会本身是否能够给消费者带来持续的商业价值。风险与价值是并在的。创业机会评价就是对机会价值和风险进行全面的评估，从而规避风险，提升创业成功率。所以创业机会的评估，简单来说，就是“价值有多大，风险有多少”。&#8195;&#8195;具体在创业机会评价过程中要把握相应的准则。如果创业者能先以相对客观的方式对创业机会进行评价，那么许多创业失败的结局就不至于屡次发生，创业成功的概率也可以随之而提高。所以针对如何评价创业机会，需要构建一套包括效益、市场、创业团队、策略特色等四大要素的评价准则。这四大要素的评价准则相辅相成，缺一不可。&#8195;&#8195;对于这四个方面呢，我们逐一来看。首先是效益评价准则。简单来说就是要看这个机会可能带来多大的效益，其重要因素有资本需求、合理的税后净利、毛利率、盈亏平衡所需的时间资本市场活力、退出机制与策略等。&#8195;&#8195;第二个准则是市场评价准则。也就是说，考虑一个创业机会在市场上的表现如何，其表现包括市场规模、市场定位、市场渗透力、产品的成本结构、市场结构、市场占有率等。其中一些是定性的，一些是定量的。&#8195;&#8195;第三个准则是创业团队评价准则。通常由综合素质高的核心创业者统领，加上一群各具专业和知识背景的团队成员所组成的创业团队，再结合团队内聚力与共同分享的价值观，这种最佳团队组合能体现创业机会价值大小。像搜狐、当当网、新希望集团，都是优秀的创业团队。除此之外，团队中的团队成员的产业经验与专业背景，核心创业者与团队成员的产业经验与对该产业的了解程度，会影响创业机会的价值实现。比如江苏有家公司叫做奥雷光电，它是由一些旅美归国的博士团队创建的。他们良好的专业背景和技术，成功地打造了这样一家中外合资的高科技企业。我们创业团队中成员的正直、诚信的人格，在业界拥有良好的声誉，具有正直、诚信公平等基本为人处事准则的创业团队成员，对创业机会评价通常会有显著加分的效果。比如李嘉诚，他在创业的过程中，最早是从塑胶花厂开始创业的。虽说是一个小小的塑胶花，李嘉诚却一丝不苟，用真诚和信用，即其领导气质的根基，去打动自己的客户。这样的个性特征为他的创业成功奠定了良好的基础。其次，创业团队成员所拥有的战略眼光，也可以给创业机会带来更多成功的保障。“先知先觉是成功的必要条件。”创业团队要能培育并把握创业机会，必须要有比较长远的眼光。仔细分析一下，大多数成功的创业团队都比其他人更能够寻找或捕捉并把握住创业机会。还有一个例子，2003年江南春创立的分众传媒，决定了绕开开竞争惨烈的传统媒体，走分众之路，专攻楼宇液晶媒体。在很短的时间内，利用数字多媒体技术所建造的商业楼宇联播网，就从上海发展到全国的37个城市，网络覆盖面也从50多栋楼宇发展到6800多栋楼宇，拥有75%以上的市场占有率，取得了很大的成功。&#8195;&#8195;最后一个准则是策略特色评价准则。它主要包括创业模式的组合、机会的导向、所拥有的技术优势、进入时间的把握、服务的品质。&#8195;&#8195;除了以上评价策略以外，现金流评价策略也是创业者或团队可以用来评价创业机会的一个简单实用的手段。创业机会的评价还需要考虑可实现度，无论特定创业机会可能的现金流有多大，如果在实现的可能性上有较大的难度，那么它同样也不是一个好的创业机会。创业机会如果不能够带来现金流，那就很难让创业者或团队支撑下去。因为任何一个企业，任何一个创业者，其财力资源都是有限的。这点也可以作为一个评价准则来辅助使用。&#8195;&#8195;对于创业机会评价的策略，我们主要了解这些方面就可以了。好，谢谢各位同学。  \n创业机会评价策略2&#8195;&#8195;同学们好，在创业机会这章的最后，我们来学习一些在创业机会评价过程中比较常用的方法。我们对创业机会进行评价，如果能够合理的运用这些方法，也能够给我们更好地评价创业机会带来帮助。&#8195;&#8195;这些方法主要分为两大类：一类是定性的评价方法，一类是定量的评价方法。这些方法大多数是以提出方法的研究者的姓名来命名的。下面逐一给大家进行介绍。&#8195;&#8195;首先，我们来看史蒂文森法。它是一种典型的定性评价方法，主要从四个方面来评价创业机会的可行性。第一，机会的大小和随时间成长的速度问题：也就是说这个机会可能会带来的收益有多大，随着时间成长的速度快还是慢；第二，潜在的利润是否足够弥补资金、时间和机会成本的投资，并带来令人满意的收益：也就是看未来的收益状况；第三，在可能的障碍面前收益是否会持久：创业机会在实施过程中可能会面临各种各样的障碍，那么如果面对这些障碍，考虑是否仍然能够取得相应的收益；第四，产品或服务是否真正满足了真实的需求：如果不能够满足消费者的需求，那未来这个创业机会也是不可持续的。&#8195;&#8195;第二个定性的评价方法叫做朗格内克法。这种方法总共有五项基本的评价标准。第一，产品或服务有明确界定的市场需求，推出的时机也是恰当的；第二，产品或服务必须能够维持持久的竞争优势：与竞争对手进行对比，优势是否明显；第三，创业机会必须具有定程度的高回报（收益状况）；第四，创业者和创业机会之间必须相互适合：每个人性格不一样，每一个团队的特点不一样，这个创业机会是否能够适合，就像找对象似的，最好的不一定是最适合的，只有最适合的才能够一起走下去；第五，创业机会不存在致命的缺陷：如果存在致命的缺陷，在评价的过程中，其的得分也不会太高。&#8195;&#8195;第三个定量的评价方法叫做标准打分矩阵。运用矩阵的原理，选择对创业机会有重要影响的因素，并由相关专家对每因素进行打分，最后求出每个因素在各个创业机会下的加权平均分，从而对不同的创业机会进行比较，得分高的创业机会，其利用的价值就越大。&#8195;&#8195;第四个方法叫做蒂蒙斯法。著名的创业学家蒂蒙斯概括了评价创业机会的框架体系，其中涉及八大类、共53项指标，创业者利用这个体系模型对行业和市场问题、竞争优势、收获条件、经济因素、管理团队、理想与现实的战略差异、创业家的个人标准和致命缺陷等做出判断，来评价创业机会的投资价值。从右边的表格中可以看到创业者根据具体情况对创业机会打分，并根据打分结果的高低判断创业机会的潜在价值的大小。&#8195;&#8195;第五个方法叫做普坦辛米特法。这是一种让创业者填写预先设定好因素权值的选项式问卷的方法，对各种因素、不同选项的得分为-2到+2分，对所有因素得分加总就是最后的总分，总分越高的创业机会价值就越大。一般来说，只有得分高于15分的创业机会才值得开发，低于15分的应该抛弃。&#8195;&#8195;第六种方法叫做巴蒂选择因素法。该方法是通过11个选择因素来对创业机会进行判。如果某个创业机会只符合中的6个或者更少的因素，这个创业机会就不可取；反之则说明该创业机会成功的希望很大，可以好好地利用开发。&#8195;&#8195;那么第五章的内容我们就全部讲完了，谢谢大家。  \n创业风险创业风险及其特征&#8195;&#8195;各位同学，大家好。在了解了创业机会以及创业机会的识别以后，我们接下来看看创业风险。因为机会都是与风险共存的。想要取得高收益，通常都会面临高风险。在创业机会的把握过程中，我们不得不重点分析可能面临的创业风险。那么第六章，我们主要从三个方面来介绍：什么叫创业风险及其特征、创业风险的识别与防范、创业风险预测。&#8195;&#8195;首先我们来看看创业风险，以及它所具有的特征。&#8195;&#8195;所谓创业风险，指的就是由于创业环境的不确定性，创业机会与新企业的复杂性，创业者、创业团队与创业投资者的能力与实力的有限性，而导致创业活动偏离预期目标的可能性及其后果。简单来说，在创业过程中失败的可能性及其后果就是所谓的创业风险。&#8195;&#8195;创业风险具有多方面的特征，包括客观存在性、不确定性、相关性。&#8195;&#8195;创业风险的第一个特征是客观存在性。在创业的过程中，由于内外部因素发展的不确定性是客观存在的，因而创业风险也必然是客观存在的，是不以人的意志为转移的。客观性要求创业者采取正确的态度承认和正视创业风险。既然没有办法回避，那就需要提前考虑好应对方案。当然，这种客观性并不否认创业风险的存在，它也有主观的一面。比如有些人为的因素，也有可能会带来风险。比如对某一方面知识掌握得不够全面、分析得不够透彻、能力某些方面存在不足，都有可能会导致风险存在并且加大。&#8195;&#8195;创业风险的第二个特征是不确定性。在创业过程中，创业者面临各种各样的不确定因素，如可能遭受到已有市场竞争对手的排斥，进入新市场面临着需求的不确定，甚至创业团队面临解散。举个例子。肯尼迪爱坐旋转椅，他当美国总统时，旋转椅市场曾一度被看好。到了里根入主白宫之后，因他爱吃豆胶软糖，顿时激发市场上对各种牌子的豆胶软糖的销售。类似这样的市场不确定性，有时真令创业者难以预测和捉模。&#8195;&#8195;创业风险的第三个特征是相关性。创业者面临的风险与其创业行为及决策是紧密相连的。同一风险事件对不同的创业者会产生不同的风险，同一创业者由于其决策或采取的策略不同，会面临不同的风险结果。一定程度上，创业风险也可以说是一个系统性的体系。我们对其进行分析的时候，不能只看到风险的某一个方面，要把握住风险的全部，通过对相关性来进行分析，可以更全面、更综合地去判断所面临风险以及对创业成功造成威胁的大小。&#8195;&#8195;这三个方面的特征需要认真地进行分析，以使得在创业过程中能更好地去面对风险，提高创业成功的几率。&#8195;&#8195;谢谢大家。  \n创业风险的识别与防范&#8195;&#8195;同学们好。既然我们前面说到创业风险在整个创业过程中的重要性是显而易见的，所以我们有必要对创业过程中所面临的创业风险进行识别，以及采取相应的防范措施。&#8195;&#8195;在对创业风险的识别与防范过程中，我们主要把创业风险分为两大类：一类是系统创业风险，另外一类是非系统创业风险。&#8195;&#8195;系统创业风险主要包括四种，分别是政策风险、法律风险、宏观经济风险、自然风险。对于这四种风险，我们如何去加以识别和防范呢？&#8195;&#8195;第一，政治风险。对创业者而言，国家和地方政府所采取的政策可能会带来一定的创业风险，必然会影响市场环境、社会购买力，影响到创业者的生产经营方向。现在我们国家还有地方政府都是支持低碳、环保、节能、减排产品的推广，那么如果我们的创业跟国家这一类政策不相符合的话，那必然会带来较大的政策风险。对于这类政治风险，如何来进行防范？创业者在创业过程应该积极关注和预测国家的政策走向，如果预测到某一政策将对新创企业的发展不利，企业可以早做准备，适应政策的变化。比如可以做一些挽救的措施、制定一些预案，或者可以提前退出。&#8195;&#8195;第二，法律风险。通常，法律、法规的制定和修改，都会对创业者产生影响。有一些是直接的，有一些是间接的。比如近年来，一些企业开发出转基因产品，但这被有关国家的政府明令禁止销售，特别是欧美一些发达国家。如果没有提前意识到而遇上了这种情况，创业者可能就得不到相应的商业利益。法律风险最好的防范办法就是知法、守法，自觉运用法律法规来规范自己的创业行为，同时还应善于运用法律武器来维护自己的合法权益。所以我们也建议作为创业者，最好能有一个专门的法律顾问。有些大企业可能有专职的律师，我们作为初创企业、小企业的话，可以聘请一个法律顾问，来及时的防范法律风险。&#8195;&#8195;第三，宏观经济风险。它指的是因国家宏观经济变化、产业政策调整、利率变动等因素所带来的损失的风险。价格水平、通货膨胀等因素的变化以及金融、资本市场的层次、规模、健全程度等都会带来很大的不确定性，使创业者容易暴露在风险之中。而当这类风险将要出现时，创业者应该能够快速响应，采取措施，使新企业适应这一变化。&#8195;&#8195;第三，自然风险。随着我国经济的快速增长，天气、气候灾害造成的损失越来越大。这些自然灾害属于创业者不可抗力的范畴。就像化学工业园区，如果和企业、居民区交错布置，缺乏统一的区域性环境风险应急预案等，那就会不可避免地存在自然风险。对于各种自然灾害，创业者没有能力遏制其发生，但只要事先做好准备工作，就能够降低自然灾害造成的损失。新企业在创业机会开发时，不仅要考虑当地的劳动力素质及成本、市场需求等，还要考虑当地在气候、卫生等方面的条件，为创业成功提前做好预案。&#8195;&#8195;另一方面，非系统创业风险。非系统创业风险主要分成五类，分别是市场风险、生产风险、技术风险、财务风险和管理风险。&#8195;&#8195;第一，市场风险。市场风险的识别，一是产品能否被消费者接受的问题。一个产品研制出来以后，消费者到底买不买帐。比如世界著名的贝尔实验室在20世纪50年代就推出了图像电话，但直到20年后，才开始了商业应用。一项产品被消费者接受是存在一个过程的。二是产品导入市场的时间、市场的需求量等都难以估测。比如1959年，IBM公司预测施乐914复印机在10年内仅销售5000台，从而拒绝了与研制该产品的哈罗德公司合作，然而复印技术被人们迅速采用，改名为施乐公司的哈罗德公司10年内销售了20万台。这其实就是预测的错误导致没有能够抓住创业机会。市场风险防范的途径：一是市场进入成本，即成本的大小；二是市场进入定位，即定位是否清晰，目标消费者是否明确。对于市场风险，除了考虑到进入风险以外，还要考虑到营销风险。营销风险的防范，一是树立以市场为导向的整合营销理念，二是制定合理的价格策略。&#8195;&#8195;第二，生产风险。对于新企业来说，由于企业刚刚起步，生产人员的配备、生产要素的供给、各类资源的配置等容易出现问题，存在着较大的风险。这就需要新企业在研发时，应考察替代技术的发展状况，评估技术本身的替代性，采取风险防范或自留策略，还要综合考虑原材料及能源供应，地址要接近原材料产地，且能源供应充足。&#8195;&#8195;第三，技术风险。技术风险的主要表现，一是技术成熟度，如可口可乐的配方；二是技术适用性，如美国杜邦公司曾对一种称之为Corfam的皮革替代品进行开发并上市销售，亏损了近1亿美元，成为公司历史上罕见的一次失败；三是技术生命周期。技术风险防范，一是采用多元化技术开发战略，二是组建战略联盟，三是转移技术风险。&#8195;&#8195;第四，财务风险。财务风险，一是看资产负债表的状况，二是看企业收益状况。所以一家企业肯定是有专门的财务人员的，要对财务报表来进行分析。当然，作为创业者，也要懂一点财务知识，否则可能很难提前发现财务风险。比如辉煌一时的新疆德隆集团，短短几年内一下子进入十几个产业，总负债高达570亿，酝酿了巨大的财务风险。2004年初，德隆系资金链开始断裂。财务风险的防范，一是增强创业者的风险意识，二是保持资产流动性，三是加强财务会计制度建设。&#8195;&#8195;第五，管理风险。一是创业者综合素质和经验：可以从创业者的技术能力、管理能力和经验、企业家精神等方面来考察。二是管理机制的成熟度：应将本企业与产业内相似企业进行对比，识别出新企业哪些管理制度不够完善，并加以改进。管理风险的防范，一是建立健全的现代企业制度：新企业必须要按照现代企业制度的要求，建立起真正的完善的产权制度和法人治理结构；二是提高创业者和创业团队的自身素质：很多企业家都会去高校里攻读MBA、EMBA等，以提高自身素质和管理理念。&#8195;&#8195;那么这一节，我们先讲到这，谢谢。  \n创业风险预测&#8195;&#8195;同学们好。在创业风险这一章，最后我们来了解如何对创业风险来进行预测，烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫烫。&#8195;&#8195;创业风险的预测，首先要对创业者自身对风险的承担能力进行估计。风险一方面来自于外部，一方面来自于企业内部。&#8195;&#8195;外部的风险包括自然、技术、环境等风险，这些风险虽无法根本消除，但创业者对周围环境的知识积累程度影响其对外部风险的判断和预防工作的准备，能够提升创业者的风险承担能力。&#8195;&#8195;而企业内部风险承担能力指创业者固有的资源以及配置这些资源的能力，包括技术、生产、管理、营销、创新等内容，这些可控因素是决定创业者的风险承担能力的重要指标。&#8195;&#8195;除了内部和外部风险的估计以外，还需要对创业收益来进行预测。如果创业者知道未来可能呈现出多种风险，但对其出现的概率全然不知，那么在预测创业收益时，就只能根据主观选择的一些准则来进行。这些准则主要有五种：等可能性准则、乐观准则、悲观准则、折衷准则、后悔值准则。我们逐一来看看如何利用这些准则进行创业收益的预测。&#8195;&#8195;第一，等可能性准则。这个准则假定各种风险状态发生的可能性是相同的，通过比较每个创业方案的收益平均值来进行创业方案的选择。来看一个例子。某个企业有三种产品待选：甲、乙、丙。估计销路风险状况和收益情况在这个表中。计算各产品在三种风险状态下的平均收益值：甲产品为16.67万元，乙产品为26.67万元，丙产品为15.33万元。由此可见，乙产品的平均收益值最大，选择该方案。&#8195;&#8195;第二，乐观准则。如果创业者比较乐观，创业者从最有利的角度去考虑问题，先选出每个创业方案在不同风险状态下的最大收益值（最乐观），然后从这些最大收益值中取最大的。仍以上个题目为例，由于甲产品最大收益为40万元，乙产品最大收益为90万元，丙产品最大收益为30万元，所以90万元对应的乙产品为选择的方案。&#8195;&#8195;第三，悲观准则。创业者从最不利的角度去考虑问题，先选出每个创业方案在不同风险状态下的最小收益值（最保险），然后从这些最小收益值中取最大的，从而确定创业行动方案。仍以上个题目为例，由于甲产品最小收益为-10万元，乙产品最小收益为-50万元，丙产品最小收益为-4万元，所以-4万元对应的丙产品为选择的方案。&#8195;&#8195;第四，折衷准则。这种方法是中庸的体现，认为应在两种极端中求得平衡，最好和最差的风险状态均有出现的可能。因此，可以根据创业者的判断，给最好状态以一个乐观系数，给最差状态以一个悲观系数，两者之和为1，从而得出各方案的期望收益值，然后据此做出选择。仍以上个题目为例，设销路好的系数为0.7，销路差的系数为0.3，通过计算得到期望收益值，由于乙产品的期望收益值最大，所以乙产品为选择的方案。&#8195;&#8195;第五，后悔准则。把在不同风险状态下的最大收益值作为理想目标，把各个创业方案的收益值与这个最大收益值的差称为未达到理想目标的后悔值。然后从各创业方案最大后悔值中取最小者，从而确定创业行动方案。仍以上个题目为例，计算后悔值。由于甲产品最大后悔值为50万元，乙产品最大后悔值为46万元，丙产品最大后悔值为60万元，在其中再取最小的，所以46万元对应的乙产品为选择的方案。&#8195;&#8195;创业风险这一章就全部给大家讲完了，谢谢。  \n商业模式商业模式创新&#8195;&#8195;同学们，大家好。现在我们开始讨论创业过程当中的商业模式问题。&#8195;&#8195;在创业和撰写创业计划书的过程中，都有一个非常重要的部分，就是商业模式。很多人可能都会问，你的创业到底采取的是什么样的商业模式，你的盈利模式是什么？在这里，我们就来具体探讨一下什么叫做商业模式，它的本质是什么。&#8195;&#8195;商业模式开发的思路是什么样的，企业如何去进行商业模式创新，是我们这章的主要内容。&#8195;&#8195;首先我们来看什么叫做商业模式。商业模式是一种包含了一系列创业要素及其内在关系的概念性系统，用以阐明创业者的创业逻辑。它描述了企业所能为消费者提供的价值以及企业的内部结构、合作伙伴网络和关系资本等用以实现（创造、推销和交付）这一价值并产生可持续盈利收入的要素。从这个定义可以看出，商业模式包含的内容是非常广泛的。说得简单一点，商业模式就是企业生成的一个状态、盈利的路径、综合运用资源、实现和创造价值的过程。&#8195;&#8195;商业模式内涵主要包括九个方面的因素，包括价值主张、消费者目标群体、分销渠道、消费者关系、价值配置、核心能力、合作伙伴网络、成本结构、收入模型，涉及到企业经营的方方面面。&#8195;&#8195;所以说商业模式是一个综合性的系统，所以也需要我们在其设计过程中遵循严密的设计思路，不是说简单拍脑袋就能拍出来的。一个良好的、经过精心设计的、符合企业发展需要的商业模式，可以为企业带来源源不断的利润，否则企业可能就经常会面临发展的问题。&#8195;&#8195;商业模式设计的思路，第一，以顾客为立足点和出发点。很多企业都喜欢挂横幅喊口号：“顾客就是上帝”，那么到底有没有真正把顾客摆在这样的位置呢？我们应该从创业的时候，从商业模式设计的时候，就把这个理念灌输进来，以顾客为立足点和出发点，要思考顾客希望我们怎么做，然后我们再怎么做。&#8195;&#8195;第二，以产品或服务为依托。一个新企业成立之初，首先要明确到底是做什么的，而且要用一句话就说清楚。这也想做那也想做的企业，往往可能什么都做不好啊。&#8195;&#8195;第三，以价值链上的价值最大化为根本目标。波特的价值链理论提到，每一个企业其实都是处于价值链上的某一个环节。既然是处于某个环节，在考虑问题的时候不仅仅要从所处的这个环节来考虑，还要以整个价值链（全局）的观念上来思考问题。我们自身价值要最大化，整个价值链也要实现价值最大化。这其实是当前比较流行的一种说法，叫做“合作共赢”，并不是“你死我生”，要求大家共同来为整个社会服务，共同创造客户的价值，为顾客做好服务。&#8195;&#8195;第四，以核心竞争力保证利润来源。任何一个企业都要有自身敲门砖，其竞争优势要突出，要明显。那么有了核心竞争力，商业模式就要围绕核心竞争力来开展服务、提供产品。如果核心竞争力不够突出的话，那么商业模式也要为突出核心竞争力而服务。&#8195;&#8195;最后，很多企业还会面临一个问题，就是企业发展过了几年，要想再壮大也很难挖出潜力了，要想寻找新的利润增长点也很困难了。那么很多企业就会想到商业模式创新。很多企业家都意识到其商业模式已经落后了，想要改换一种商业模式。那怎么去创新，怎么去跟上新的时代潮流呢？&#8195;&#8195;我们主要可以通过五个方面来进行商业模式的创新。首先要分析企业内外部的状况，做到知己知彼。了解企业之前的优势在哪，劣势、不足在哪，竞争对手的优势在哪，薄弱环节是哪。然后通过商业模式创新来突出企业的优势，补足短板。&#8195;&#8195;第二，重新进行市场定位。比如说，我们的产品、服务原来的定位是中低端的市场，那么我们可以重新定位，瞄准高端市场，服务高端客户，以进行商业模式创新。&#8195;&#8195;第三，改变分销渠道。比如，我们原来是通过线下销售的，那么我们可以改变分销渠道，通过线上销售产品，以改变商业模式。&#8195;&#8195;第四，改变收入模式。比如，很多原来只是通过销售产品获取收入的企业，通过转变收入模式，开始提供优质的服务，照样能够实现收入的增长。&#8195;&#8195;第五，运用现代科技。现在的网络科技，特别是移动互联网科技，为商业模式的创新提供了更多的发挥空间。&#8195;&#8195;这是我们所说的商业模式、它的定义、设计思路以及创新。好，谢谢各位同学。  \n传统商业模式&#8195;&#8195;同学们好。了解了商业模式的基本内涵和设计的基本思路，接下来，我们了解一些比较常见的商业模式。通过了解这些常见的商业模式，可以为我们创业选择合适的商业模式提供借鉴。&#8195;&#8195;首先，我们来看一些比较传统的商业模式，主要看这五种，分别是特许经营、专业经营、模仿经营、承包经营和收购经营。&#8195;&#8195;第一，特许经营。特许经营是指特许者将自己所拥有的商标、商号、产品、专利和专有技术、经营模式等以合同的方式授予受许者（创业者）使用，受许者（创业者）按合同规定，在特许者统一的业务模式下从事经营活动，并向特许者支付相应的费用。比如我们所常见的加盟店，它购买的不仅是商品的销售权，而是整个模式的经营权。同时，总公司要给予加盟店在开店前及经营过程中必要的支持。但是，尽管受许者投资并获得了对特许加盟店的所有权，但管理权最终仍为特许者掌握，也并不发生知识产权的转移。特许经营这种商业模式，它的优点和缺点比较明显，优点就是易上轨道、风脸较低、较易对所需的资金作出预算、生意有保障；但是它的突出缺点就是受合约限制。所以针对特许经营的商业模式，主要有这样一些注意事项。一、总店的质量和商誉难以量化，所以创业者应选择较可靠的特许经营业务加盟。二、选择加盟品牌时，要作多方面的考虑，包括品牌的知名度和商誉、产品供应是否稳定、定价是否合理、总店其他特许经营店的经营情况。三、总店一般会向加盟店征收一笔开业的特许经营加盟费，之后加盟店便要按月支付服务费，包括专利权费、营业额某个百分比的管理费及广告费等。由于这些费用在整体成本中占不少比例，因此会直接影响利润，创业者要小心计算。四、要跟随总店订下的模式运营，不能加入个人风格或创意，灵活性不够，但欠缺经商经验者则有规可循。五、当心特许经营的“陷阱”。有的总店实力不足，自身都难保，导致无力保障加盟者的利益。更有甚者些成心骗取创业者的所谓特许经营费、加盟费，钱一骗到手就消失了。我们来看一下案例——掉渣烧饼。它的特色体现在三个方面：包装注重细节、排队也是广告、沾“土”字的光。经营成本是加盟费、设备费、一年房租，大约3万元，其中设备主要是烤箱、面机、饼架等。像这种门槛低、加盟投资额不高、现金周转额度不高的项目，受到大部分普通创业者的青睐。&#8195;&#8195;第二、专业经营。专业经营是指创业者利用自己专业特长或专业资格，为相关客户提供产品或服务，借此收取报酬的创业模式。专业经营的前提是必须在某一领域拥有专业资格或者特长，也就是所谓的专业。优点是成功机会较高、成本较低、人脉网络及客户基础；缺点是由子依赖专业人士的声誉，专业人士可能因为工作失误或个人行为不当，或被取消专业资格，导致企业前途受影响。专业经营的注意事项，一、为了在专业范畴中可以进一步的发展创业者需要不断地进修，以提升个人的专业水平、知识，以免被淘汰。二、经常参与专业公会或行内的聚会，对开拓客源及建立人脉关系网络会有帮助。&#8195;&#8195;第三、模仿经营。模仿经营有两类：一是跟随技术先行者，通过购买技术专利和许可证的办法，来进行生产；二是所谓的“搭免费车”，对他人的产品和服务，以及运营模式等稍加改动，为己所用。优点是创业成本低。由于购买甚至免费借鉴他人的技术、经营模式、管理模式，节省了研发的时间成本和资金成本，而且风险较低；缺点是模仿对象的选择很关键，并且有一定的法律风险，可能会涉及到侵权等。所以运用这种模式的注意事项，一、创业者需要进行广泛调研，分析流行趋势和市场走向，选择最有前途的目标技术或企业。二、注意向工商部门或相关法律专家进行咨询，确保模仿的专利不至于引起法律纠纷。三、不能一味模仿，模仿之中要有创新，在模仿他人的基础上要逐步形成风格、品牌价值、研发能力和销售网络才是决定模仿者能否成功的关键因素。也就是说，不要仅仅只是模仿，要做出改进。&#8195;&#8195;第四，承包经营。承包就是创业者按承包经营合同，对企业所有者的资产进行经营管理，在不改变企业所有制性质的前提下，“所有权与经营权相分离”，出租方把企业有期限地交给承租人，承租人交纳租金并按合同自主经营的方式。这种模式优点是竞争小，承办企业通常已有良好的客户基础，如果能提供良好的服务或产品，创业者所面对的风险会较低；缺点是市场限制、受合约限制、合约年期有限。承包经营的注意事项，一、创业者必须充分了解承包条文、合约上列明的要求，并要对租金、承包年期和业务范围等小心计算，确保可得到预期的回报。二、承包项目中的各项细节和守则必须合乎法律要求。&#8195;&#8195;第五，收购经营。收购是指创业者通过购买其他企业的大部分或全部所有权，从而取得对该企业的经营控制权。在目前的市场中收购也是比较常见的，比如吉利收购了沃尔沃，可口可乐收购汇源果汁，联想收购IBM的个人电脑业务。它的优点是开业时间短，短时间内可以做大做强；由于被收购方已有一定的基础，回本期快，承接业务既有的客户及供货商，能缩短回本期。缺点是风险不易评估。收购本身最大的风险在于被收购的业务可能隐藏有财务危机、债务诉讼及其它问题，创业者务必注意，不然买来的可能不是收益，而是一个包袱。收购经营注意事项，一、对要收购的业务进行彻底的调查，包括所收购业务的财务状况、诉讼纪录、债务纪录和客户口碑等。二、宜聘用律师或会计师作为成交过程的见证人或者进行公证。三、保持原有班底，在收购过程中稳定员工的军心，对公司或店铺的顺利过渡十分重要。四、尽快掌握客源。&#8195;&#8195;这是我们所讲的一些传统商业模式，主要举这五个的例子。好，谢谢大家。  \n现代商业模式&#8195;&#8195;同学们好。接下来我们看三类现代的比较常见的商业模式，分别是虚拟企业、小型家居企业和1+1店铺模式。&#8195;&#8195;首先我们来看虚拟企业。虚拟企业是创业者以项目、产品或服务为中心，利用以互联网为核心的信息技术，以合作协议、外包、战略联盟、甚至成立合资企业的方式所构建的经济组织。比如淘宝、天猫、京东等网上商店就是虚拟企业的典型的形态。这种模式优点是风险小，经营成本较低，无需经营场所和设备投资。往往只需在家中敲敲电脑键盘即能联系业务；缺点是业务范围受限，部分传统企业和年长的消费者无法成为潜在客户。运用这种商业模式，一方面，要注意消除用户的抵触难。部分网络经营者为获取经济利益，采取窥探别人隐私、泄漏用户资料等行为，严重影响了用户正常生活，甚至给用户造成极大的经济损失。网上诈骗及网上消费隐私的隐忧，使得许多潜在的消费者对电子商务产生了抵触。其次，物流配送困难大。虚拟企业在信息流上享有绝对的优势，但在物流配送上却面临极大的困难，一是配送成本高，二是仓储费用高，三是配送渠道不完善。例如，美国的玩具网站“eToys”，曾遭遇过圣诞节订单大量涌进，以致顾客延迟收货，最后导致股价下跌的窘境。&#8195;&#8195;第二，小型家居企业。小型家居企业指自雇人士利用自己的家居作为主要办公地点的企业。随着互联网的迅速发展，这种创业模式已开始流行，而且渐被客户接受。它的优点是节省日常的营运成本，有竞争优势，而且居家创业者可享受相对独立的环境（也有些人是为了兼顾其它事务而选择居家创业）；但是它的缺点是个人惰性可能是小型家居企业最大的绊脚石，其次，小型家居企业的创业者在决策上，较少获取他人的意见，也较少接触业内人士去开拓视野。所以对于这类商业模式需要注意一、居家创业须有高度的自觉和纪律性。二、虽然小型家居企业并无公司的形体，但实际上仍是一家公司，因此，所有筹组公司的手续，包括办理公司注册、登记、营业执照等都要按程序来做，不可敷衍了事。三、虽然居家创业可以足不出户，但仍应继续和行业内朋友保持紧密联络，从中获取市场最新信息，这样才不至于被落伍、淘汰。&#8195;&#8195;第三、1+1店铺模式。1+1模式就是在别人已开张的店铺中，与其协商，插入自己的经营项目。如果你想开个小店，一时资金不足，或在一个自己看中的地段很难找到门面或只是想试营业等，可以考虑1+1模式经营店铺。最常见的模式是一个商店附带一部公用电话。如今有更多的组合模式被应用，如小区内出租VCD影碟店可与缝纫店合租；小卖部也可以引进电脑彩票销售。优点是充分利用门面空间，相对降低门面租金不用大量装修店面；不用从头开拓消费群体，因为第一个项目的经营者已有不少的消费群体，如果你开设相关项目，就可以吸引他们的消费，二者互为补充；减少投资风险，一旦生意砸了，损失比单独门面小的多。缺点是这种模式项目选择受到的限制较多，经营模式也要受到原有经营业务的制约；品牌的形象很难建立。所以，注意事项主要包括提前协商双方房租和其他费用分摊、门面钥匙各一、在营业的时间上，营业时间彼此不限制、广告招牌在门面上面和两边分装。&#8195;&#8195;那么对于商业模式，给大家列举了传统的和现代的，总共八种商业模式，谨供创业者在创业过程中进行参考和选择。当然，也可以进行一定程度上的创新，设计、开发出自己独有的一套商业模式。&#8195;&#8195;商业模式这章的内容就全部给大家讲完了。谢谢大家。  \n创业资源创业资源概述&#8195;&#8195;同学们好，欢迎回来。这一节我们讲一下创业资源。&#8195;&#8195;首先我们来阐述一下创业资源包括哪些内容？它包括创业资源的内涵与种类、与一般商业资源的异同、创业资源的作用以及融资分析等等。&#8195;&#8195;第一，创业资源内涵与种类。通常，创业资源是新企业在创业的过程中所投入和利用的各种资源的总和。它的种类包括直接资源和间接资源，也可以分为人力资源、技术资源、财务资源、生产经营性资源，还可以按照核心资源和非核心资源进行分类。有的人还会把它分为自有资源和外部资源。我们按照资源要素对企业战略规划过程的参与程度，可以把创业资源分为直接资源和间接资源。直接资源主要是指财务、经营管理、人才、市场资源等等。与之相对应的间接资源，是指政策资源、信息资源、科技资源等等。如果按照资源的重要性进行分类，创业资源分为人力和技术资源（这也是最重要的一种创业资源）、财务资源、生产经营性资源。根据资源基础论进行分类，我们把资源分为核心资源（包括技术、管理和人力资源）、非核心资源（包括资金、场地、环境资源）。如果按照资源的来源进行分类，那么分为自有资源（来自内部机会积累，是创业者自身所拥有的可用于创业的资源）、外部资源（来自于外部机会发现，而外部机会发现在创业初期起着决定性的作用）。&#8195;&#8195;第二，创业资源与一般商业资源的异同。在相同点上，都具有稀缺性，包涵内容相同的特点。在不同点上，创业资源多为外部资源，创业者在创业资源中的作用举足轻重，专有化高的知识在创业资源中至关重要。&#8195;&#8195;第三，创业资源的作用。主要有，技术和人力资源是决定资源，财务资源是根本资源，信息资源是重要资源。因此，这三个方面组成了创业资源的基本内容。&#8195;&#8195;第四，创业融资分析。对于创业融资，新企业不同发展阶段的资金来源是不同的。初创期的资金来源包括创业者的自有资金、向亲戚朋友借入的资金、民间借贷、吸收合伙人投资以及创业投资。对于处于成长期的企业，资金来源有私募股权投资、银行贷款、信用担保贷款、小额贷款公司等信贷资金。那么，新企业融资和一般企业融资的差别在这个表里面有所体现。比如说新企业资金来源少，无法借助成熟的资本市场，其资金数量也相对较少，资金的用途主要用于解决威胁企业生存的急需问题，融资方式可能相对单一（主要是指风险投资），融资较难，资金风险较大，资金的回报率也较大；对一般企业资金来源较多，可以和成熟的资本市场直接对接，资金的数量一般较大，资金主要用于企业的持续快速发展的一般问题，融资可以采取组合的形式，融资渠道和融资方式较多，融资相对容易。但他的资金风险适中，回报率也适中。创业融资难，有三个影响因素。一、新企业自身的原因，例如团队不够优秀，项目不够创新，市场不够大等。二、融资市场不规范，政策法规不健全，对初创企业有歧视，扶持力度不够等。三、融资渠道不畅，融资结构不够合理。&#8195;&#8195;好，关于创业资源的概述部分我们就讲到这里。谢谢大家。  \n创业融资&#8195;&#8195;同学们好，欢迎回来。这一节我们来讲一下创业融资。&#8195;&#8195;创业融资主要涉及到三个方面的问题，分别是创业所需资金的测算、初创期融资渠道及融资策略、成长期融资渠道及融资策略。&#8195;&#8195;第一，创业所需资金的测算。启动资金的预算编制极其重要，主要包括固定资产投资、流动资金。&#8195;&#8195;一、固定资产投资预测，包括企业用地和建筑投资（办企业或开公司，都需要有适用的场地和建筑，也许是用来开工厂的整个建筑，也许只是一个小工作间，也许只需要租一个店面）、设备投资（设备是指企业需要的所有的机器、工具、工作设施、车辆、办公家具等）。&#8195;&#8195;二、流动资金的预测其主要作用有购买原材料和成品费用、促销费用、支付人力资源工资费用、租金、保险及其他费用。我们在这里看一个启动资金预算编制的案例。例如张佳明大学毕业后准备开办一家小型书店，在经过考察以后，他决定租用一间60m2的门面房，下面是他开办书店进行的资金预算（不同城市及地段各项费用有差别，仅作参考）。（1）店铺装修：普通的中小书店，装修每平方米300元。60平方米的书店约需投入装修费18000元。（2）书架：中档的报价是每个300元。60平方米的书店放30个书架，约需要9000元。（3）营业设备：电脑、扫描仪、打印机、电话、传真等大约10000元。（4）首期备货的采购资金：参考其他书店情况初步确定50000元。（5）房租：每月租金5000元，得预备3个月的，共15000元。（6）人员工资：60平方米的书店需要2个店员，每人每月平均1600元，预备3个月，共9600元。（7）其他费用预留：如水电、通信、公关、物流等费用，每月预算2000元，预备3个月，共6000元。以上各项费用合计117600元。结论：开设这样一家60平方米的小型书店需要启动资金117600元。除了启动资金，我们还需要运转过程相应的资金。运转过程所需资金的预测，主要是为了后期运转需要的各项现金流量。有些销售需要赊账，赊销通常在几个月后才能收回现金；有时企业采购会赊账，以后再付现金，这也会使现金流量计划的制订变得更加复杂；新企业的某些费用是“非现金”的，如设备折旧等项目将不包括在现金流量计划里。&#8195;&#8195;第二，初创期企业融资渠道及融资策略。其融资渠道主要有自筹资金及策略、寻找合伙人投资、创业投资及策略。&#8195;&#8195;一、自筹资金及策略。有三种渠道，一是自有资金：是成功创业的基础，投入资金的数量还取决于与外部资金供给者谈判时所处的地位；而是向家庭成员及亲朋好友融资：家庭成员和亲朋好友的资金是创业融资的重要来源，需要明确所获得资金的性质。三是民间借贷及其策略：是指公民之间、公民与法人之间、公民与其它组织之间借贷。&#8195;&#8195;二、寻找合伙人共同投资创业。建立在利益共享、风险共担基础上的合作创业可以是亲朋好友，也可是原先素昧平生者。这里并非借款，而是投资。创业者需要做好以下工作：合伙人的人品要了解、合伙人的出资要明确、合伙企业制度要明确、合伙企业的账目要清晰。&#8195;&#8195;三、吸收风险投资。风险投资是把资本投向蕴藏着失败风险的高新技术及其产品的研究开发领域，旨在促使高新技术成果尽快商品化、产业化，以取得高资本收益的一种投资过程。也称创业投资。风险投资不需抵押，也不需要偿还。如果风险投资成功，投资人将获得几倍、几十倍甚至上百倍的回报；如果失败，投进去的钱就算打水漂了。对技术创业者来讲，使用风险投资创业的最大好处在于即使失败，也不会背上债务。这样就使得年轻人创业成为可能。在吸引投资创业的策略上，流程是明确创业投资机构的范围，充分准备谈判文件，与创业投资者会谈，与创业投资者进行价格谈判，双方签署文件。&#8195;&#8195;第三，成长期企业融资渠道及融资策略。其融资渠道主要有信贷资金及获取策略、各类创业扶持资金及获取策略、私募股权基金及获取策略以及其他融资策略。&#8195;&#8195;一、信贷资金及获取策略。它包括商业银行的贷款（需要明晰贷款品种、贷款金额、利率和期限）、信用担保贷款（主要指的是小额担保贷款、新企业担保贷款）、小额贷款公司贷款（小额贷款公司以商业额的差别在于只贷不存、贷款利率浮动区间比较大）。&#8195;&#8195;（1）商业银行贷款。第一，在贷款品种方面，宜从小到大逐步升级。第二，在贷款金额方面，贷款时应量力而行，尽量避免搞大投入。第三，在贷款利率方面，可“贷比三家”尽量选择利率上浮幅度小的金融机构去贷款。第四，在贷款期限方面也要十分注意。&#8195;&#8195;（2）信用担保贷款。它是政府部门为了支持中小企业，设立担保基金，成立担保机构（也有商业性担保机构）。对担保机构对符合担保条件的中小企业办理审批手续（一般需反担保），同意为银行贷款提供担保，银行则为中小企业提供贷款。&#8195;&#8195;（3）小额贷款公司贷款。小额贷款公司是由自然人、企业法人等投资设立的公司。它的典型特征是只贷不存、利率浮动较大（不得超过同期银行贷款利率的4倍）。与银行相比，它更为便捷迅速，适合小微企业的资金需求。与民间借贷相比，它更加规范。&#8195;&#8195;二、各类创业扶持资金及获取策略。地方层面设立的创业扶持资金有扶持对象较广的创业资金，也有扶持大学生的创业资金。国家层面设立的创业扶持资金，有科技型中小企业技术创新基金、中小企业发展专项资金、中小企业国际市场开拓资金。获取创业扶持资金的策略，一是要认真学习充分理解各项创业扶持基金申请的相关政策，二是要充分挖掘新企业价值，三是要加强信用管理。&#8195;&#8195;三、私募股权基金及获取策略。私募股权基建投资对已形成一定规模、处于成长期、有上市潜力新创企业的股权投资。例如，小肥羊在上市前接受了著名私募机构英国3i与普凯基金投资2500万美元，当当网先后接受了来自美国数据集团（IDG）、卢森堡剑桥投资控股公司、美国老虎科技基金的投资。如何获取私募基金？首先要积极配合价值评估与尽职调查，还要写好商业计划书，充分挖掘企业的价值，熟悉私募股权融资过程。&#8195;&#8195;四、其他资金来源。最主要的是供应商融资或客户提前付款。例如融资租赁，又称设备租赁或现代租赁，是指实质上转移与资产所有权有关的全部或绝大部分风险和报酬的租赁。资产的所有权最终可以转移，也可以不转移。还有，也可以通过证券市场获得资金。&#8195;&#8195;好，创业融资方面我们就讲到这里。谢谢大家。  \n创业资源管理&#8195;&#8195;同学们好。这一节，我们来讲一下创业资源管理。在这节内容里，我们主要围绕创业资源的识别、获取、开发和利用展开讲述。&#8195;&#8195;第一，创业资源的识别。第一种是决策驱动型创业资源识别方法，是指创业者首先决定创业，然后发掘创业机会，组织资源，创建企业的过程。第二种是机会驱动型创业资源识别方法，是创业者首先发现创业机会，然后评估创业资源，创建企业的过程。在创业资源的识别过程中，我们首先要对创业资源进行分类，例如可以分为人力资源、社会资源、金融资源、物质资源、技术资源和组织资源。我们还可以对每一项资源进行交叉为维度划分，分为简单资源、复杂资源、实用型资源和工具型系列。另外，我们还要围绕创业资源的数量、质量、结构等基本情况进行调查。&#8195;&#8195;第二，创业资源的获取。在影响创业资源正常获取的因素中，主要有以下几个方面：社会网络（通常的人脉资源）、集聚经济效应（指由于劳动和资本等生产要素的集中所产生的高效益）、创业者先前的工作经验、才能以及信息的掌握情况。创业资源获取途径从创业资源来源方向来看，包括资源外部获取和资源内部积累两种方式，内部和外部主要是以新企业作为边界。资源外部获取主要包括资源购买、资源租赁、资本运营三种方式。针对创业资源的获取过程，创业者可以在创业资源获取阶段同时利用内部和外部两种杠杄撬动其它创业资源。由于创业者个人声誉和社会网络的积累是一个长期的过程，无形资源杠杆只能发挥单向作用，即通过无形的工具型资源来获得生产型资源。因此，新企业有效合理地利用这两类资源杠杆，能够提高新企业的资源获取效率。&#8195;&#8195;第三，创业资源的开发。影响创业资源开发的因素有新企业的拥有者或创业者、利益相关者面临的风险、社会网络、员工的非正式交流和频繁流动等。创业资源的开发途径也有很多种。我们总结为，一、步步为营：创业者分多个阶段投入创业资源并在每个阶段或决策点投入最少的创业资源，如果成功那么扩大投入，如果不成功则马上打住，这样就能稳扎稳打，保证最后的成功；二、杠杆效应：新企业要想走向成功，光靠自身的资源是远远不够的，必须利用自身资源“吸引”和“撬动”更多的资源，就是物理学上的杠杆效应；三、资源拼凑：创业者可以开发已经获得到的创业资源或者在他人看来无用的、废弃的创业资源，通过巧妙的整合，实现自己的目的。创业资源开发的过程包括资源合并和资源转化两个阶段。在创业者识别和获取资源之后，并不能保证新企业的存活。创业者根据不同的创业理念将资源的价值和潜能加以整合转化为新企业所持有资源基础。&#8195;&#8195;第四，创业资源的利用。创业资源利用的影响因素有风险偏好（分风险偏好型和风险厌恶型）、超前行动和思维、创业者自身素质。在创业过程中，创业者不但要能识别所需的各种不同效用的创业资源，还需知道如何对资源进行整合，整合过程包括绑聚、匹配以及合理利用等。创业者通过前期的准备工作，识别、获取、开发资源，可以利用这些资源进行价值创造。&#8195;&#8195;好，以上就是关于创业资源方面的内容。这一讲就到这里结束。谢谢大家。  \n创业计划商业计划书概述&#8195;&#8195;同学们好，今天我们一起来学习商业计划书的写作方法和技巧。我们的讲解分为四个部分，分别是商业计划书的作用、商业计划书的基本内容、商业计划书的制作流程、商业计划书摘要的基本内容和撰写注意事项。&#8195;&#8195;首先我们来看商业计划书的作用。作用一、可以帮助我们理清创业思路，让我们清晰的知道创业面临的机会和困难是什么。作用二、好的商业计划书也是后续实施和调整创业计划的蓝本。作用三、更是获取风险投资的试金石。大多数投资人接触创业项目的第一次就是阅读商业计划书，然后才会有投资的意向。&#8195;&#8195;下面我们来讲解一下商业计划书的基本内容。一份完整的商业计划书，一般包括摘要、公司简介、产品与服务等十一项基本内容。我们来分别介绍一下。&#8195;&#8195;基本内容一、摘要。摘要是商业计划书最简练的概括，长度通常以2至3页为宜。它的撰写要求精练有力，结果为主，并能回答风险投资者心中的关键问题。作为商业计划书中最重要的一部分，摘要一般放在商业计划书主体完成后撰写。&#8195;&#8195;基本内容二、公司介绍。公司介绍需要给出公司的基本轮廓和基本情况，它包括公司的历史、当前地位、战略发展和未来计划。如果是拟创业的公司，创业者可以模拟成立一个公司来具体介绍。&#8195;&#8195;基本内容三、产品与服务。产品与服务是商业计划书中最重要的部分，也是向投资者明晰产品与服务的核心环节。它主要介绍公司产品与服务的概念、性能及特性、主要产品与服务介绍、产品与服务的市场竞争力、产品与服务的研究和开发过程、发展新产品与服务的计划和成本分析、产品与服务的市场前景预测、产品与服务的品牌和专利等内容。&#8195;&#8195;基本内容四、行业与市场。行业与市场阐述公司外部市场中的关键影响因素。行业分析主要介绍创业公司所归属产业领域的基本情况，以及公司在整个产业中的地位。市场分析主要介绍公司产品与服务的市场情况，包括目标市场、市场竞争中的位置、竞争对手的情况、未来市场的发展趋势等。因此这部分的撰写越详细越好，要以那些可信度高和已经证实的数据作为分析基础。&#8195;&#8195;基本内容五、营销计划。营销计划应该以市场调研和产品与服务的价值为基础，制定产品与服务、定价、促销、渠道等问题的发展战略和实施计划。&#8195;&#8195;基本内容六、生产运营。生产运营需要解决以下几个问题，包括厂址的选取与布局，生产工艺流程，产品的包装与储运等。此外，产品的质量检验也非常重要。如果是服务类产品，可以结合产品和服务的特点介绍这一部分。&#8195;&#8195;基本内容七、公司管理。公司管理需要介绍公司的组织机构图、各部门的功能与职责范围、各部门的负责人及主要成员、公司的报酬体系公司的股东名单（包括股份份额、认股权、比例和特权）、公司的董事会成员、股权分配等。一个稳定团结的核心团队，可以帮助创业者渡过各种难关，是公司最宝贵的财富。马云曾说过：“什么是团队呢？团队就是不要让另外一个人失败，不要让团队任何一个人失败。”&#8195;&#8195;基本内容八、财务计划。财务计划包括融资需求和财务预测报告。融资需求要说明实现公司发展过程中所需要的资金额度、时间表和用途。财务预测是公司发展的价值化表现，它必须与公司的历史业绩和发展趋势相一致，也应该与商业计划书中其他部分的讨论结果相一致。此外，财务预测还应该考虑投资者需要的投资回报率、投资回收方式和股权计划，使投资人可以从中看到企业的成长性。&#8195;&#8195;基本内容九、风险控制。风险控制分析部分说明各种潜在风险，并向风险投资者阐述针对各类风险的规避措施。风险投资者都害怕面对一个存在着不确定因素太多的项目，也害怕面对风险一无所知的创业者。&#8195;&#8195;基本内容十、资本退出。企业发展到一定阶段后，投资者认为有必要、是时候将资本回收的投资战略。这里需要设计最优的资本退出方式，详细说明该退出方式的合理性。若如果公司在计划期内未完成风险资本退出计划，最好要给出次优方案，这样才能让每个风险投资者都清晰地知道获利时间和可选方案。&#8195;&#8195;最后是附录。附录是商业计划书内容的有力补充和说明。在附录中可能出现的附件包括：财务报表、主要合同资料、信誉证明、图片资料、分支机构列表、市场调硏结果、主要创业者履历、技术信息、宣传资料、相关数据的测算和解释、相关获奖和专利证明、授权使用书等。&#8195;&#8195;第三部分，我们给大家讲解一下商业计划书制定前需要了解的基本知识。&#8195;&#8195;第一，创业项目选择的要点和出处。创业者在进行创业项目选择时，应该把握以下几个要点。难模仿：也就是说技术含量高，壁垒高；有创意：创意独特，能满足消费者某种特殊需求；易转化：产业化程度较好；有市场：能够切实解决目前市场上所存在的问题，市场容量大。创业项目的出处主要来自于以下几个方面：创业团队目前已经注册或即将注册的实体公司的主营产品与服务；或者创业团队参与的发明创造、专利技术或创意想法；以及经专家或企业授权的发明创造或专利技术；一项可能研究发现的新概念产品与服务，并准备在未来一段时间内实现该项目的研发或实施；大学科技园技术转化中心推荐的项目、成果汇编、孵化器项目等。获取相关资料主要来源于统计年鉴、文献资料、政府工作报告、专业行业期刊、杂志、咨询公司报告、互联网上的信息、实际调研访谈等。我们要注意，准确和真实的数据获取对于预测、评估具有非常重要的作用。&#8195;&#8195;第二，商业计划书需要有清晰的结构，一般的篇幅在30至40页左右。写完后可以先请外行进行试读，因为计划书要让大多数人从中看到项目的可行性，不要写的晦涩难懂。&#8195;&#8195;第三，创业项目需要简单的说明、草图以及图片进行辅助说明。技术细节和生产流程可以放进附录里描写，关于技术细节最好的撰写模式是用最简单的话说明最复杂的原理，多列举技术依托的项目和团队、所获的发明专利和奖励，增加风险投资者的信心。风投专家不一定希望听到面面俱到的技术细节。&#8195;&#8195;第四，创业项目成功的关键就是满足客户需求。能否明确表明它能满足什么样客户的哪类需求、并且以什么方式去满足？是否具有市场价值、能否提供客户价值？因此，产品与服务只是为客户提供价值的一个手段而已。&#8195;&#8195;第五，项目的可行性和盈利性。首先要进行可行性评估，找出可能导致该项目不可行的具体因素，例如法规方面的考虑、产品的标准等。要描述完成该项目所需要的时间和资源。还要进行盈利性评估：明确指出赚钱的多少和途径、启动阶段创造的毛利润（收入减去产品直接成本）应该是在40%到50%之间。&#8195;&#8195;第六，风险资本如何参与公司发展。风险资本是指风险投资公司或者个人提供的、用来资助和参股新兴项目的资金。一般来说，这样的项目很可能获取高额利润，同时也面临巨大的亏损风险。在创业公司发展过程中，风险资本基本会全程参与其中，在不同的阶段起到不同的作用，其最终目标是收回风险投资。&#8195;&#8195;最后我们来看一下商业计划书的制作流程，分别是构想细化、背景资料获取和市场调研、撰写制作、答辩和反馈。&#8195;&#8195;在构想细化部分，主要回答几个基本问题：产品与服务是什么？目标人群？市场容量？竞争对手？竞争优势？&#8195;&#8195;背景资料获取和市场调研部分，我们需要对行业进行了解。同时针对现有和潜在客户的数量，他们愿意支付的价钱、产品与服务对客户的经济价值、购买周期等进行市场调研。竞争对手方面需要对对手产品与服务的特点和性能，以及对手的竞争方式进行分析。&#8195;&#8195;撰写制作方面，关于市场分析一般是3到5页，用来量化市场机会，建立在市场调查和竞争者调查的基础上。关于公司运营也可以写到3到5页的篇幅，从今天到将来的运作方式。关于团队建设，可以以2到3页的篇幅来阐述团队合理性及成员分工。关于财务分析，围绕价值评估、收益率、三大报表进行阐述。最后是摘要和封面。&#8195;&#8195;创业项目在争取投资之前，需要进行答辩和反馈，因此我们需要准备答辩稿和PPT。PPT围绕10分钟左右的时间来进行组织，需要强调获取成功的关键因素。同时，我们要以容易理解的讲解逻辑进行阐述。&#8195;&#8195;在商业计划书撰写的过程中，我们尤其强调了摘要的内容。因为很多投资人计划书重点看摘要，就体现了摘要撰写的重要性。&#8195;&#8195;商业计划书摘要一般包括公司介绍、产品与服务、行业与市场、营销计划、生产管理、公司管理、财务计划、风险控制与退出方式等，撰写者可以根据需求增减内容。介绍创业公司时，要说创办思路、思想形成过程、公司目标及发展战略、公司现状、过去的背景、经营范围以及创业者背景、经历、经验和特长。&#8195;&#8195;同时还需要回答摘要中的一些核心问题，包括公司所处的行业与市场、公司经营的性质和范围、公司的主要产品和技术的内容，以及公司所面临的目标市场在哪里、谁是企业的目标客户以及他们的需求，要阐述公司现有的合伙人、投资人是谁，以及分析出竞争对手是谁。&#8195;&#8195;摘要需要简明生动，不要进行详细分析，多给出结论时的阐述，详述公司的竞争优势，以及获取成功的市场因素。&#8195;&#8195;最后要注意，摘要撰写时需要放在最后完成，也就是写完正文以后完成。要有针对性，文笔生动，开门见山，夺人眼球，重点突出，语句通顺，无错别字。&#8195;&#8195;在商业计划书制作中，也有几个方面要回避。一是忌言辞过于技术化、专业化；二是忌陈述或数据含糊不清、无确切根据；三忌隐瞒事实真相；四忌数据没出处。&#8195;&#8195;好，今天我们的内容就讲到这里，谢谢大家。  \n公司介绍&#8195;&#8195;同学们好。今天我们来讲解一下公司简介。&#8195;&#8195;首先我们为大家介绍一下公司简介部分的主要内容，包括基本的信息和重要的信息。基本信息主要包括公司概述、公司名称、地址、联系方式等。重要信息主要说明自然业务情况和发展历史、公司未来的发展规划、拥有的竞争优势和独特性、公司所属的类别以及从属关系，还有公司所具有的专利和商标，以及已有的投资者或合伙人。同时，新创企业需要说明创办新企业的思路、新思想的形成过程、以及企业的目标和发展战略。另外，创业者的自己的经历、背景、经验和特长需要在此部分进行阐述。&#8195;&#8195;接下来我们来讲解一下，这里所涉及到的一些基本理论和概念。&#8195;&#8195;第一，公司基本情况介绍。要阐明法律名称、商标或品牌名称、公司类型（初创企业需虚拟一个弹性较大、经营范围较广的名称避免限制企业业务的拓展和经营方向的改变）。关于主要业务，需要尽可能快速地让风险投资者了解企业的主要产品与服务进行说明。经营地点介绍，要说明公司总部所在地点、主要经营生产场所，一定要介绍公司业务范围所覆盖的地区情况。如果随着时间业务方位和覆盖地区有所变化，那就需要说明初期是什么，多少年后又有哪些变化。企业有不同的类型，我们按照企业的组织形式、法律责任、不同需求对设立企业进行分类和股权说明。通常在我国按经济类型分，企业法定种类主要有国有企业、集体所有制企业、私营企业、股份制企业、联营企业、外商投资企业、港澳台投资企业和股份合作企业。&#8195;&#8195;第二，关于公司的宗旨和目标。公司宗旨可以以最精炼、清晰的语言来表述企业的使命与指导方针（经营理念）。公司描述基本内容有以下几个方面。首先是获利能力，包括获利程度及贡献。其次是外部追求，对公众注意事项的关心，对股东、员工、供应商注意事项的关心等。还有产品效率、产品质量、企业氛围、行业规范等。例如为顾客服务；求精求简求实用；为提升学生终身竞争力等方面，公司目标是公司使命和指导方针的具体化和数量化，反映企业在一定时期内经营活动的方向和要求达到的数量水平。公司目标的实现一般为3到5年。好的目标实现起来与外部环境密切相关，对公司发展具有正向的激励作用。&#8195;&#8195;第三，公司的组织形式和申请流程。根据相关法规，现代企业制度的常见组织形式有：有限责任公司，2-50个股东共同出资，每个股东以其所认缴的出资额对公司承担有限责任，公司以其全部资产对其债务承担责任，包括国有独资公司和其他有限责任公司；股份有限公司，是指全部注册资本由等额股份构成并通过发行股票筹集资本，股东以其认购的股份对公司承担有限责任，公司以其全部资产对其债务承担责任的经济组织。有限责任公司是最常用的一种企业组织形式，其主要特点是股东仅就其出资额为限对公司负责；股东人数一般都有最高人数的限制，在中国是不超过50人；不能公开募集股份，不能发行股票，只能由发起人集资；股东出资的转让有严格限制，信息不公开；设立程序要比股份有限公司简便。创业公司初期多为这种类型的形式。股份有限公司的特点是，这是一种最典型的法人组织，有完备的组织机构，完全独立的财产及其责任；股东必须达到法定的人数，可以公开募集资金；资本划分为均等的股份；股东承担有限责任。&#8195;&#8195;第四，公司发展历史与未来发展的规划。公司发展历史，不同企业阐述的角度有所不同。对于初创企业，可以详细介绍公司的成型过程，例如创意是如何产生的、产品与服务的现状、技术水平和可持续创新能力、已经投入了哪些人财物、关键人员在其中起到的作用等。对于现有的成熟企业，可以描述初次提供产品与服务的时间、目标人群和客户、公司业务经历了几个阶段等。创业企业也需要一个清晰的未来发展规划，我们可以按照时间顺序，对未来的业务发展提供可行的计划，指出发展的关键节点在哪里，投资未来将用到哪些方面的资源。同时需要制定创业公司未来五年的发展计划。例如可以说 “本公司在未来五年生产和销售某一种主要产品，在第三年将继续开发出另一种产品投向市场” 等。&#8195;&#8195;公司介绍的注意事项。团队成员介绍的数量选择3到5位关键人物即可，不宜过多。团队介绍的顺序，按照从职位高到职位低，同等职位按照创业经历长短的原则。其中常见职位有总经理、总裁、常务副总经理、人事部经理、营销部经理、财务部经理、生产部经理。那么我们需要介绍哪些方面的内容呢？主要有教育背景、工作背景和业绩、领导能力和个人品质、团队整体特点等。&#8195;&#8195;写完计划书的公司介绍部分，我们最后需要总结一下几个关键问题是否得到了回应。第一，公司的类型、注册地址、商标、宗旨和目标都是什么？第二，公司的基本业务和发展历史是怎样的？第三，公司的未来发展规划是如何构思的？第四，公司的团队成员包括哪些人？他们有什么突出的地方（例如教育背景、专业经验，以往的成功经历，在商界的出众表现等）？第五，团队成员有哪些经验或能力？团队缺乏什么样的经验和能力？你打算如何弥补这些差距？由谁来弥补？每个团队成员的动力有多大？第六，公司具有哪些知识产权？如何进行保护？如何体现未来的可持续创新能力？&#8195;&#8195;以上问题也是本讲的主要内容。今天我们就讲到这里，谢谢。  \n产品与服务&#8195;&#8195;同学们好。今天我们来讲一下产品与服务。&#8195;&#8195;首先我们来看一下产品与服务包括的主要内容。在产品与服务的基本介绍方面，我们应该围绕以下内容展开。一、需要围绕产品相关概念、技能、特性进行详细阐述，说明与市场同类产品的差异性和优越性，这是产品的基本点。二、对拟向市场提供的主要产品与服务进行介绍。三、描述产品研究和开发过程，需要介绍技术先进性。四、通过SWOT分析工具进行产品的市场竞争力研究。五、计划和成本分析，需要阐明是否具有成本优势。六、对产品的市场前景情况进行适当预测分析。七、回答风投和阅读者关心的，是否已经设计了产品品牌，品牌知名度如何，是否掌握一些核心专利技术和标准。&#8195;&#8195;下面我们来介绍一些关于产品与服务的基本理论知识。在撰写产品与服务部分，要注意避免过多技术细节的展示，使用通俗的语言整理归纳产品服务的功能、特点、竞争优势等信息，具体包括，创新性：围绕创新性可以进行细节阐述，可与竞争对手进行分析，提出自己的竞争优势；独特的功能价值：潜在竞争对手分析，例如具有什么新功能，具有什么社会价值等等；额外的价值增值：与提供替代性产品的对手进行比较分析。最后，在这一部分的撰写要详略得当，介绍核心产品是主要的任务。&#8195;&#8195;第二，关于产品与服务的规划开发。在这部分要重点阐述产品与服务的规划和系列化、产品服务的准确定位、产品服务线的长度和宽度、生命周期规划等等。我们需要讲清技术研发力量和未来的技术发展趋势，还需要详细阐述公司研发新产品与服务的成本核算、研发进度、时间规划等。产品与服务规划部分需要分为三部分内容进行撰写：一是进行产品市场的细分及选择，二是新产品与服务的定位，三是新产品的规划和开发。&#8195;&#8195;第三，关于新产品的创意和开发。产品创意是否好，决定着产品的未来。因此，我们拟定四个评判标准进行衡量。一是考察是否明确客户价值，二要有足够大的市场容量，三是具备足够的创新度，四是具有可信性和盈利性。那么创意从何而来呢？其主要来源有客户分析得出、竞争对手分析获知、前期沟通对象的多元化而来、各类专业知识交叉而来等等。对于新产品的创意和开发，我们需要遵循以下步骤：首先要产生创意，进而开始概念开发和测试，开发完成要进行产品开发和测试，然后进入市场进行测试，最后做出最终是否具备可行性的新产品生产策略。&#8195;&#8195;第四，产品生命周期理论。任何产品都有生命周期。我们按照产品生命周期理论，把时间维度分为导入期、成长期、成熟期和衰退期或蜕变期。在成熟期之前，产品销量会逐渐上升，并达到顶点，后转为衰退，逐渐退出市场，市场销量也随之萎缩。抑或者我们可以进行产品创新，升级改造，也就转化为蜕变期，其产品销量反而逐渐上升。产品生命周期理论中，在不同结算的客户、成本、竞争对手、营销目标、产品价格、渠道、盈利模式情况，如图所示。&#8195;&#8195;第五，增强产品竞争力的方法。要想增强产品竞争力，通常最主要有两点。一是做到产品差异化，二是实施经营差异化。这两点就像两个法宝，需要创业者随时牢记。增强产品竞争力的方法主要有以下这些方面。一、垄断可以增强产品的竞争力。二、如果具有不可比拟的技术标准和技术壁垒也是可行的。三、进入战略联盟，促进产品的优势。四、依托技术进步，推出蕴含高新技术的产品，产品足够创新。五、快速丰富产品线，因为单一的产品很难取胜。六、快速推出新产品，产品绝不能一成不变。七、塑造强势品牌，走品牌战略，因为品牌可以带来无形的价值和效益。八、通过创新不断塑造差异化优势。九、通过性价比获取竞争优势。十、有效的客户关系管理极其重要，如何提高用户的粘性和回报率。&#8195;&#8195;最后，我们总结一下产品与服务部分在撰写和思考时的注意事项。第一，公司要面对什么样的最终客户？客户需要企业的产品与服务解决什么问题？客户能从企业的产品和服务中获得什么样的客户价值？第二，公司的产品和竞争对手的产品相比有哪些优缺点？客户为什么会选择本企业的产品？第三，公司为自己的产品采取了哪些保护措施？企业拥有哪些专利、许可证，或者已经申请专利的厂家达成了哪些协议？第四，为什么公司的产品定价可以使公司产生足够的利润？为什么客户会大批量购买该产品？第五，你的产品服务处于哪个发展阶段？公司采用何种方式去改进产品的质量、性能？公司对发展新产品有哪些计划？&#8195;&#8195;以上总结的问题也是本讲的主要内容。谢谢大家，我们下一讲再见。  \n市场分析&#8195;&#8195;同学们好，这一节我们讲一下市场分析。我们主要围绕创业项目中面临的行业与市场进行讲解。&#8195;&#8195;首先我们讨论一下行业与市场的主要内容。行业与市场是在一个广阔的商业环境中，虽然相互分开，但却有重叠的部分，其含义有所不同。那么什么是行业呢？它是向生产并向特定市场销售同类产品与服务的一个公司群，既可以界定公司的同类企业，也可以界定竞争对手。行业分析主要介绍创业公司所归属的产业领域的基本情况，以及公司在整个产业中的地位。什么是市场呢？销售公司产品与服务的地方，用来确定公司的机会和客户，所以市场分析主要就是介绍公司产品服务的市场情况，包括目标市场、市场竞争中的位置、竞争对手的情况、未来市场的发展趋势等等。在行业和市场分析之前，我们需要大量的市场调研和消费者调研，才能够了解一手资料。&#8195;&#8195;那么下面我们来关注一下有关行业和市场的基本理论。&#8195;&#8195;知识行业的主要经济特性有以下重要因素。一、市场规模：市场规模小的项目可能不值得我们去创业。二、竞争角逐范围：与之竞争的范围进行界定，更多的是依靠所属行业经营划分。三、市场增长速度：这是一个重要指标，能够支撑项目在短期内获得成功。四、行业和产品在成长周期中所处的阶段：如果是成熟期及以后的行业，就没有介入的价值了。五、竞争厂家的数量及规模：竞争越激烈，竞争的难度也就越大，因此要进行很好的自我度量。六、购买者的数量及相对规模。七、分销渠道：它是产品迅速推向客户的重要保证，尤其重要，不要指望所有的产品都亲自销售。八、行业中公司能否实现规模经济：这样可以有效降低生产和销售的成本。九、进入和退出市场的难度：如果难以进入市场，对于现存企业是极其有利的，但对于创业者却是不利的。十、创新速度的影响：创新的意义不言而喻，创新越快，产品升级越快，市场欢迎度越高。&#8195;&#8195;行业中的关键成功因素主要包括技术相关因素（即技术创新能力、产品创新能力、在既定技术上的专有技能、运用网络发布信息、承接订单、送货和提供服务等能力）、制造相关因素（主要是生产效率、固定资产的利用率、生产工厂定位、足够的熟练劳动力、产品设计和产品工程，还要能够定制化的生产一系列规格的产品）、市场营销相关因素（快速准确的技术支持、礼貌的客户服务、准确地满足客户订单、产品线和可供选择的产品很宽泛、推销技巧、具有吸引力的包装、精准的广告）、分销相关因素（是否具有强大的批发分销商、通过互联网建立起来的电子化的分销能力、能够在零售商的货架上获得足够的空间、拥有公司自己的分销渠道和网点）、技能相关因素（劳动力的技能水平、质量控制、设计、在某一项具体的技术上的专有技能、能够开发出创造性的产品、能够使最近构想出的产品快速的经过研发阶段到达市场、卓越的信息系统、能够快速的对变化的市场做出迅速反应、能够熟练的使用互联网和电子商务做生意等等）。&#8195;&#8195;市场结构和类型市场类型，包括完全竞争、垄断竞争、寡头竞争和完全垄断四种，其企业数量、产品差异、价格和行业进出难以程度见表格所示。对于大学生初创企业来说，要尽可能选择完全竞争的行业进入，否则很难打入具有垄断特质的市场。同时，我们需要对行业外部环境和内部情况进行分析，通常我们使用成熟的分析方法。首先针对行业外部环境，我们可以使用Test 分析法。Test分析代表政治、经济、社会、技术等因素。&#8195;&#8195;政治因素。我们可以考虑本地、本国和全球的政治因素影响，包括，一、直接税和间接税，例如对消费者支出和市场需求产生影响的所得税和增值税。二、中央及各级政府的公共支出对市场需求水平的直接影响。三、中央及各级政府的产业政策在微观层面上对企业的影响，如地方拨款补贴、税收优惠等会影响企业的生产和经营选择。四、货币政策对市场需求和企业还贷能力的影响。五、国际贸易环境的改变对出口市场的影响，如中国加入各类贸易组织，促进产品的进出口。六、法律对于企业的扩张的影响，如法律如何规定并购、垄断等。&#8195;&#8195;经济因素。可以考虑本地国家和全球的经济因素影响，包括，一、经济周期：在经济周期的不同阶段，经济可能会呈现快速的发展，也有可能停滞不前。有的行业，例如休闲、餐饮、服装等消费数量与经济周期变化紧密相连，非常容易受到经济周期的影响和冲击。二、就业率：就业率以当地的经济状况密切相关，一个地区的就业率高，意味着当地消费需求能力强，同时也说明劳动力的价格将会更加昂贵。三、通货膨胀率：通货膨胀对企业有多方面影响。从产品角度说，如果是需求增加导致的通货膨胀，可以使企业增加收益。从原材料角度说，如果原材料成本增加导致的通货膨胀会导致企业收益下降。四、利率和汇率：虽然企业能采取一些方法规避利率和汇率风险，但是利率和汇率的变动会影响企业的盈利能力。五、房价和股价：房价和股价的变动都会影响消费者的消费信心和消费能力，所以最终也会转嫁到企业的销售额。&#8195;&#8195;社会因素。某个国家的人口迁徙和社会价值变化需要经历很长的时间。所以，人口和社会价值往往是产品与服务需求探讨的起点。我们可以考虑的社会因素，包括，一、人口变化：人口的变化速度，对于开发产品与服务的规模具有直接影响。由于发展中国家的人口增长速度明显高于发达国家，所以创业型公司在未来应该更加关注发展中国家。二、年龄结构：人口年龄结构的差异，会对产品消费数量和种类产生影响。此外，还会对就业人数产生影响。三、人口从农村迁徙到城市的速度：随着全球产业升级和结构化的转变，以及国家城镇化的发展，大量的农村人口向城市迁徙，这就导致劳动力和潜在消费者的人数直接增加。四、社会和文化的变化：对于工作和休闲态度的转变，会对某些产品的需求和劳动力人数产生影响。此外，妇女在社会中的角色转变，也会对劳动力和产品需求以及供给产生影响。&#8195;&#8195;技术因素。技术变革对经济会产生巨大的影响。可以考虑的技术因素，包括，一、技术创新能力和研发水平以及新产品：对某些以特定技术为基础的产品以服务来说，新技术的导入就意味着新市场的诞生。二、生产和工艺创新：新的生产和工艺将带来效率的提升、成本降低，这对消费力量和市场竞争水平都有直接影响。三、新技术的使用效率：新技术能否快速融入到产品进入市场，将会对市场结构、收益和需求产生直接影响。&#8195;&#8195;另外，如果从行业内部看，我们可以使用波特五力竞争模型，对行业进行分析，其主要从供方议价能力、买方议价能力、潜在进入者、替代品、产业竞争对手等五个方面进行分析。在进行SWOT分析时，我们要分清楚企业的优势、劣势，以及外部因素中的机会和威胁，形成SWOT表格，如图所示。SWOT分析可以分三个步骤，首先分析环境因素，其次构造SWOT矩阵，最后制定可以推荐的行动计划。另外我们也可以制定竞争强弱对比分析表。这个分析表可以是单个的，也可以是多个。我们可以根据价格、质量、服务等三十几个指标进行对标分析，具体如表格所示。&#8195;&#8195;市场总需求与市场细分和定位。市场总需求（或者叫做市场容量），是指行业在既定环境下，一定的时期和地域内，客户全体购买产品和劳务的总量，前提是要掌握往年或历年市场总需求的增长变化情况，收集这些相关因素的变化情况，历年的趋势分析以及对外环境的状况分析，预测出总需求的大小。关于市场细分，根据消费者的不同需求，把整体市场划分为不同的消费者群体。市场细分方式可以按照地理细分，（国家、城市、乡村等）、人口细分（年龄、性别、收入、职业、教育等）、心理细分（社会阶层、生活方式、个性等）、行为细分（时机、使用者地位、忠诚度、产品使用效率、产品应用等）、受益细分（追求的具体利益、产品带来的好处等）。&#8195;&#8195;目标市场选择的注意事项。首先，市场规模有足够大的发展和盈利空间。其次，目标市场要有良好的发展前景。&#8195;&#8195;最后我们总结一下，在本节内容里面需要注意和解决的问题。第一，该行业发展现状如何？发展趋势怎么样？利润率怎么样？决定行业发展的成功因素有哪些？第二，经济发展和政府是如何影响该行业？是什么因素决定着行业的发展？第三，公司所处的市场结构和竞争情况如何？进入该行业的障碍是什么？企业可以参与哪些竞争策略？第四，你的三个最主要的竞争对手是谁？对比你的主要竞争对手，企业的发展、市场和地理位置如何？如果没有直接竞争对手，那么谁有可能是你的潜在经营者？第五，企业所处市场总需求和市场细分情况如何？目标市场在哪里？第六，针对该市场状况，企业未来3到5年市场销售预测？占有市场份额是多少？&#8195;&#8195;同学们以上问题也是本讲的主要内容。谢谢，我们下一讲再见。  \n营销计划&#8195;&#8195;欢迎同学们回来。本节我们主要围绕创业中的营销计划进行讲解。&#8195;&#8195;首先我们来讲解一下营销计划的主要内容。生活中，我们经常听到“营销”和“销售”两个词语，那么它们之间的区别是什么呢？营销是一个系统，而销售是营销系统的-部分具有包含关系。营销是为了满足客户需求，让产品好卖；而销售是卖好产品与服务，是主动行为。营销需要战略层面思考，注重建立持续销售的系统；而销售是战术思考，通过销售技巧，达到产品与服务的销售目标。营销计划包括市场调研、市场推广、品牌策划、销售客户服务等等。&#8195;&#8195;那么我们分别来讲解一下，营销中涉及的基本理论知识。&#8195;&#8195;第一，营销方案的制定。好的产品需要好的营销方案，产品营销方案制定过程需要四个步骤。一、产品构思和设想：为描述产品与服务确定需求，对市场和市场机会做出说明。二、市场调研：对消费者、竞争对手、市场基本情况的调研，帮助创业者判断和预测。三、市场定位和客户选择：深入了解细分市场。四、围绕产品、渠道、定价、促销及市场定位分析的4P营销策略。五、销售预测：促进风险投资者理解营销目标和财务报表。&#8195;&#8195;第二，关于市场调研。市场调研可以帮助创业者掌握一手的市场数据，为自己的决策和产品分析提供支持，因此市场调研的好坏也至关重要。通常市场调研的详细方法，可以参照以下表格的详细流程。那么大家要注意，在设计调查问题时，也应该掌握以下原则和技巧。一、提问的内容尽可能短：所有人愿意回答简单的问题。二、内容简洁：被调查的人往往不愿意花更多的时间去做这些看似对他们无所谓的事情，因此要力求简洁。三、不要诱导回答：只有这样才能保证调研的客观公正性。四、在一项提问中只包含一项内容，否则容易分散调查目标。五、提问最好能在被提问者记忆范围之内。六、请问的意思和范围必须明确，不要涉及模棱两可的问题。七、避免提出人们反感或很偏门的问题。&#8195;&#8195;调研结束后，我们需要将调研情况以报告书的形式记录和整理下来。报告的撰写原则有如下几条。一、我们把调研报告的式样与委托人的需求联系起来，撰写两种（或多种）版本的调硏报告，对技术和管理人员进行访谈。二、调研报告中的图表应该有标题，对计量单位应清楚地加以说明。如果采用了已经公布的资料应该注明资料来源。三、把调研报告的小册子提前交给风险投资者过目，以便风险投资者有机会对调查结果进行仔细审查从而提出他们的问题。四、在一个有逻辑的框架中陈述调硏结果。&#8195;&#8195;那么市场调研的方法有哪些呢？主要以下几种的方法。一、询问法：实施方法包括传统的电话访问、入户访问、拦截访问、小组座谈、深度访谈法、邮寄调查表法等等。二、观察法：就要调查对象的行动与意识，调查者通过观察边记录以收集信息。观察法一般分为自由观察法和组织观察法。三、实验法：设定特殊的实验场所、状况来进行调查。即一部分为附加若干实验因子的实验群，另一部分为未附加实验因子的对象群，然后再分类实施调查。&#8195;&#8195;那么我们重点阐述一下4P营销理论。它被归结为四个基本的策略组合，即产品、价格、渠道、促销。由于这四个英文单词的字母第一个都是P，再加上策略S，所以有时候我们简称“4PS”。&#8195;&#8195;首先我们看产品策略。产品的整体概念。产品是指人们向市场提供的能满足客户需求的有形产品和无形服务。有形产品包括产品实体，以及所包含的品质、特色、式样、商标和包装等。无形服务则包括可以给客户带来附加利益和心理上满足感和信任感的售后服务、销售声誉、产品形象等。产品整体的概念有三个基本层次，即扩大产品（产品的各种附加利益综合，通常是指各种售后服务）、形式产品（核心产品的表现形式是向市场提供实体和劳务时，可以为消费者识别的特征）、核心产品（产品营销中最基本层次，它是指为客户提供最基本的效用和价值）。&#8195;&#8195;价格策略。价格的定义分为狭义和广义。狭义上说是每种商品具体单位的货币形式；广义上是指交换过程中所支付的一切条件，既包括直接的货币价值，也包括间接的、现期的和未来的代价。那么影响价格的因素主要有如下这些方面：成本、市场需求、竞争状况、消费者心理和政策法规等。其中，产品价值是产品价格的基础。在市场营销中，除了产品成本、市场供求、竞争状况外，市场营销组合中的产品策略、渠道策略、促销策略都在直接和间接地影响价格。定价是一个复杂的事情，定价的目标要以利润为目标，以销售额和市场占有率为目标，同时有的也可以以形象或者以竞争为目标。公司定价的基本方法包括撇脂定价策略（高价格策略）、渗透定价策略（低价格策略）、满意定价策略（适中定价策略）。&#8195;&#8195;关于渠道策略。首先我们要搞清楚分销渠道的类型。主要有长渠道和短渠道、直接渠道和间接渠道、宽渠道和窄渠道、传统渠道和整合渠道。另外，渠道中离不开中间商。中间商的类型有经销商、代理商、批发商、零售商等。&#8195;&#8195;关于促销策略。促销是企业综合运用人员推销、广告、营业推广和公共关系等手段，向消费者传递信息，引发、刺激消费者的购买欲望和兴趣，促使其产生购买行为的系列活动。促销的核心是沟通信息；目的是刺激消费者产生购买行为；方式可以通过人员促销和非人员促销，例如广告、营业推广、广告植入、公共关系等。在促销策略中，我们可以采用人员推销策略（沟通灵活，精准素质）、广告策略（找准人群，精准定位）、公共关系策略（树立形象，促进销售）、营业推广策略（短期诱因，刺激需求）。实际生活中往往使用这四种策略的组合，我们叫做促销组合。&#8195;&#8195;在这一节最后，我们总结一下需要注意和解决的问题。第一，将采用何种市场调研方式去获取市场信息？如何确定企业目标市场和人群？第二，企业发展各阶段的销售计划和销售额目标是多少（预计）？第三，对于每个目标市场和分销渠道，希望最终的产品与服务销售价格是多少（预计）？你使用什么样的标准得出这一最终销售价格？在这种情况下利润率有多高（预计）？第四，企业计划从哪些客户群着手进入市场？打算如何把这个小小的立足点扩展成一个规模很大的业务？第五，阐述你销售产品与服务的典型流程，在潜在客户中间，谁最终购买产品？&#8195;&#8195;好，以上问题是本讲的所有内容。谢谢，我们下一讲再见。  \n生产运营&#8195;&#8195;同学们好，欢迎大家进入创新创业基础课程。这一节我们来讲解一下生产运营。&#8195;&#8195;首先我们来看一下生产运营的主要内容。企业的生产运营主要包括公司生产制造所需的厂房选址、工艺流程和设备的引进情况、生产周期标准的制定以及生产作业计划的编制、物料需求计划及其保证劳动力的需求、库存管理情况、质量控制的方法。下面我们围绕生产运营，介绍一些基本理论知识。&#8195;&#8195;一、厂商选址规划。关于不同企业的厂址的选择，有很多的影响因素。关于生产制造业选址的影响因素有接近市场所在地、接近原材料所在地、运输和物流便利性、外协公司相对位置、接近劳动力资源、优惠的政策和法规条件等等。关于服务性公司，其选址的影响因素主要涉及到顾客到服务提供处的便利程度（例如宾馆、饭店、商场等服务型企业）、服务提供者到顾客的便利程度（例如搬家、维修、装修等方面）、服务提供者与顾客在虚拟空间完成了交易情况（例如网络购物、网络订票等服务）。对于生产制造公司的选址，我们需要有一个评价方法，它通常使用因素评分法，将交通条件、工资水平、原料供应、职业教育、公共设施等7项因素分别设置权重，计算打分后加权得分进行比较分析。权重值的确定可以采用专家打分法和层次分析法得到。对于零售企业的选址评价方法，我们有如下步骤。首先，进行商圈分析，评价每个区域的居民及现有商铺的特点。其次，选择开店的区域，评价是在一个未规划的商业区内开设孤立商铺，还是要在该区域的一个规划的购物中心内开设新店。然后，选择大体位置，选择孤立商铺、无规划商业区域或规划的购物中心的位置。最后，确定具体的位置，分析在特定的零售区域类型中可供选择的商铺位置。零售企业选址评价方法可以采用商铺地址决策评价要素，通过客流量、车流量、停车设施、交通条件、具体店址等8项指标进行定性或定量分析，进而给出零售企业选址的全面评价，供创业者进行选址决策参考。&#8195;&#8195;二、产运营能力的评估。生产运营能力是指人员能力、设备能力和管理能力的总和。那么我们需要注意，生产运营能力的度量主要处理好两个关系，一是投入量和产出量的比较关系，二是设计能力和有效能力的比较。同时，合理的生产运营能力的规划对于评估创业项目具有极其重要的意义。&#8195;&#8195;三、库存管理。库存是指公司用于今后销售或使用的储备物料，它包括原材料、半成品、成品等不同形态。那么为什么我们一定要持有库存呢？主要考虑到以下几个原因：预防不确定性的随机需求变动、保持生产的连续性与稳定性、经济批量订货。库存的类型按照功能分，包括在途库存、安全库存、预期库存、周转库存；按照状态分，分为原材料、保养、维修和操作类物料、在制品、产成品。库存利弊分析：它的优点主要是能够提升服务质量、节约订货费用、节约相关生产费用；同时库存的缺点是增加了库存的成本、掩盖生产经营中存在的问题、占用了大量的资金流。&#8195;&#8195;四、生产作业计划和生产周期。生产作业计划编制工作的主要内容包括收集编制计划所需要的各种资料，核算、平衡生产能力，制定期量标准和编制生产作业计划。生产周期是指企业产品从原材料投入生产到制成品出产时为止，整个生产过程所需要经历的时间，包括毛坯制造、零件加工产品装配等工艺阶段的生产周期。&#8195;&#8195;五、劳动力和原材料需求。在商业计划书中，需要表明公司有足够的物质资源，可以研发和生产自己的产品。需要估计对原材料的需求量，阐述供应商的背景，以及如果出现意外的情况时，备选供应商是谁。在人力资源方面，在招聘各类人员时最好对所需职位的背景及特殊需求进行细化。&#8195;&#8195;好，下面我们总结一下这一节需要注意和解决的问题。第一，不同类型公司选址可以采用何种方法？采用何种评价指标来衡量选址问题？第二，你正在计划什么样的生产过程？怎样保证新产品在进入规模生产时的稳定性和可靠性？第三，设备的引进和安装情况？谁是供应商？生产线的设计与产品组装是怎样的？工艺流程的设计需要考虑的因素和方法？生产周期标准的制定以及生产作业计划的编制如何？第四，你打算具备多大的产品生产能力和服务提供能力（产品数）？第五，物料需求计划如何？你需要什么样的产品和工具？需要什么原材料？你将从第三者或供应商手中购买什么原材料，部件或服务？第六，如果你需要一个仓库，你打算如何组织安排你的库存？第七，你的成本结构（固定成本、可变成本）是怎样的？第八，在保证产品质量方面采取了哪些措施？&#8195;&#8195;好，以上就是本讲的主要内容。谢谢大家。  \n公司管理&#8195;&#8195;同学们好。今天我们来讲一下公司管理。&#8195;&#8195;首先我们来看一下公司管理的主要内容。公司管理的内容主要包括公司的组织机构图、各部门的功能与职责范围、各部门的负责人及主要成员、公司的报酬体系、公司的股东名单（包括股份份额、认股权比例和特权）。尤其要注意的是，公司的董事会成员以及股权分配情况，因为这一部分内容需要引起创业者足够重视，有太多的现实案例说明，由于初创人员对于公司管理的知识不足，导致了满盘皆输的例子。&#8195;&#8195;下面我们来看一下关于公司管理的一些基本概念。&#8195;&#8195;第一，公司的定义。公司是指由两个或两个以上的出资者（也称为股东）出资兴办并组成一个法人，能够独立自主经营，自负盈亏，并对共同出资经营的财产享有民事权利，承担民事责任的经济实体。公司有一定的优缺点，优点是实行有限责任制度、筹集资金能力强、具有独立的寿命、管理效率较高；缺点就是手续较繁杂、限制较多、财务信息公开、双重缴纳所得税等。&#8195;&#8195;第二，公司管理的管理幅度与管理层次。管理幅度是指任何主管能够直接有效地指挥和监督的下属数量，这个下属数量总是有限的。许多时候它又称为“管理宽度”。有效管理幅度的大小会受到管理者本身素质及被管理者的员工素质、沟通层度、工作内容、组织文化工作环境与工作条件等诸多因素影响，一般对初创企业来说，高层管理幅度3到6人较为合适，中层管理5到9人较为合适，低层管理幅度7到15人较为合理。管理层次是指最高主管的委托人需要将委托担任的部分管理工作再委托给另一些人来协助进行，以此类推，直至受托人能直接安排和协调组织成员执行具体业务活动，由此形成组织中从最高主管到具体工作人员之间的不同管理层次。随着经济的发展和技术的进步，企业的组织趋于扁平化，就是组织通过增大管理幅度，减少层次来提高组织信息收集、传递和决策的效率，最终发挥组织的内在潜力和创新能力，从而提高组织的整体绩效，完成组织的战略目标。&#8195;&#8195;第三，公司组织结构。公司组织结构分为直线型、职能型、直线职能型、事业部制组织结构。各种组织结构适用于不同的企业发展阶段、不同企业产品或不同的企业文化，每种结构各有优劣，需要因地制宜。&#8195;&#8195;第四，相关部门和重要岗位职责介绍。企业重要部门有哪些呢？一个完备的现代企业主要包括以下相关部门：行政部门、人事部门、计划发展部门、财务部门、采购部门、营销部门、生产管理部门、技术工程部门、品质管理部门以及产品研发部门等。与之相对应的岗位包括董事长、公司总经理、副总经理、财务总监、人事行政总监、市场总监、运营总监、技术质量总监、生产总监。&#8195;&#8195;第五，股权划分。首先我们要知道股份分配的基本原则。第一个原则是投入的资产越高，股份应当越高。当然，这里的资产不仅仅包括实物资产和资金，还包括投入的软资本，也就是劳动和技术，这就是所谓的资金入股和技术入股。第二个原则是管理者对行业理解越深刻，能够把团队带向正确的方向，说话的份量应该越重，股份也应当越高。&#8195;&#8195;在这节里，我们总结了如下一些需要注意和解决的问题。第一，创业公司适用于什么公司性质、组织形式，以及选择该性质的公司及该类型的组织形式的优缺点？第二，公司组织结构图是怎样的？公司组织结构中包括哪些职位？第三，公司各部门的主要负责人及成员？其人员数量和报酬体系如何？第四，公司的股权人背景资料和股权如何划分？公司的融资需求、用途、使用计划、拟出让股份、投资者权利等有何计划？&#8195;&#8195;以上就是公司管理部分的主要内容。我们下一节再见。  \n财务计划&#8195;&#8195;同学们好，欢迎回到创新创业基础课程。这一节我们来讲一下财务计划。&#8195;&#8195;财务计划部分需要创业者了解财务计划的基本内容、分析财务计划的预测、掌握会计制作三大财务报表、归纳和理解公司的基本财务指标、掌握盈亏平衡的计算方法等。同时，同学们要注意，财务计划不仅仅是财务总监的事情，创业领导者也要随时了解并掌控财务管理的内容。&#8195;&#8195;首先，我们来看一下财务计划的主要内容。财务计划包括三大报表制作和分析，即现金流量表，资产负债表和损益表。在制作这些表格之前，我们必须搜集到一些具体的财务数据：销售收入，销售成本，管理费用，销售费用，资金支付，债务利率，收入税率，应收账款，应付账款，存货周转和资产利用率等。有了这些数据我们可以制定3到5年的财务计划，计算盈亏平衡点，对资金的来源和使用进行合理计划。&#8195;&#8195;下面我们来看一下财务计划里面设计的一些基本理论知识。&#8195;&#8195;第一，财务计划中的预测和假设。在做财务计划时，最重要的假设和要素数据就是预期销售量，其次是销售的成本和毛利润。&#8195;&#8195;第二，财务报表分析。一、资产负债表。资产负债表亦称财务状况表，表示企业在一定日期的财务状况的主要会计报表，资产负债表利用会计平衡原则，将合乎会计原则的资产、负债、股东权益、交易科目分为“资产”和“负债及股东权益”两大区块，在经过分录、转帐、分类帐、试算、调整等会计程序后，以特定日期的静态企业情况为基准，浓缩成一张报表。资产负债表反映了公司在特定时点的财务状况，是公司的经营管理活动结果的集中体现。通过分析公司的资产负债表，能够揭示出公司偿还短期债务的能力，公司经营稳健与否或经营风险的大小，以及公司经营管理总体水平的高低等。二、损益表。损益表（利润分配表）是指反映企业在一定会计期的经营成果及其分配情况的会计报表，是一段时间内公司经营业绩的财务记录，反映了这段时间的销售收入、销售成本、经营费用及税收状况，报表结果为公司实现的利润或亏损。三、现金流量表。现金流量表是财务报表的三个基本报告之一，所表达的是在一固定期间（通常是每月或每季）内，一家机构的现金（包含银行存款）的增减变动情形。现金流量表的出现，主要是要反映出资产负债表中各个项目对现金流量的影响，并根据其用途划分为经营、投资及融资三个活动分类。现金流量表可用于分析一家机构在短期内有没有足够现金去应付开销。&#8195;&#8195;第三，基本财务指标分析。分别有偿债能力分析（其主要制表为流动比率、速动比率和资产负债率）、营运能力分析（主要考察企业应收账款损失率和应收账款周转次数）、经营能力分析（主要通过资本报酬率、销售净利率、市盈率进行表征）。&#8195;&#8195;第四，盈亏平衡分析。常用的一种分析方法叫做盈亏平衡分析法，也称量本利分析、盈亏临界分析和收支平衡分析，是通过盈亏平衡点（BEP）来分析项目成本与收入。它有几个基本假设：一、生产量等于销售量；二、固定成本不变，单位可变成本与生产量成正比变化；三、销售价格不变；四、只按单一产品计算，若项目生产多种产品则换算成单一产品，损益的平衡关系是种方法。盈亏平衡的计算公式是固定成本除以单位产品价格与单位产品变动成本之差。静态投资回收期（Pt）=累计净现金流量开始出现正值的年份数-1+上一年累计净现金流量的绝对值/出现正值年份的净现金流量；动态投资回收期（P’t）=累计净现金流量现值出现正值的年数-1+上一年累计净现金流量现值的绝对值/出现正值年份净现金流量的现值。&#8195;&#8195;最后我们来总结一下财务计划部分需要注意和解决的问题。第一，预计的风险投资数额为多少？其中，创业者期望从风险投资者那里获得多少投资？是以贷款、出售债券还是以出售普通股、优先股的形式实现？第二，产品在每一个期间的生产量和售出量有多大？什么时候开始产品线扩张？每件产品的生产费用是多少？每件产品的定价是多少？所预期的成本和利润是多少？盈亏平衡点是多少？第三，在偿债能力、营运能力、盈利能力中有哪些分析指标？各代表什么含义？第四，公司的现金流量发展趋势是怎样的？预计什么时候达到收支平衡？第五，基于公司的规划，融资需求有多高？在最差的情况下，需要多少现金？第七，投资者可以得到多少回报？什么时候用什么形式可以得到这些回报？&#8195;&#8195;同学们，以上是关于财务计划方面的内容。我们下一节再见。  \n风险控制与资本退出&#8195;&#8195;欢迎同学们回来。这一节，我们来讲一下风险控制与资本退出。&#8195;&#8195;这节里，创业者需要了解风险控制和资本退出的基本内容，理解风险和创业风险的含义与特点，掌握创业风险的种类和防范措施，掌握资本退出的基本形式，了解不同证券市场对于上市公司的基本要求和区别。&#8195;&#8195;我们先看一下这部分的主要内容：创业公司可能面临的风险以及风险的大致程度；创业公司将采取何种措施降低或者防范风险、增加收益；投资将以何种方式退出，能获得多少投资回报。&#8195;&#8195;相关的理论知识有如下几个方面。首先是风险，风险是指由于环境的不确定性、客体的复杂性、主体的能力与实力的有限性，从而导致某一事物或活动偏离预期目标的可能性。风险具有客观存在、不确定、相关性、可预测性等特征。创业风险的种类有很多，通常初创者面临的风险种类主要有技术风险、市场风险、财务风险、管理风险和环境风险。&#8195;&#8195;既然存在这么多风险，下面我们介绍一下如何去应对风险，进行防范。&#8195;&#8195;第一，经营风险的防范。一、充分利用各广告媒体，加强企业和产品宣传。二、强化销售队伍和售后服务，保持与客户良好的合作关系。三、快速推进其他系列产品的开发，从而相对减少对单一产品的依赖。四、利用一切优势让本产品成为国内知名品牌，力争将产品打入国际市场。五、积极营造良好的工作环境和科研环境，改善福利待遇，吸引更多科技人员和高素质人才来企业工作。&#8195;&#8195;第二，对市场风险的防范。一、在加强产品销售的同时，建立一套完善的市场信息反馈体系，制定合理的产品销售价格，增加企业的盈利能力。二、加快产品的开发，增加市场的应变能力，适应调整产品结构，增加适销对路的产品产量。三、实行创名牌战略，以优质的产品稳定客户稳定价格，用以消除市场波动对于企业的价格的影响。四、进一步提高产品质量，降低产品成本，提高产品的综合竞争力，增加产品适应市场变化的能力。五、通过进一步拓展思路，紧跟市场发展方向，来解决风险的问题。&#8195;&#8195;第三，财务风险的防范。一、提高经营者的风险意识，培养高素质的财务管理人员。二、提高企业的财务实力，提高企业抗风险能力。三、加强财务风险管理，建立财务评价体系，采取各种手段和措施，对风险进行控制和处理。四、建立科学的财务预测机制，提前安排融资计划，使融资和筹资相联系。&#8195;&#8195;第四，投资风险防范。一、研究投资环境、捕捉投资机会，降低投资风险。二、预测投资风险，强化风险防范。三、强化投资管理、规范投资决策，防范投资风险。四、如果有可能，尽量将投资进行分散，将有限的资金进行最佳的组合，以期达到风险分担的目的。五、完善投资业务内部控制，加强投资业务内部控制的评审和财务风险的审计。&#8195;&#8195;关于资本的退出的基本形式。第一种形式是首次公开上市退出（IPO）：它是指风险投资企业在证券市场上第一次向社会公众发布风险企业的股票，风险投资者通过被投资企业股份上市，将拥有的私人权益转化为公共股权，在市场认同后获得投资收益，实现资本增值。一般企业达不到主板上市的标准，都是在创业板进行上市。例如美国的纳斯达克市场，我国的香港也建立了自己的创业板市场。第二种形式是并购退出：它是指通过与其他企业兼并或收购风险企业，从而使风险资本退出。第三种形式是回购退出：它是通过风险企业家或风险企业的管理层购回风险资本手中的股份，使风险资本退出。第四种形式是清算退出：这是一种针对投资失败项目的退出方式，清算退出主要有两种方式，分为破产清算和解散清算。&#8195;&#8195;我们最后总结一下，在这一节里需要注意和解决的问题。第一，创业公司将面临哪些风险？哪类风险是最影响公司的生存发展的？第二，面临相关风险，创业公司将会采取哪些措施进行应对？第三，市场和技术中最大的风险可能分别出在那里？如何应对？第四，创业公司有哪几种资金退出方式？首选退出方式是哪种？投资回报是什么？第五，如果选取公司上市为基本退出方式，商业计划书中是否有与公司上市为目标的相关运营计划？&#8195;&#8195;这节内容就讲这么多，谢谢大家。  \n新企业的基本知识新企业的基本知识&#8195;&#8195;这章我们讲一下企业创办的相关内容。&#8195;&#8195;在做好商业计划书的准备之后，创业者将进入真正的实践操作阶段——创办企业。在这一章节中，我们将分四个部分展开，分别是新企业的基本知识、成立新企业的相关法律法规新企业的市场进入及进入程序，以及最后新企业的选址。&#8195;&#8195;在新企业的基本知识章节，我们将分别介绍企业的含义与分类、企业的本源和影响、企业成立的衡量和界定，以及新企业成立的时机和条件这四个部分的内容。掌握了这些企业的基本内容，是创办企业的先决条件。&#8195;&#8195;我们首先对企业的含义和分类做一个了解。企业一般是指以盈利为目的，以实现投资人、客户、员工、社会、大众的利益最大化为使命，运用劳动力、资本、土地、信息技术的各种生产要素，向市场提供商品或服务，实现自主经营、自负盈亏、独立核算的具有法人资格的社会经济组织。&#8195;&#8195;按照投资人的出资方式和责任形式，有三大基本组织形式，分别是独资企业、合伙企业和公司，其中公司制企业是现代企业中最主要的最典型的组织形式。除此以外，按照不同的分类标准，还有其他分类，例如按照所有制分，可分为全民所有制企业、集体所有制企业、合伙企业和外资企业；而按照规模划分，又可分为大型企业、中型企业、小型企业和微型企业；按照公司地位和历史关系划分，分为母公司、子公司等等。&#8195;&#8195;而企业成立的意义，其实质上就是企业的本源和性质问题。在1937年，美国经济学家科斯发表的《企业本质》一文中提到，企业的本质特征是对价格机制的替代。通过对企业组织生产、交易费用低于市场组织的交易费用，企业得以产生。&#8195;&#8195;企业成立的影响，可以从宏观和微观两个层面来看。从宏观层面来看，企业是市场活动的主要参加者和直接承担者。市场经济活动的顺利进行，离不开企业的生产和销售活动。从微观层面来说，新企业的成立是创业者对识别的商业机会进行商业化参与市场活动一开始实现创业机会价值的途径和平台，不仅给创业者带来丰厚的经济报酬，也能在很大程度上实现创业者的个人价值和理想抱负。&#8195;&#8195;我们一般衡量新企业的成立有三个维度。第一、存在雇佣性质的员工关系。第二、产生第一笔销售收入。第三、注册登记成合法实体。当然也有部分研究，以企业成立的时间作为新企业界定的标准，例如全球创业观察GEM界定的新企业则指成立时间在42个月以内的企业。&#8195;&#8195;成立新企业也需要什么条件呢？什么时间成立比较合宜？这是创业者普遍关心的问题。根据蒂蒙斯教授在1999年提出的包含三个核心要素的创业过程模型，这三个核心要素分别是创业机会、创业团队和创业资源。从这个模型看，创业者识别到了具有潜力和商业价值的创业机会，组建好了创业团队，并且整合到了创业所需要的物质资源，便是成立新企业的最佳时机了。&#8195;&#8195;这章节就讲到这里，谢谢大家收听。  \n成立新企业的相关法律法规&#8195;&#8195;在这一章节中，我们要讲一下新企业需要处理好的一些重要的法律问题。&#8195;&#8195;在企业初创阶段，新企业需要处理好一些重要的法律问题，以免由于法律失误，导致新企业付出沉重的代价。例如曾经著名的互联网传播企业，快播公司由于传播淫秽物品牟利而导致触犯法律，他们的CEO被抓，而最终导致公司解体。因此，我们必须首先了解成立新企业的法律因素和法规，其次选择新企业的法律组织形式，最后确定新企业的组织结构。&#8195;&#8195;在企业的创建阶段，创业者面临的法律问题，包括确定企业的法律形式、设立适当的税收记录、协调租赁和融资问题、起草合同、申请专利、商标或版权的保护等。新企业开始运营以后仍有与经营相关的法律问题，例如人力资源或者劳动法规可能会影响员工的雇佣报酬以及工作的确定；安全法规则可能会影响产品的设计和包装、工作场所和机器设备的设计使用等等。&#8195;&#8195;创业者在创建和经营企业的过程中，必须了解和遵守有关法律、法规，以确保自己和他人的利益，不受到非法侵害。法律法规一方面对新企业有约束作用，另外一方面也对新企业的运营和发展给予法律保护。与创业有关的法律主要是知识产权、竞争、质量和劳动等方面的法规，具体包括专利法、商标法、著作权法、反不正当竞争法、合同法等等。&#8195;&#8195;按照中外企业有关法律条款的规定，目前我国企业主要有三种基本的组织形式：个人独资企业、合伙企业和公司制企业，其中公司制企业主要包括有限责任公司和股份有限公司。还有一种比较特殊的一人公司也叫一人有限责任公司实际上是有限责任公司的一种。以上各种企业组织形式的投资人要求和需要承担的责任。请看图表。在图表中，我们列出了各种企业组织形式，对于创业者的优劣比较，各种企业组织形式没有绝对的好坏之分。对于创业者来说，各有利弊，没有说哪一种就一定比另外一种好，关键是要看是否适合创业者自身。因为不同的组织形式，对于企业权责利的安排不同，并直接影响企业筹资渠道、产权制度、治理结构、责任形式和税收负担等重大问题。&#8195;&#8195;传统的组织结构类型包括直线型、智能性、部门制、矩阵制的不同类型。进入21世纪以来，全球环境发生了前所未有的变革。全球一体化互联网和信息技术发展决策速度加快的，对组织结构也产生了深远的影响和要求。一些创造性的组织方法和结构不断的出现。我们这里提出四种新企业的组织结构：分别是学习型组织结构、团队型组织结构、项目型组织结构和虚拟型组织结构。学习型组织结构是美国学者彼得圣吉提出的。在学习型组织中，每个人都要参与识别和解决问题，使组织能够进行不断的尝试改善和提高他的能力。学习型组织的基本价值在于解决问题，将好于创业企业的特质相契合。而团队型组织机构则是这个企业中任何一个员工都可以发展自己的团队。在所在区域构建一个团队，每个团队人员都是灵活变化的，这种组织结构可以大幅度提高经营效率，提高服务质量以及产品的研发速度和效率。对于服务型创业企业和技术性创业企业都大有裨益。项目型组织结构与团队型组织结构有很大类似之处，但也有不同之处在于，一个项目团队只存在于完成一个项目的阶段内存在时间取决于项目完成所需要的时间。对于创业企业而言，该组织结构既能够提高运行效率，又能因团队的存在而增强灵活性。虚拟型组织结构是，当市场出现新机遇时，具有不同资源和优势的企业为了共同开拓市场，共同对付其他竞争者，而组织的建立在信息网络基础上的共享技术与信息分担费用联合开发的互利的企业联盟体。&#8195;&#8195;这一章节就讲到这里，谢谢大家。  \n新企业的市场进入与进入程序&#8195;&#8195;当创业者看好一个市场或产品领域，并确定要进入该市场后，他所面临的下一个至关重要的决策，就是制定并选择相应的市场进入途径。从现有的路径模式看，创业者可以选择以下三种市场进入模式，分别是注册成立一个全新的企业、收购现有企业和特许经营。&#8195;&#8195;现在我们简单介绍一下新企业必须完成的注册流程，包括企业名称预先核准、前置审批、填写登记申请书、审核和核准、颁发营业执照、刻章、银行开户、社会保险登记注册。&#8195;&#8195;个人独资企业则需要提交一系列的文件，包括投资人签署个人独资企业设立申请书、投资人身份证明、企业住所证明和生产经营场所使用证明等文件。&#8195;&#8195;设立一家合伙公司和有限责任公司或者股份有限公司，则应提交企业设立登记申请书全体股东签字的公司章程。如果有法人股东的，还需要加盖该法人单位的公章，并由其法定代表人亲笔签字，还要提交验资报告，以非货币方式出资的，还应提交资产评估报告，出资权属证明名称预先核准申请书及企业名称预先核准通知书、股东资格证明、制定委托书等必备文件及股东名录、董事、经理、监事成员名录，递交申请材料，领取受理通知书，并已交纳登记费领取执照。&#8195;&#8195;而通过收购企业启动新事业，我们则首先要掌握收购这一重要概念。收购是指买方从卖方企业购入资产或者股票，你获得对卖方企业的控制权。而该公司的法人地位不改变。从法律意义上来说，收购是指持有一家上市公司发行在外的股份的30%时发出要约收购该公司股票的行为。其实质是购买被收购企业的股权。收购按照支付方式分类，可分为资产收购和股份收购。控股收购，理论上是指持有投票权的股票，特指普通股的51%被收购公司收购。如果收购公司的规模大，且股份分散的情况下，往往控制25%到30%的股份，就能够有效的控制整个公司。股份收购里面的控股收购和全面收购，是创业者比较青睐的方式。按收购双方行业关联分类主要分为横向收购、纵向收购和混合收购；按照持股对象是否确定分为要约收购和协议收购；按照收购者预定收购目标公司股份的数量分类，则可分为部分收购和全面收购。收购一家理想企业，可以帮助创业者快速获得被收购企业的市场优势，包括技术、市场、专利、产品、管理等各个方面。第二、可以实现合理避税的目的。第三、可以减少企业发展的投资风险和成本，还可以有效的减少进入新行业的障碍，并且可以利用学习曲线的效益实践得出真知，经验越多，企业的效率就会越高。收购存在经营风险、多付风险、财务风险等等。收购企业在收购后业绩并没有预期的好，收购的高价格使买主无法获得一个满意的投资回报。通过借债为收购融资，则制约了买主为经营融资并同时还债的能力。我们在选择被收购企业时，一般要求它有如下的特征，创业者倾向于选择去收购那些目标公司管理层的管理效率低下、财务资源有限、流动性差、反收购能力差、资产规模较小的公司，而那些需要收购的资金少、股权分散、股权流动性又较好的，则被认为是一种潜力较大的被收购企业。收购一家企业需要通过以下8个程序，分别是制定收购计划、寻找合适的目标企业、初步谈判、企业收购审查与决策、确定收购价格并签订收购协议、融资交割并披露，最后是企业的重整再造特许经营这一环节。我们首先要了解其含义和特点。特许经营权拥有者以合同要约的形式，允许被特许经营者有偿使用其名称、商标专有技术产品及运作管理经验等从事经营活动的商业经营模式。美国三分之一以上的零售业就是特许经营的商业模式。特许经营有三个要素组成：特许总部；特许分店；规定了转让、包括全套经营方式管理技巧、无形资产在内的协议。特许经营的主体是一种互利合作共同发展的关系，在法律地位上是平等的、自负盈亏的民事主体；基础是特许和受许人之间建立在互惠互利基础上的契约关系；核心是特许人向受许人出售的技术专长管理经验和经营之道；特许人和受许人通过协议组成的分工合作体系。特许经营的种类。目前主要存在商品和商标特许经营、经营模式特许经营两种不同的特许经营体系。商品和商标特许经营能将单一制造商和零售商、分销商连接起来。而经营模式特许经营则是更为流行的一种特许经营方式，特许授权商通过培训、广告等形式的一种经营模式，提供给加盟商特许经营，可使得企业获得大规模、低成本扩张、准确定位等管理优势，但同时也带来相对固定的记忆模式，不能应对变化的市场；各主体之间责任不清，带来消费者的不信任；只能专注某一领域难以扩展到其他市场等。这也使创业者选择特许经营方式时，应注意特许经营公司需要良好的业绩要素，实际投资成本、经营记录、特许方的过往业绩、特许方提供的培训和知识水平、要求受许方承担的义务等等要素。&#8195;&#8195;这一章节就讲到这里，谢谢大家。  \n新企业的运营设计&#8195;&#8195;这章节，我们讲讲新企业的运营选址。&#8195;&#8195;根据香港工业总会和香港总商会的统计，在众多开业不到两年就关门的企业中，由于选址不当所导致的企业失败数量占据了创业失败的50%以上。从这个数字可以显示，选址的重要性不言而喻。&#8195;&#8195;新企业选址是一个比较复杂的决策过程，涉及的因素主要有五个方面:经济因素、技术因素、政治因素、社会文化因素和自然因素。其中经济因素是选址中需要考虑的最重要因素。在关联企业和关联机构相对集中的新企业容易成功。创业者多数选择产业集群形成的区域，对于零售业和服务业有两种思路。第一是在同行聚集林立的地方，形成集群优势。另外一种则是“别人淘金，我卖水”的差异化竞争场所的选择。而技术因素对于高科技创业企业，成功的作用是显著的企业选择建立在技术研发中心附近或者新技术、信息传递比较迅速频繁的地区，例如美国的硅谷、中国的中关村等。政府对市场的规制，也是值得创业者重视的一个方面。马云在杭州创立阿里巴巴，华为会将总部建在深圳这些也并非偶然。云南省省长某次公开场合，曾批评当地企业审批流程的繁琐：“某一地区的一个企业完成投资审批要一年时间。我要是投资商早就走了。”也是创业者所考虑。所在地域政府对于企业支持的一个政策力度，投资者在国外市场更应该考虑不同国家的政治环境，如国家的政策是否稳定、有无歧视等。而社会文化因素，企业则应选址建在企业文化与其所生产产品得到较大认同的地区。自然因素。选址则应考虑地质状况、水资源的可利用性、气候的变化等自然因素。例如化工企业多选择在沿江、沿海区域，因为交通运输方便。&#8195;&#8195;总体而言，上述各种因素对于不同的行业企业来说，有不同的考虑侧重。比如制造业的选址侧重生产成本的因素，而服务业的选址则侧重市场因素。&#8195;&#8195;科学而行之有效的选址过程，一般遵循市场信息的收集和研究多个地点的评价，以及最终厂址的确定的步骤。&#8195;&#8195;首先，创业者应考虑从二手资料中收集信息，图书馆杂志、互联网等。其次，创业者还应该亲自去收集一些新的信息，获取第一手的资料。方法有很多，比如观察站在一个路口，计算一段时间内的人流量，还有访谈、问卷调查等多种形式。其中一种据点小组是一种收集申请信息的公开、非正规化的方法——邀请10到12名潜在顾客来参加有关创业者研究目标的讨论。最后就要对收集到各种信息进行汇总。经过此阶段后，创业者应该已经得出若干个新企业厂址的候选地。这个时候可以借助定量分析方法来进行评价。目前比较常用的评价方法有量本利分析法、综合评价法、运输模型法、重心法和引力模型法等。&#8195;&#8195;下面我们来讲一个企业选址的案例。肯德基和麦当劳都是大家熟悉的快餐行业品牌。业界有一句俗语：“选铺跟着麦当劳、肯德基走没错。”麦当劳的选址标准。首先是针对他的目标消费群体，它的目标消费群主要是年轻人儿童和家庭成员。所以布点上，经常选择人潮涌动的地方，以及年轻人儿童经常光顾的地方。其次，选址着眼于今天和明天。麦当劳布点的一大原则，就是一定二十年不变。所以对每个点的选址都通过了3到6个月的考察，重点考察是否与城市规划发展相吻合，是否会出现人口动迁。而老化的商圈和纯住宅区则不设点。第三是选址讲究醒目，和麦当劳的招牌一样，选址都在一楼的店堂，透过玻璃橱窗，让路人感知他的餐饮文化氛围。而对于黄金地段的布点，则不急于求成，因为黄金地段的商铺价格通常租金会比较贵，他们会选择先发展其他地方的布点，通过其他网点的成功，让黄金高价地段的房产业主感到，由于麦当劳的引进，则有助于提高房产价值身价，从而愿意降低价格引入。如果选择在店中店开业的话，都是选择大型的声誉较高的商业广场知名百货店等。一方面这些商场和百货店会给麦当劳带来客源。另外一方面，麦当劳的客人也会吸引年轻人去逛商场，形成两方面的优势互动。而同样竞争对手的肯德基，则通过专业调查公司收集相关地区的资料，划分商圈。例如商场营业额1000万以上的算1分，5000万以上的算2分，一条公交线路和一条地铁线路加多少分。这些分值标准都是通过多年的平均下来的一个比较准确的经验值。通过打分，把商圈分为了市级商业型、区级商业型定点消费型、社区商务两用型、旅游型等等。而肯德基布点的另外一个原则，就是争取在最聚客的地方和其附近开店。俗话说：“一步差三市。”开店地址差一步就可能差三成的买卖。这和人流活动的线路有着密切的关系。&#8195;&#8195;以上就是新企业选址的相关内容。谢谢大家。  \n","categories":["学科笔记"]},{"title":"《地理信息科学-B》笔记","url":"/posts/69ed51f5/","content":"地理信息科学前沿\nGIS的内涵与发展历程\nGIS定义\n获取、存储、管理、处理与分析与地理空间分布相关的数据，并提取信息和发现知识的计算机系统。\n\n\nGIS基本功能\n采集、管理、查询、输出多种地理空间信息的能力。\n以地理模型方法为手段，开展多要素综合分析能力。\n借助科学计算与可视化，辅助政府、机构、个体决策。\n\n\nGIS内涵的变化\n地理信息系统\n起步：1960-1980，数据输入、数据管理、数据统计、机助制图\n巩固：1980-1990，混合模型、空间分析、专业软件、地学应用\n专业应用：1990-1995，系列化软件、专业化应用、大型数据库、网络化发展\n\n\n地理信息科学\n科学体系：1995-2005，时空认知、数据挖掘、系统模拟、WebGIS\n\n\n地理信息服务\n社会服务：2005至今，云计算、大数据、位置服务、虚拟环境\n\n\n\n\nGIS应用快速拓展\n阳春白雪：1960-1995，高投入、单一平台、政府应用\n百舸争流：1995-2002，低投入、多种平台、行业推广\n润物无声：2002-2008，稳步发展、接触大众\n无处不在：2008至今，服务至上、融入生活\n\n\n\n\n当前形势与业界成果回顾\n国际关注：人口-资源-环境问题\n国家需求：社会发展与国防建设\n资源调查、生态保护、灾害防治\n市政管理、智能交通、社会分析\n反恐维稳、嫌犯跟踪、作战协同\n武器升级、无人装备、精确打击\n\n\n大众期待：现代化生活方式（社交So、位置Lo、移动Mo）\n信息易得、智能导航、自动驾驶\n电子商务、快递配单、亲情关爱\n出行便捷、移动社交、广告定投\n\n\n面向智慧地球的地理信息科技进展\n对地观测手段多样，高分辨率成为主流\n无人机迅猛发展降低了遥感应用门槛\n夜光遥感等新兴遥感技术大放异彩\n遥感从观测自然要素过渡到观测人与社会\n\n\n移动定位技术发展如火如荼\n室内导航定位技术五彩缤纷\n\n\n地理信息技术全方位渗透\n应用领域拓展到自然与社会科学诸多学科\n以位置服务（LBS）为核心的地理信息服务产业迅速发展\n\n\n\n\n\n\n地理信息科技发展前沿\n大数据背景下的地理信息泛化\n大数据本质：刻画时空粒度更为精细，注重细节关联和逻辑，为科学分析熟视无睹的行为、格局与过程提供了极大的便利。\n采集手段：人人都是传感器。\n数据类型：自然环境、社会环境、商业。\n替代价值：大数据分析就是榨取各种数据的替代性价值，使其功效转移。\n学科条件：GIS已经由设备依赖过渡到数据依赖和用户依赖，学科交叉更为迫切。\n核心理念：以位置为核心的大数据动态关联。\n\n\n新时代的地理信息科学特征\n精细时空尺度下研究自然与社会系统格局及演化过程越发需要GIS\n新的特征\n自然与社会环境实时感知、大数据成为主流\n云环境下的普适计算成为新的支撑技术体系\n知识服务开始主导地理信息的网络应用模式\n\n\n新的目标\n地理空间大数据采集、管理与分析方法\n从聚焦几何形态，到侧重语义关联\n助力从地理计算到社会计算的形态转变\n\n\n\n\n地理信息科学前沿研究主题\n地理数据采集与表达：地理空间认知、大数据有偏性与影响测度、稀疏地理空间大数据插值、地理信息不确定性、地理信息传输误差规律等。\n地理数据存储与处理：异构地理空间大数据管理与查询、数据压缩变换、变化发现与数据更新、数据交换共享、数据安全与隐私保护、知识图谱等。\n数据挖掘与知识发现：时空聚类与模式识别、空间统计推断、空间规则提取、可解释空间智能、地理知识表达与推理、地理过程的尺度依赖性等。\n\n\n地理信息科学关键技术瓶颈\n数据采集与处理\n测绘遥感新技术+社会环境大数据感知\n多源遥感追求立体成像，实时处理、自动理解\n移动定位追求稳定、低成本、普适、智能混合\n社会感知追求泛在、跨界、群体智慧、语义关联\n\n\n数据采集与处理的目标：时空场景重构\n打造精细化、全空间、全过程的自然场景数字孪生环境，并实现时空场景对象级要素信息动态更新与维护，为高精度智能计算提供数据与可视化平台支撑。\n\n\n\n\n数据管理与集成\n多源数据集成：室内外地图、影像、视频、移动对象轨迹、社交网络、网络文本、个性化信息，强调信息的动态关联。\n移动对象管理：室内外一体化、空间索引与查询。\n全息位置地图与知识图谱：语义网+图搜索。\n云/端协同计算：NoSQL、数据仓库、云服务。\n地理信息用户隐私保护\n\n\n数据分析与模拟\n移动对象轨迹数据挖掘\n网络文本和音视频分析\n空间场景实时构建与推理\n动态复杂网络分析技术\n基于场景知识图谱的推荐\n时空大数据机器学习算法\n\n\n人机交互方式\n自然语言查询过程\n自适应推送式信息服务\n三维模型轻量化与交互\n三维场景VR与AR\n\n\n\n\n地理信息科学研究前沿总结\nGIS已跨越了传统测绘地理信息的范畴，大数据时代的泛在地理信息处理，需要全新的数据表达、管理和分析方法论。\n数据采集：现代测绘、计算机视觉、群智感知及异构数据融合技术为时空场景快速构建奠定了基础。场景要素间的动态语义关联亟需可智能更新的领域知识图谱。\n数据管理：地理空间大数据管理需要新型的时空数据引擎与高性能计算环境的支撑。\n数据分析：机器学习和知识图谱相结合，是泛在地理信息智能分析的必然需求。\n\n\n\n\n\n普适GIS与地理空间智能\n普适GIS的基本特征\n普适/广义GIS\n实时自然环境、社会环境监测日趋多样，时空大数据快速增长，地理空间信息大量隐式存在， 动态性、非专业性、非结构化和个性化更加突出，地理信息在泛化。\n针对政府智能管理、企业商业决策、大众现代生活的时空数据处理需求，很多已经超越了传统GIS的能力范畴。泛化地理信息背景下，GIS的概念也在泛化。\n处理时空大数据的GIS软件（Big geo-data enabled GIS software）\n可处理位置信息的专业软件（Location enabled software）\n\n\n行业案例\n阿里巴巴：多源异构时空大数据引擎\n京东：智慧城市时空大数据引擎\n美团：地理位置赋能的商业推荐引擎\n\n\n\n\n面向大数据的GIS平台技术\n空间大数据存储技术\n空间大数据存储需求：经典空间数据库侧重解决数据“深度”问题，空间大数据还需考虑数据的“广度”与“密度”问题。\n空间大数据“深度”：单领域数据汇聚规模与维度\n空间大数据“广度”：多领域异构数据汇聚与关联\n空间大数据“密度”：实时汇聚有价值数据的比例\n\n\n空间大数据存储方案\n专业GIS软件服务商（超图、易智瑞、航天宏图）：依赖开源工具，提供地理空间大数据汇聚与访问能力，并提供处理、存储、分析一体化全流程管理手段。\n阿里巴巴：空天网格码模型\n京东：JUST时空数据模型\n\n\n\n\n空间大数据规整技术\n针对地理空间大数据的审核、纠错、筛选、排序等，包括数据清理、数据集成、数据转换和数据归约等。\n\n\n空间大数据访问技术\n查询实现策略为计算与存储分离的共享存储架构。有效降低I/O延迟，引入跨节点空间并行查询处理框架，采用布隆过滤器/动态分区加速查询，提高查询效率。\n\n\n空间大数据计算环境\n现状特征：时空大数据与高性能计算/云计算融合。\n发展趋势：面向多源数据集成的时空分析AI框架。\n空间大数据计算面临挑战：AI算法多为“黑箱”模型，隐藏底层数据挖掘过程，算法扩展性不佳，并行化受到诸多限制。\n\n\n空间大数据分析技术\n环境动态感知与推理\n场景与个体动态画像\n全息地图数据聚合\n经典空间数据挖掘拓展\n知识图谱与深度学习\n\n\n空间大数据可视技术\n直接可视化\n特征可视化\n聚集可视化\n\n\n\n\n地理空间智能基础知识\n地理空间分析\n地表数据采集/处理：采样、插值、地理空间信息抽取、场景画像、空间范围标定等\n地表要素聚类/分类：地理区划、风险评估等\n地表过程刻画/预测：地理学第1/2/3定律、地理归因等\n地表过程模拟/控制：地理情景模拟、地理过程控制等\n\n\n地理空间分析的科学范式变革\n主观意识\n智慧：基于已有知识进行分析与演绎，提出解决方案的能力。\n知识：沉淀并与已有知识库进行结构化整合的有价值的信息。\n\n\n客观存在\n信息：经过加工、具有一定含义、逻辑性和时效性的数据流。\n数据：对客观事物数量、属性、位置及相互关系的抽象表示。\n\n\n\n\n\n\n\n空间抽样与统计推断\n参考文献\nWang J F, Zhang T L, Fu B J. A measure of spatial stratified heterogeneity[J]. Ecological Indicators, 2016, 67: 250-256.\nWang J, Gao B, Stein A. The spatial statistic trinity: A generic framework for spatial sampling and inference[J]. Environmental Modelling &amp; Software, 2020, 134: 104835.\n\n\n概念解释\nPopulation \n解释：总体，所有研究的单元\n举例：2022年9月6日中国的日温分布\n\n\nElement/Unit/Individual/Point/Supp.\n解释：最小刻画单元\n举例：2022年9月6日中国区域内某一点的日温\n\n\nSample \n解释：样本，总体中的一部分单元\n举例：2022年9月6日中国749个气象站点的日温\n\n\nEstimator, Estimate, Estimation \n解释：估计值\n\n\n\n\n空间统计三位一体\nPopulation \ni.i.d.()：independence and identically distributed，互相独立并且同一分布\nSAC()：spatial autocorrelation，空间自相关性\n符号定义\n：研究区域包含的单元（总体）数量\n：总体中第个单元（的值）\n：第个单元和第个单元之间的空间权重\n\n\n统计量\n总体均值：\n所有空间权重的聚合：\n\n\n全局莫兰指数（Moran’s I）\n\n\n\n空间自相关性的显著性检验\n原假设：没有显著的空间自相关性\n备择假设：存在显著的空间自相关性\n期望：\n方差：\n统计量：\n拒绝域：\n\n\n\n\nSSH()：spatial stratified heterogeneity，空间分层异质性\n符号定义\n：研究区域包含的单元（总体）数量\n：研究区域分层数量\n：第（）个分层包含的单元数量\n：总体中第个单元（的值）\n：第个分层中第个单元\n\n\n第个分层的统计量\n均值：\n方差：\n\n\n总体的统计量\n均值：\n方差：\n\n\n统计量\n\n层内平方和：\n总体平方和：\n\n\n统计量的判读\n\n总体具有的空间分层异质性\n时表示总体没有空间分层异质性\n时表示总体具有完全空间分层异质性\n\n\n空间分层异质性的显著性检验\n假定条件：\n原假设：没有显著的空间分层异质性\n备择假设：存在显著的空间分层异质性\n统计量：（非中心分布）\n非中心参数\n拒绝域：\n\n\n\n\n\n\nSampling \nR：random，随机采样\nT：system，系统采样\nS：strata，分层采样\n\n\nEstimator \ni.i.d.\n简单平均\n普通最小二乘法（OLS）\n\n\nSSH\n三明治估计法\n\n\nSAC\n克里金估计法\n\n\nSSH和SAC的混合\nMSN（Mean of Surface with Nonhomogeneity，非均匀表面平均法）\nB-shade（Biased-Sentinel Hospital Area Disease Estimation）\nSPA（Single Point Areal Estimation，单点区域估计法）\n\n\n\n\n总结：如果总体是……\n无空间分层异质性（）且……\n无空间自相关性（）：简单平均\n有空间自相关性（）：克里金\n\n\n有空间分层异质性（）且……\n无空间自相关性（）且样本……\n无偏：三明治\n有偏：Heckman\n\n\n有空间自相关性（）且样本……\n无偏：MSN\n有偏：B-shade或SPA\n\n\n\n\n\n\n\n\n\n空间分异及地理探测器\n参考文献\nWang J F, Li X H, Christakos G, et al. Geographical detectors‐based health risk assessment and its application in the neural tube defects study of the Heshun Region, China[J]. International Journal of Geographical Information Science, 2010, 24(1): 107-127.\n\n\n空间分层异质性指标的计算\n见上一节“SSH()”部分。\n\n\n案例分析\n输入数据\n来源\nhttp://geodetector.cn/GeoDetector_2015_Example(DiseaseDataset).zip\n\n\n预览\n字段说明\nincidence：数值型，平均发病率\ntype：分类型，土壤类型\nregion：分类型，流域类型\nlevel：分类型，高程类型\n\n\n\n\n结果分析\n风险探测器\n土壤类型对平均发病率的影响\\begin{array}{|c|c|c|c|c|}\\hline1&2&3&5&7\\\\\\hline6.34&6.69&6.58&5.84&6.35\\\\\\hline\\end{array}\n\n\n\n\n\n\n\n知识图谱\n知识图谱概念及演化\n概念\n知识图谱是一个结构化的语义知识库，用于以符号形式描述物理世界中的概念及其关系。它的基本单位是“实体-关系-实体”和“实体-属性-属性值”的三要素。实体通过关系相互连接，形成一个网络化的知识结构。\n\n\n演化\n1960年：语义网（Semantic Networks）作为知识表示的一种方法被提出，主要用于然语言理解领域。\n1980年：哲学概念“本体（Ontology）”被引入人工智能领域来刻画知识。\n1989年：Tim Berners-Lee在欧洲高能物理研究中心发明了万维网。\n1998年：Tim Berners-Lee提出了语义互联网（The Semantic Web）的概念。\n2006年：Tim Berners-Lee定义了在互联网上链接数据（Linked Data）的四条原则。\n2012年：谷歌发布了其基于知识图谱（Knowledge Graph）的搜索引擎产品。\n\n\n不同视角\nWeb视角：像建立文本之间的超链接一样，建立数据之间的语义链接，将各种结构化、半结构化、非结构化数据关联和导航，并且提供语义搜索。\nNLP视角：怎样从文本中抽取实体关系、实体属性值，提取术语、标签的关系，实现语义理解。\nKR视角：怎样利用计算机符号和采取何种数据结构来表示知识以及对知识进行推理。\nDB视角：怎么高效地进行知识存储和检索。\nML视角：怎么挖掘知识并且将知识作为特征融入到机器学习模型中提升机器学习模型的有效性。\n\n\n相关领域的发展\n数据库：RDF数据库系统、数据集成、知识融合\n自然语言处理：信息抽取、语义解析\n知识工程：知识库构建、基于规则的推理\n机器学习：知识图谱数据的知识表示\n\n\n语义知识图谱与科学知识图谱的异同\n相同点\n两类知识图谱都是以图( Graph) 为基础构建网络模型，在网络分析的基础上服务于知识管理。\n\n\n不同点\n概念\n科学知识图谱：在科学计量学的范畴中，知识图谱的定义是以科学文献知识为对象，以科学研究范式为基础，以引文分析方法和信息可视化技术为手段，显示学科发展进程与结构关系的一种图形，主要是对文献和文献内容的知识单元进行可视化。\n语义知识图谱：谷歌公司于2012 年提出“知识图谱（Knowledge Graph）”的概念，旨在描述真实世界中存在的各种实体或概念及其关系，以构建巨大的语义网络图，因此知识图谱提供了从关系的角度去发现知识、分析问题的能力，逐渐发展成为以语义网为基础的新型海量知识管理和服务模式。\n\n\n数据类型\n科学知识图谱主要建立在对科学文献和科研相关数据进行分析，重要研究数据包括引文数据（如科学引文索引，SCI）、科研论文、合作关系、项目资助、关键词、数据库（如PubMed）等。\n语义知识图谱所用的数据类型广泛得多，而且尤其适用于解决关系复杂、类型繁多、结构多变的数据。比如在金融领域，既有来自互联网舆情、监管机构的合规要求、内部报告等非结构化文本数据，也有财务、报告等半结构化数据，以及上百个业务系统产生的海量结构化数据；医学领域数据有电子病历、临床医学知识库、医学主题词表（如MESH）、国际疾病分类（如ICD-10）等。\n\n\n构建方法\n应用领域\n科学知识图谱：研究内容智能检索和分析；发现学科发展脉络和趋势；辅助科研评价与决策；支持科研合作和管理。\n语义知识图谱：在自然语言处理、语义标注、智能搜索、知识问答、关联分析、决策支持、知识推理等方面有了广泛的应用。此外，在医疗、教育、交通等重要领域也有应用研究。\n\n\n\n\n\n\n\n\n知识图谱技术体系\n知识表示\n本体建模\n本体定义：“本体”概念来源于哲学领域，指的是对客观存在系统的解释和说明。计算机科学中，“本体”用于面向特定领域的形式化地对于共享概念体系的明确而又详细的说明。它提供了面向特定领域的概念、对象类型、上下位语义关系等以及它们的属性等，是对特定领域之中概念及其相互之间关系的形式化表达，从而方便地进行自动推理等功能。\n本体语言：DARPA提出的DAML（DARPA Agent Markup Language）、w3c提出DAML+OIL3以及目前知识图谱数据集常用w3c所定义的RDF(S)和OWL语言等。\n本体工具：Progege和WebOnto\n\n\n知识图谱数据模型\nRDF(Resource Description Framework)\nRDF定义了一个简单的模型，用于描述资源、属性和值之间的关系。资源是可以用URI标识的所有事物，属性是资源的一个特定的方面或特征，值可以是另一个资源，也可以是字符串。总的来说，一个RDF描述就是一个三元组：&lt;主语，谓词，宾语&gt;。\n\n\nRDFs\n在RDF数据层的基础上引入模式层，定义类、属性、关系的定义域与值域来描述与约束资源，构建最基本的类层次体系和属性体系，支持简单的上下文推理。\n\n\n\n\n\n\n知识抽取\n概念\n从不同来源、不同结构的数据中进行知识提取，形成知识存入到知识图谱。\n\n\n关键技术与难点\n从结构化数据库中获取知识\n技术：D2R\n难点：复杂表数据的处理\n\n\n从链接数据中获取知识\n技术：图映射\n难点：数据对齐\n\n\n从半结构化（网站）数据中获取知识\n技术：包装器\n难点：方便的包装器定义方法、包装器自动生成、包装器的更新与维护\n\n\n从文本中获取知识\n技术：信息抽取\n难点：结果的准确率与覆盖率\n\n\n\n\n\n\n实体识别\n概念\n从文本中识别出实体的命名性指称项，并标明其类别。\n\n\n类别\n三大类：实体类、时间类、数字类\n七小类：人名、机构名、地名、时间、日期、货币和百分比\n\n\n命名实体识别方法\n基于规则的实体识别方法\n解释：采用字符串完全匹配或者部分匹配的方式，从文本中找出与词典最相似的短语完成实体识别。\n优点：规则简单。\n缺点：需要构建词典和规则；性能受词典规模和质量的影响。\n\n\n基于机器学习的实体识别方法\n解释：利用预先标注好的语料训练模型，使模型学习到某个字或词作为命名实体组成部分的概率，进而计算一个候选字段作为命名实体的概率值。若大于某一阈值，则识别为命名实体。包括最大熵模型和条件随机场模型（CRF）。\n难点：实体消歧与共指消解。\n\n\n\n\n\n\n关系抽取\n概念\n自动识别实体之间具有的某种语义关系。可分为句子级关系抽取和语料（篇级）关系抽取。\n\n\n难点\n同一个关系可以具有多种不同的词汇表达方式。\n同一个短语或者词可能表达不同的关系。\n同一对实体之间可能存在不止一种关系需要结合上下文。\n关系有时在文本中找不到任何明确表示，隐含在文本中。\n关系抽取依赖词法、句法分析等基本的自然语言处理工具，但该工具性能并不高。\n\n\n方法\n基于模板的方法\n分类：基于触发词/字符串的Pattern、基于依存句法的Pattern\n优点：在小规模数据集上容易实现，构建简单。\n缺点：特定领域的模板需要专家构建，难以维护，可移植性差，规则集合小的时候，召回率很低。\n\n\n监督学习方法\n分类：机器学习方法、深度学习方法\n步骤：预先定义好关系的类别→人工标注一些数据→设计特征表示→选择一个分类方法 (SVM、NN、Naive Bayes)→评估结果\n优点：准确率高，标注数据越多越准确。\n缺点：标注数据成本太高，不能扩展新的关系。\n\n\n弱监督学习方法\n适用情况\n数据量特别大\n没有足够多标注数据\n\n\n远程监督方法\n概念：知识库与非结构化文本对齐来自动构建大量训练数据，减少模型对人工标注数据的依赖，增强模型跨领域适应能力。\n步骤：从知识库中抽取存在关系的实体对→从非结构化文本中抽取含有实体对的句子作为训练样例\n优点：利用丰富的知识库信息，减少一定的人工标注。\n缺点：假设过于肯定，引入大量噪声，存在语义漂移现象；很难发现新的关系。\n\n\nBootstrapping\n概念：通过在文本中匹配实体对和表达关系短语模式，寻找和发现新的潜在关系三元组\n步骤：给定种子集合→从文档中抽取出包含种子实体的新闻→将抽取出的Pattern去文档集中匹配→根据Pattern抽取出的新文档如种子库并迭代多轮直到不符合条件\n优点：构建成本低，适合大规模构建,可以发现新的关系（隐含的）。\n缺点：对初始给定的种子集敏感，存在语义漂移问题，结果准确率较低，缺乏对每一个结果的置信度的计算。\n\n\n\n\n\n\n\n\n事件抽取\n概念\n从自然语言中抽取出用户感兴趣的事件信息，并以结构化的形式呈现出来，例如事件发生的时间、地点、发生原因、参与者等。\n\n\n任务\n识别事件触发词及事件类型\n抽取事件元素同时判断其角色\n抽出描述事件的词组或句子\n事件属性标注\n事件共指消解\n\n\npipeline方法分类器\n事件触发次分类器 (Trigger Classifier)：用于判断词汇是否是是事件触发词，以及事件的类别\n元素分类器 (Argument Classifier)：判别词组是否是事件的元素\n元素角色分类器 (Role Classifier)：判定元素的角色类别\n属性分类器 (attribute classifier)：判定事件的属性\n可报告性分类器 (Reportable-Event Classifier)：判定是否存在值得报告的事件实例\n\n\n\n\n知识存储\n图数据库的概念\n图数据库源起欧拉和图理论（graph theory）,也可称为面向/基于图的数据库，对应的英文是Graph Database。图数据库的基本含义是以“图”这种数据结构存储和查询数据。它的数据模型主要是以节点和关系（边）来体现，也可处理键值对。它的优点是快速解决复杂的关系问题。\n\n\n图的特征\n包含节点和边\n节点上有属性（键值对）\n边有名字和方向，并总是有一个开始节点和一个结束节点\n边也可以有属性\n\n\n\n\n知识融合\n概念\n指在不同数据集中找出同一个实体的描述记录，主要目的是对不同数据源中的实体信息进行整合，形成更加全面的实体信息。\n\n\n主要技术挑战\n数据质量的挑战：命名模糊，数据输入错误，数据丢失，数据格式不一致，缩写等。\n数据规模的挑战：数据量大（并行计算），数据种类多样性，不再仅仅通过名字匹配，多种关系，更多链接等。\n\n\n基本技术流程\n数据预处理：对数据进行归一化处理是提高后续链接精确度的重要步骤，包括语法正规化和数据正规化。\n记录链接：假设两个实体的记录和，和在第个属性上的值是和，通过属性相似度和实体相似度进行记录链接。\n属性相似度计算\n编辑距离：Levenstein、Wagner and Fisher、Edit Distance with Affine Gaps\n集合相似度：Jaccard系数、Dice\n基于向量的相似度计算：Cosine相似度、TFIDF相似度\n\n\n实体相似度计算\n聚合：加权平均、手动制定规则、分类器等\n聚类：层次聚类、相关性聚类、Canopy+K-means\n表示学习：知识嵌入（TransE模型）\n\n\n\n\n负载均衡（Load Balance）来保证所有块中的实体数目相当，从而保证分块对性能的提升程度。最简单的方法是多次Map-Reduce操作。\n结果评估：评估准确率、召回率、值，以及整个算法的运行时间。\n\n\n\n\n知识推理\n概念\n通过各种方法获取新的知识或者结论，这些知识和结论满足语义。\n\n\n任务\n可满足性（satisfiability）\n分类（classification）\n实例化（meterialization）\n\n\n方法\nOWL本体推理：基于Tableaux运算的方法\n使用场合：检查某一本体的可满足性，以及实例检测。\n基本思想：通过一系列规则构建Abox，以检测可满足性，或者检测某一实例是否存在于某概念。\nABox解释：TBox定义了特定知识领域的结构并包含一系列公理，可以通过已有概念构成新的概念。ABox包含了TBox中概念的实例。\n\n\n基于逻辑编程改写的方法：规则推理\n由于本体推理仅支持预定义的本体公理上的推理，用户无法定义自己的推理过程，因此引入规则推理，可以根据特定的场景制定规则，以实现用户自定义的推理过程。\n\n\n基于产生式规则的方法\n产生式系统：一种向前推理系统，可以按照一定机制执行规则从而达到某些目标，与一阶逻辑类似。\n产生式系统的组成：事实集合（Working Memory）、产生式/规则集合、推理引擎。\n应用：自动规划、专家系统。\n\n\n基于并行技术的方法\n单机环境下多核、多处理器技术\n多机环境下基于网络通信的分布式技术\n\n\n\n\n\n\n语义搜索\n技术流程（todo）\n\n\n知识问答\n基本要求\n可用性高：支持自然语言查询\n高查询表现力：路径、连接词、非连接词、聚合、条件\n准确和全面的语义匹配：高精确度和召回率\n低可维护性：易于在不同领域的数据集之间传输（最小的适应努力/低适应时间）\n低查询执行时间：适用于交互式查询\n高可扩展性：可扩展到大量的数据集（组织规模、网络规模）\n\n\n主流方法\n基于模板的方法：模板定义、模板生成、模板匹配\n基于语义解析的方法：资源映射、Logic Form、候选答案生成、排序\n深度学习方法\n\n\n\n\n\n\n\n文本挖掘\n研究背景\n文本挖掘与分析\n文本挖掘是抽取有效、新颖、有用、可理解的、散布在文本文件中的有价值知识，并且利用这些知识更好地组织信息的过程。\n\n\n文本挖掘\n文本挖掘，也称为文本数据库中的知识发现，是从大量文本的集合或语料库中抽取事先未知的、可理解的、有潜在实用价值的模式和知识。\n文本挖掘是一个多学科混杂的领域，涵盖了多种技术，包括数据挖掘技术、信息抽取、信息检索，机器学习、自然语言处理、计算语言学、统计数据分析、线性几何、概率理论甚至还有图论。\n文本挖掘由三部分组成：底层是文本挖掘的基础领域，包括机器学习、数理统计、自然语言处理；中间是文本挖掘的基本技术，包括信息抽取、文本分类、文本聚类、文本数据压缩、文本数据处理；顶层是两个主要应用领域：信息访问和知识发现，信息访问包括信息检索、信息浏览、信息过滤、信息报告，知识发现包括数据分析、数据预测。\n\n\n自然语言处理\n自然语言处理NLP (Natural Language Processing) ，是计算机科学、人工智能和语言学的交叉学科，目的是让计算机处理或“理解”自然语言。\n\n\n\n\n基于Web文本的灾害信息获取\n技术架构\n灾害数据源：以新闻报道、官方灾害机构网站、微博、论坛等Web页面为主\n灾害主题网页抓取：针对某一灾害事件或某类灾种，从海量网页中提取灾害主题页面\n灾害事件信息解析抽取：对灾害事件时间信息、空间信息、属性信息的解析与提取\n灾害事件信息空间展示：灾害事件时空与属性信息进行二、三维可视化展示，时空特征分布图。\n\n\n关键技术\n灾害主题页面抓取\n概念：现有研究主要通过构建灾害领域关键词词典，借助搜索引擎或者社交媒体API，采用主题网络爬虫与关键词识别匹配技术，实现灾害主题页面的抓取。主题网络爬虫是根据一定的网页分析算法，判断网页与设定主题的相关程度，尽可能多地抓取与主题相关网页。\n现有问题：关键词覆盖度不够，忽略灾害文本语义特征，准确度不高等问题。\n其他方法探索：基于本体语义灾害主题爬虫框架；时间、位置、主题为要素的事件表达模板；基于机器学习（支持向量机、朴素贝叶斯）等。\n\n\n中文分词\n概念：中文通用的分词方法主要有机械匹配、语义分词和人工智能3种方法。但在各类型领域中，需要根据使用情况分别设计有效的分词方法。目前，直接针对灾害信息进行分词还缺乏研究。\n工具：中科院ICTCLAS分词软件、IKAnalyzer分词器\n\n\n命名实体抽取\n命名实体分类：时间、地点、属性\n基于规则的方法：主要利用命名实体描述特征，通过归纳总结建立识别规则进行识别，适用于小规模语料，速度快，但规则构建困难，系统可移植性差，难以解决语义多样性问题。\n利用统计模型方法：对大规模语料库内的命名实体以及上下文进行统计分析，构建统计模型来进行命名实体的识别，如隐马尔可夫模型、最大熵模型、条件随机场模型等等。\n基于机器学习的方法：以训练语料作为学习用例和测试用例，与特定的语言无关，可以减少人工干预的过程，并且可移植性较好，但对训练语料依赖性较大，必须对语料库进行准确标注。\n\n\n空间信息展示\n\n\n\n\n灾害事件下社交媒体数据分析\n灾害事件检测与跟踪\n将微博、Twitter等社交媒体用户看作为传感器，采用自然语言处理、文本挖掘、机器学习等技术对灾害相关文本进行识别、分类、挖掘、聚类，实现对灾害事件的检测、实时预警，以提高态势感知以及对灾害的应急响应能力。\n客观灾害信息获取与分析\n灾害地理空间信息识别：基于命名实体抽取等方法进行灾害地理空间信息（VGI）识别，包括受灾人群位置识别、社区识别、地理编码、空间可视化等。\n灾害信息抽取与分类：通过基于规则词典、基于机器学习等方法，对灾害损失数据抽取和灾情信息分类，或在短文本抽取方法上创新。\n灾情感知与损失评估：将社交媒体数据与传统遥感地理数据相结合，对灾情及损失进行评估。如洪水淹没范围估计等等。\n现有问题：社交媒体数据主观性强，具有非理性、盲从性特点，客观灾害数据可靠性、数据质量存在问题。\n\n\n主观用户行为的获取与分析\n灾害事件下的用户行为是指公众通过分享自己的行动、想法、观点、感受、情绪等来表达灾害事件的反应，不仅指实际的行动，还包括认知和感知的因素。\n社交媒体丰富的用户内容数据、自带时空属性，文本挖掘等技术的快速发展使得从海量社交媒体数据中获取用户的行为成为可能。\n用户行为指标形式多样，例如用户的发文数量、话题观点、情绪、转发、点赞、评论等等。\n本研究将现有用户行为研究总结以下四个方面：情绪与情感的分析、话题抽取与分析、使用动机和传播行为、研究框架与理论模型探索。\n用户情绪与情感的分析：情感分析（sentiment analysis）是指带有情感色彩的主观性文本进行采集、处理、分析、归纳和推理的过程。现有研究借助自然语言处理的方法识别灾害事件下用户社交媒体内容表现出的情感倾向、情绪指数、情感类别。并结合社交媒体时间、空间、网络等属性，分析灾害事件下用户情绪情感的时空分布、不同阶段的变化特征、地理-社会分布不均性、社交网络传播特征、与灾害事件空间分布的关系等等。\n用户话题抽取与分析：从社交媒体文本中挖掘灾害事件下用户的话题观点，发现灾害期间民众的话题热点，对其进行时空统计分析、时空分布特征分析、话题分布与灾害事件的关系，增强对灾害情景的感知和舆情的监测。\n用户动机和传播行为研究：用户动机和传播行为是指灾害事件下社交媒体用户的发文频率、转发、评论、点赞等行为。\n综合研究框架与理论模型探索：大部分研究主要集中在社交媒体数据的应用方面，对数据本身特征关注度不足。部分学者关注社交媒体数据多维度特征，进行用户行为的研究框架和理论模型方面的创新研究。\n\n\n\n\n\n网络分析方法进阶\n地理网络分析基础\n图的基本概念\n图的定义\n$G=\\left$\n：节点集合\n：联线集合\n\n\n\n\n网络与地理网络\n网络：从实际问题中抽象出来，用图论表达的一种模型，即按一定拓扑结构连接在一起的节点和联线集合，是表示对象及其相互联系的加权图。本质是承载物质、能量和信息流动的一维受限空间。\n地理网络：相互连接及作用的线状地理实体结构形式地理网络要素的相互作用及物质、能量在网络上的传输，形成了丰富的地理现象。\n\n\n地理网络表达的基本要素\n联线/边（Link/Arc/Edge）：资源传输的通道，如交通线路、市政管线、河道等。\n节点（Node/Vertex）：通道端点或汇合点，如交叉路口、河流交汇点等。\n附属点（Point）\n障碍（Barrier）：阻碍弧段上能量流动的点。\n中心（Center：接受或分配资源的点，如商业店铺、物流仓库，状态属性包括资源容量、限制条件等。\n站点（Stop）：路径中资源增减点，如公交车站。\n\n\n\n\n地理网络度量指标计算\n网络统计与拓扑指标（从统计或拓扑角度出发以描述网络的完整性、复杂性和联通性）\n网络密度：\n联线频率：\n完整性系数：\n网络连接度：\n\n\n网络几何形态指标（从几何形态度量网络结构）\n曲折度：\n迂回度：\n\n\n网络节点地位度量指标\n接近中心性\n中介中心性\nPageRank\n\n\n\n\n最优路径算法\n搜索策略\n自由式搜索：无信息辅助，采用穷举搜索策略，不对搜索进行控制。\n启发式搜索：利用知识或经验（rule of thumb）进行搜索，通过选定评估函数，在搜索的每一步，寻找评估函数得分值最高的节点作为扩展搜索节点。可将搜索限定在一定规模内。基于启发式策略的最短路径算法例如A*算法。\n\n\nDijkstra\n历史：1959年由荷兰计算机与数学家E.W.Dijkstra提出。\n作用：可以求出某节点到连通网络中任何一个节点的最短路径及其长度；同时适用于求解有向图或无向图上的最短路径问题。\n条件：图中不存在负权边。\n基本思想\n对于图，记源节点为 、已标记节点集、从到的距离为，令数组记录到的最短距离、记录从到路径上前面的一个节点。\n步骤一：从中选择使值最小的节点，将加入到中。\n步骤二：更新与直接相邻节点的值，其中。\n重复执行步骤一和步骤二，直到，算法停止。\n\n\n特点\n通用性好\n效率依赖于具体的实现方法或运行结构\n\n\n提升\n设计优先级队列，提升集合上的提取最小值操作的效率。\n采用叉堆、二项堆或Fibonacci堆优先级队列实现Dijkstra算法，时间复杂度为或。\n采用桶结构基数堆实现Dijkstra算法，在假定弧段整数权值前提下，复杂度为，其中为最大整数权值。\n基数堆和F堆相结合的Dijkstra算法复杂度仅为。\n\n\n\n\n\n\n\n\n交通网络分析算法进阶\n最优路径算法\n搜索空间约束算法\n特点\n节点搜索过程中引入地理网络空间分布特征，将搜索限制在一定范围内，加速搜索过程。\n\n\n思想\n设置条件。的临界点构成以、为焦点，以为长轴的椭圆。即使在与、与之间存在直线路径，由于二者之和已经大于所估计的至的最短路径的极大值，在运行过程中不考虑此节点。\n在网络中系统抽样构造节点集合与。则其笛卡尔集中的每个元素可看成待求最短路径的起终节点，其欧氏距离为，网络最短路径长度为，则比值系数。\n对于抽取样本得到比值系数集合，统计后可得到某一特定值，使得中总数为满足一定置信水平的元素，其值不大于。每一对起终节点的欧氏距离乘以，可得椭圆长轴。\n判断每个新扩展出的节点是否落在限定椭圆内需大量乘积与开方计算。采用椭圆最小包含矩形限制搜索区域，在继承搜索规模限制条件下，提高搜索效率。\n由起、终节点、坐标构建椭圆方程：\n\n\n\n\n对、求偏导数后得到两者的极值：\n\n\n\n\n\n\n搜索方向约束——A*算法\n历史：1968年由Peter Hart等提出。\n思想：根据当前节点到目标节点的估计距离，引导途经节点的选择。形式化表达为，其中表示起点到节点的代价，表示节点到终点的评估代价。\n时间复杂度：依赖于启发式策略。\n\n\n搜索层次约束——导航路径规划\n导航路网的分层分区组织\n\n\n则路径算法\n历史：1959年由Hoffman和Pavley提出。\n思想：按照指定标准，寻找起点和终点间的多条最优路径。\n\n\n旅行商问题（TSP）\n历史：1930年由Merrill Flood提出。\n目的：寻找由起点出发，仅通过给定点一次，再回到起点的成本最小路径。\n解空间大小：\n精确算法：搜索最优解（穷举搜索、动态规划、分支定界、分支裁剪算法）\n有损算法：牺牲有限精度换取效率、近似最优（禁忌搜索、遗传、模拟退火、蚁群算法等）\n\n\n多车送货问题（VRP）\n历史：1959年由Dantzig和Ramser提出。\n目的：针对不同地理位置上多个客户的货物需求，为一个车队规划适当的行车路线，在特定约束下为客户送货。\n解空间大小：\n问题形态：顾及时间窗口限制的VRP、最佳服务时间的VRP、多车种VRP、考虑同时收集货物的VRP等\n解决方案：数学解析法、插入法、交换法、数学规划近似法\n\n\n路径寻优算法的现代技术\n对OD间最短路径进行实例化编码，将部分最短路径计算转变为子图间路径的直接查询。\n采用智能优化方法近似求解NP类路径寻优问题。\n动态路径寻优（行程时间切片算法、完全随机动态算法、历史数据经验推理、个体/部分/全局式路径规划与诱导；动态TSP、动态VRP）。\n采用并行、任务分解、GPU等HPC方法，支持互联网超大规模路径搜索应用。\n\n\n\n\n资源分配算法\n资源分配问题\n也称为选址与分配（Location-Allocation）问题。选址问题是指依据资源需求点的分布，确定最优的供应点配置；分配问题是根据供应点配置状态，将资源需求点分配给合适的供应点。\n\n\n-中心问题\n在个候选点中选择个供应点为个需求点服务，使得为这几个需求点服务的总成本（距离、时间或费用）最小（或最大成本最小）。\n假设记为需求点的需求量，记为从候选点到需求点的成本，则问题可描述为。\n其中为分配系数且满足（）。如果需求点接受供应点服务，则为，否则为。\n约束条件保证了每个需求点仅接受一个供应点服务，并且只有个供应点。\n\n\n-中心问题不同类型\n实际应用中，在选择供应点时，并不只是要使总加权距离最小，有时需要使总的服务范围为最大，有时又限定服务的最大距离不能超过一定的值。\n建立图书馆、医院等公共设施：希望各居民区到这些设施的路途最短（Optimal meeting point problem）。\n建立消防站、急救中心：不仅需要路途最短，而且常常规定到最远的居民区，必须在2-3分钟以内到达。\n设计有线电视中转站或通讯中心交换站：不仅要节省布线成本，而且还要使服务范围尽可能大（Maximum coverage problem）。\n\n\n\n\n可达性分析方法\n可达性\n字面含义：某一地点到达其他地点、或其他地点到达这一地点的便利程度。\n实际含义：一种对点与线、点与点地理要素进行空间关系分析的过程，包括空间阻隔、机会累积、空间相互作用方法。\n基于空间阻隔（space separation）：从几何形态角度分析空间上两点间的阻隔程度。\n基于机会累积（cumulative opportunity）：某点在确定时空范围内所能接触到的机会累积量。\n基于空间相互作用（spatial interaction）：某点和周边不同规模兴趣点之间的加权相互作用规模。\n\n\n多层面涵义\n客观层面（交通运输的便利性）\n主观层面（服务获取的难易度）\n主观层面（地理区位的优劣性）\n\n\n可达性度量涉及指标\n地点与其周边兴趣点之间的距离\n不同兴趣点对地点的潜在吸引力\n吸引力距离衰减特征（线性衰减、指数衰减等）\n不同区域需求规模（享受兴趣点服务的机会）\n\n\n交通出行便捷性\n交通便捷性：通过衡量机动车在确定时间内的出行范围大小，衡量某地点的地面交通便捷程度。\n\n\n区位优势度评价\n空间相互作用\n\n：两点间势能\n：两点的规模\n：两点间路径\n：距离衰减系数\n：常数项\n\n\n区位优势度\n\n\n\n\n模型影响因素\n吸引点数量或质量规模，如地铁站数量、商业区名气与声誉、大型公园/绿地质量、工业区就业岗位数等，与吸引力成正比。\n到吸引点的距离d，与吸引力成反比。\n\n\n距离衰减函数\n线性衰减\n指数衰减\n\n\n\n\n服务便利性评价\n服务便利性：通过与周边某种类型服务设施的供给及某地点需求量的加权均值，衡量该地点的居民服务可达性。\n两步搜寻法\n步骤一：对每个供应点，通过距离衰减函数折现，将所有需求点（）的周边需求相加，计算供需比。\n步骤二：对每个需求点，将所有供应点（）的距离衰减函数折现的比率相加，获得需求点的可达性。\n输出：可达性的加权均值（以需求量为权重）等于区域总供给量与总需求量的比值。\n\n\n\n\n\n\n\n\n复杂地理网络分析方法\n现实网络中的现象\n小世界现象：WS模型\n无标度现象：BA模型\n\n\n复杂网络\n定义\n介于规则网络和随机网络之间，统计特征与它们截然不同的的网络形态。\n\n\n特征\n具有小世界、无标度、自组织、自相似中部分或全部性质。\n大量真实复杂系统的拓扑抽象，开展研究有助于理解“复杂系统复杂性”。\n\n\n基本度量指标\n平均路径长度：网络中所有节点间最短距离的平均值，描述网络中节点间的分离程度。\n聚集系数：描述网络中节点的聚集情况，即邻接节点间也邻接的比率。\n\n\n结构度量方法\n整体结构特征：平均最短路径，聚集系数、网络直径，网络密度、层次性、网络效率、最大独立子团等\n节点关系：同配指数、节点互惠性、富人俱乐部特性等\n网络类型：幂律分布、小世界商、归一化指数、小世界指数等\n\n\n节点重要性度量方法\n基于节点邻接关系：度值、核分解法等\n基于最优路径计算：节点离心率、接近中心性、中介中心性等\n基于特征向量计算：特征向量中心性，PageRank算法，HITs算法等\n基于节点移除效应：节点删除后的最短距离度量、生成树度量等\n\n\n社区探测\n揭示复杂网络中固有的团聚（Community）结构（若干联系紧密的节点集合），发现复杂网络中隐藏的规律，辅助理解复杂网络功能，预测复杂网络行为。\n模块度（Modularity）：针对某种聚类规则，将网络划分成个群落，定义一个的矩阵，表示、两个群落的邻接边在所有边中的占比，则有，其中。\n\n\n\n\n\n\n\n轨迹数据挖掘与位置服务\n移动对象管理技术\n移动对象轨迹定义\n移动对象随时间推移的坐标序列集合。记第个位置点为，则移动对象轨迹表示为。\n\n\n移动对象轨迹数据价值\n个体轨迹数据反映了个体在不同地理单元出没的时空模式，也隐含表达了个体间、个体与地理单元间、个体与社会之间的交互。\n单一对象移动轨迹反映个体自身行为特征，群体移动轨迹反映群体共同的行为特征。地理单元大量移动对象轨迹，反映该区域的自然、社会、经济活动总体特征。\n轨迹蕴含知识对认识人地关系、优化决策意义重大。通过轨迹数据挖掘探求深层次的因果关系或作用机制，是解决诸多重大社会问题的有效手段\n\n\n移动对象数据库技术\n地图服务应用激发了大量移动对象轨迹查询需求。移动对象数据库MOD（Moving Objects Databases）技术应运而生。\n\n\n移动对象数据管理需求\n空间表达\n支持自适应地理空间剖分\n支持移动对象位置和轨迹表达\n\n\n时间表达\n支持连续时间表达\n支持移动对象全时态轨迹表达\n\n\n关系表达\n移动对象运动过程时变属性\n支持移动对象专题语义关系\n\n\n时空查询\n支持移动对象时态查询\n地理空间查询\n支持联合查询\n\n\n\n\n移动对象轨迹空间模型\n欧几里得同质空间\n受约束的欧几里德空间\n时空水族馆\n异质场空间\n不规则方块\n网络空间\n\n\n移动对象轨迹表达方式\n拉格朗日方式：移动对象轨迹以笛卡尔坐标序列连续表达（随波逐流）。拉格朗日方式表述侧重于“点”，把移动对象的性质定义为点坐标的函数。\n欧拉方式：移动对象轨迹以途经地理单元（固定锚点邻域）离散表达（岿然不动）。欧拉方式表述侧重于“场”，把移动对象的性质定义为地理单元+时间的函数。\n\n\n\n\n轨迹数据挖掘技术\n轨迹数据挖掘研究主题\n轨迹数据预处理：噪声滤波，分割、停留点语义识别和地图匹配\n轨迹数据管理/个体隐私保护：MOD、大数据管理平台、分布式计算、匿名化与位置加密\n轨迹不确定性/插值与位置预测：轨迹误差处理或缺失轨迹填补，未来出现位置推断\n模式识别/对象分类与异常检测：轨迹模式识别（聚集模式、序贯模式、周期模式）、移动对象分类与状态识别（分段特征提取——对象状态推断）、轨迹异常检测（识别异常轨迹，发现异常事件）\n\n\n轨迹数据挖掘基本框架\n轨迹数据挖掘重点任务\n地图匹配\n概念：将通过各种定位技术获取的道路网络上的移动对象坐标序列拟合到道路网络上的技术方法。\n\n\n轨迹重构\n概念：处理轨迹中的异常坐标，或者对缺失轨迹点或轨迹段进行推断的技术方法。\n研究重点：考虑轨迹点时空缺失规律的移动对象运动频繁模式挖掘，解决数据稀疏性与问题精细化求解之间的矛盾。\n\n\n轨迹聚类\n概念：基于轨迹的时空相似性，将具有相似行为的移动对象进行聚类。\n\n\n时序分析\n移动对象轨迹数据所附带的时间标签，使得轨迹数据的时序分析演化为流数据分析过程，可推断网络的运行状态。\n\n\n轨迹预测\n概念：通过挖掘轨迹时间序列或者历史数据，预测移动对象未来某个时间可能的位置。\n\n\n异常检测\n概念：根据历史和实时轨迹信息挖掘统计模式，判断是否出现异常轨迹。\n原理：对比实时轨迹与历史轨迹特征参数，判断轨迹异常发生的位置及程度，如交通异常与人群移动异常\n\n\n\n\n\n\n基于位置的信息服务\n位置服务（LBS）定义\n集成移动定位、地理信息系统、无线通讯等技术，基于移动终端的实时位置，在地图平台支持下，提供地理信息服务的技术系统或增值服务业务。位置服务涉及出行导航、社交网络、监控关爱、广告推送、企业管理等多个领域。\n\n\n位置服务的地图表达新需求\n交通网络表达：从单模式到多模式\n拓扑关系表达：从二维到三维拓扑\n地图形态需求：从固化地图到SLAM\n\n\n\n\n\n数字地形分析\n数字高程模型DEM\nDEM及相关概念\nDEM：数字高程模型\nDSM：数字表面模型=高程+表面高度\nDTM：数字地形模型=高程+坡度+曲率+河网+流域边界+……\n\n\nDTA所用的DEM数据结构\nDEM生产：高程点/点云、等高线\nDTA：三角网、栅格（正方形为主）\n\n\nDEM数据源（现代地形测量）\n地面控制测量（用于航空摄影测量）\nGPS测量\n大区域DEM多采用航空测量\nSRTM\nASTER\n\n\nLiDAR(Light Detection And Ranging)\n\n\nDEM中的研究问题\n更高质量的DEM\nDEM生成算法、算法评价\n数据结构转换：高程点/点云→TIN、TIN→栅格\n分辨率变换：插值、重采样\nDEM预处理/修正：去除地表附着物、去噪声、填充空值区、多数据集合并等\n\n\nDEM产品评价\n基于参考数据（地表控制点等）\n无参考数据（根据DTA应用结果合理性等）\n\n\n\n\nDEM数据更高的应用功效\nDEM误差信息作为DEM的一个组分\n多尺度DEM——服务于各种具特定尺度的应用\n\n\n\n\n\n\n数字地形分析DTA\nDTM\n地形信息\n地形属性：场→多表达为栅格\n地形特征：点/线/多边形/边界→常表达为矢量\n\n\n地形属性、地形特征之间可相互转换\n\n\n地形属性\n坡度（Slope gradient，）：海拔高度的最大变化率\n坡向（Aspect）：坡度最大变化率的罗盘方向\n曲率（Curvatures）：高程的二阶导数\n单位汇水面积（Specific Catchment Area）：\n地形湿度指数（Topographic Wetness Index）：\n水流强度指数（Stream Power Index）：\n坡长因子（Length-slope factor in the Revised Universal Soil Loss Equation）：\n\n\n数字地形分析算法\n根据所得DTM目标的分类\n基本地形属性的算法\n派生地形属性的算法\n地形特征提取算法\nDEM预处理算法\n\n\n根据计算时每点对应支撑域特点（local、focal、regional、global）的分类\n局域计算DTA算法\n区域DTA算法\n\n\n根据算法设计特点的分类\n迭代算法\n递归算法\n\n\n\n\nDTA中的方法研究问题\n已有地形属性的新算法研究\n单流向算法（SFD）\nD8算法\n\n\n多流向算法（MFD）\nFD8算法\n\n：第个邻域像素中的水流分配比例\n：水流分配指数\n：第个邻域像素的有效等高线长度\n存在的问题：常数忽视了地形特征对水流分配的不同作用\n\n\n\n\n新的MFD算法（MFD-md）\n基本思想：水流分配应符合当地的局域地形条件。\n模型：随局域地形条件自适应的水流分配策略根据局域地形变量建立水流分配函数，用以确定下坡方向的水流分配比例。\n公式：\n\n\n\n\nDTA算法的评价\n目的\n评估DTA算法的可用性\n\n\n角度\n准确性\n不确定性\n\n\n\n\n新的地形信息\n坡位空间渐变信息\n\n\n多尺度DTA\n对具体的应用确定适宜尺度：DEM分辨率所体现的尺度并非都适合于实际应用条件\n多尺度地形信息的定量化：不同尺度下的结果综合为一个单一的多尺度指标\n\n\n\n\n\n\n\n","categories":["学科笔记"]},{"title":"《空间分析》笔记","url":"/posts/f3f80ce4/","content":"地理信息系统与空间分析的基本概念\n空间分析思想\n地理信息系统原理主要内容\n坐标系统\n投影转换\n地理数据模型：矢量数据模型与栅格数据\n空间数据存储与管理\n空间数据可视化\n地图编辑与绘制\n空间拓扑分析\n空间叠加分析\n\n\n地理信息科学与地理学的关系\n地理信息系统是地理学数字化和定量分析的工具，是地理学中的“数学”。\n\n\n空间分析的基本概念\n地理对象的特征可采用不同的空间数据类型表达\n地理对象之间以及内在的模式、规律反映为空间关系\n空间分析模型是针对特定空间数据揭示某种空间关系\n\n\n空间数据的类型\n空间要素数据模型：土地类型、道路、行政边界、河流、时空轨迹等等\n空间栅格数据模型：遥感数据、各种图像、可由其它数据转换得来\n空间网络数据模型：交通网络、签到表、QQ好友、电网、论文引用\n空间连续场数据模型：高程数据、地球化学元素含量、气象数据（气温、污染物浓度）、人口密度、社会经济数据（人均收入和产值等）\n空间复合数据模型：台风、海洋涡旋\n\n\n空间数据之间的转换\n空间场模型→\n格网模型\n\n\n空间要素模型→\n空间场模型\n格网模型\n\n\n格网模型→\n空间场模型\n空间要素模型\n空间网络模型\n空间复合数据模型\n\n\n空间网络模型→\n空间要素模型\n格网模型\n\n\n空间复合数据模型→\n空间要素模型\n格网模型\n\n\n\n\n\n\n空间关系的类型\n空间方位与距离关系\n空间拓扑关系\n空间（自）相关\n空间配置关系\n空间互作用关系\n空间网络关系\n空间传播\n空间复杂关系\n\n\n\n空间分析统计基础\n简介\n空间分析的描述\n概念\n空间分析（Spatial analysis/Spatial statistics）是用来分析空间/地理对象的几何、拓扑和属性数据的方法。\n空间分析为发现地理现象和过程的规律性-Pattern提供定量的数值描述、操作方法和统计证据支持（Pattern包括时空趋势、分布、相关性、异质性、邻近性、可达性等）。\n\n\n基于统计的空间分析方法\n通常是一般统计方法在分析地理（空间）问题上的扩展\n地理（空间）现象通常具有位置（显式/隐式）和相对位置关系（拓扑）\n地理（空间）问题的研究通常是位置和位置关系依赖的\n需要在一般统计方法上发展针对数据位置信息进行处理\n分析的结果通常也是位置和位置关系相关的-（时）空间模式\n总体来看，空间分析的处理过程与一般统计方法是一致的\n\n\n\n\n基于经典统计方法的（空间）分析步骤\n研究问题的提出\n数据的收集与处理\n探索性分析\n确定假设（猜测）\n建模和检验\n统计结果分析\n结果呈现与问题结论描述\n\n\n\n\n基础统计知识\n概率与概率分布\n概率（Probability）：是对一个（随机）事件发生的可能性的度量，一般用之间的实数表示，表示绝对不会发生，表示一定会发生。\n概率密度函数PDF（Probability Density Function）：刻画连续型随机变量取不同值的相对可能性大小（relative likelihood）。\n概率质量函数PMF（Probability Mass Function）：刻画离散型随机变量取值的相对可能性。\n\n\n随机变量的数字特征\n实际问题的概率分布通常很难知道\n利用数字特征来刻画随机变量的分布状况\n通过样本（Sample）对总体（Population）进行估计\n样本均值：观测值的中心趋势、总体期望的估计\n样本方差：变量观测值偏离均值的程度、总体方差的无偏点估计\n\n\n点估计与区间估计\n统计估计是由样本来推测总体的特征。\n点估计是由样本对总体特征参数给出单值的最佳估计。\n区间估计是给出总体参数的可能值的区间，称之置信区间和可信区间。\n期望与方差的点估计\n\n\n：样本对总体的无偏估计\n\n\n期望的区间估计\n\n满足标准正态分布，未知时，采用分布。\n\n\n\n\n方差的区间估计\n\n满足分布，置信区间下，记和分别为给定自由度分布和对应的临界值。\n\n\n\nBootstrapping\n基本思想：对一个观测样本经多次重复（有放回）随机抽样而产生的系列新样本，然后分别进行计算，由计算结果的分布给出对应的置信区间的估计。\n\n\n\n\n统计假设检验\n统计假设检验/显著性检验\n事先对总体的分布、特征参数、变量关系等作出一个假设，利用样本来判断假设的合理性，即判断样本信息与假设差异的显著性来决定是否拒绝该假设。\n假设检验的核心思想为某种带有概率性质的反证法— 即先认为某种假设是成立的，如果导出一个不合理的现象，则拒绝假设，称为不相容的（incompatible），可以接受替代假设；否则不能拒绝假设，称为相容的。\n不合理的现象是指“发生了小概率事件”，即在给定假设条件下由样本计算的检验统计量位于对应概率密度分布的两端。\n此检验以拒绝原假设为主。\n\n\n参数检验和非参数检验。\n非参数检验不意味着不使用参数（不使用总体分布的特征参数）。\n参数检验适用于正态总体，非参数适用于非正态总体。\n参数检验考虑总体分布，通过估算总体特征参数构建检验统计量。\n非参数检验不考虑总体分布，直接构建统计检验量。\n参数检验利用总体信息，非参数检验利用样本信息。\n参数检验参数固定，非参数检验参数不固定。\n\n\n（空间）统计假设检验一般步骤\n确定原假设和备择假设。\n选择统计量与分布形式。\n在原假设成立下计算统计量。\n选择显著水平（通常选）。\n比较计算量和选定显著水平下的理论临界值大小以得出检验结果\n\n\n\n\n通用符号说明\n：样本量\n：样本中的第的值（若涉及两个样本则第二个样本用表示）\n：样本均值\n：样本标准差\n：总体均值\n：总体标准差\n：显著性水平（默认取）\n：自由度\n\n\n学生氏t检验\n作用\n通过单个样本，检验其总体的均值与给定值之间的大小关系。\n通过两个成对样本或两个独立样本，检验两者各自总体的均值与之差与给定值之间的大小关系。一般来说取，以检验两总体均值之间的大小关系。\n\n\n不同大小关系应用的假设与拒绝域\n不相等\n原假设：\n备择假设：\n拒绝域：\n值：\n\n\n大于\n原假设：\n备择假设：\n拒绝域：\n值：\n\n\n小于\n原假设：\n备择假设：\n拒绝域：\n值：\n\n\n\n\n单个样本\n自由度：\n统计量：\n例子\n问题：某区域分布9个气象站，2016年测得年均温异常数据如下，从区域平均水平看该地区2016年温度是否存在显著的正异常（历史背景下的变暖）？\n原假设：\n备择假设：\n临界值：\n统计量：\n结论：从区域平均水平看该地区2016年温度存在显著的正异常\nPython# needed 3rd party packages: scipyfrom scipy import statsx = [0.1, -0.2, 0.3, 0.28, 0.6, -0.1, 0.4, 0.5, 0.3]print(stats.ttest_1samp(x, 0, alternative=\"greater\"))\nTtest_1sampResult(statistic=2.745670334136337, pvalue=0.012613576750457104)\nRx &lt;- c(0.1, -0.2, 0.3, 0.28, 0.6, -0.1, 0.4, 0.5, 0.3)t.test(x, mu = 0, alternative = \"greater\")\n        One Sample t-testdata:  xt = 2.7457, df = 8, p-value = 0.01261alternative hypothesis: true mean is greater than 095 percent confidence interval:0.07817345        Infsample estimates:mean of x 0.2422222 \n\n\n\n\n成对样本\n方法：将两组样本数据之差作为一组新的数据，然后对这组新的数据应用上文“单个样本”的检验方法。\nPython# needed 3rd party packages: scipyfrom scipy import statsprint(stats.ttest_rel(x, y, alternative=\"greater\"))\nRt.test(x, y, alternative = \"greater\", paired = TRUE)\n\n\n两个独立样本\n两个样本的总体方差已知\n统计量：\n\n\n两个样本的总体方差未知且相等\n自由度：\n的合并估计量：\n估计量的抽样标准差：\n统计量：\n\n\n两个样本的总体方差未知且不相等\n自由度：\n统计量：\n\n\n\n\n相关数值的计算方法\n符号与变量名的对应关系\n：alpha\n：df\n：t\n\n\n\n伽马函数：\n解析解：\nPython：scipy.stats.t.cdf(t, df)\nR：pt(t, df)\n\n\n\nPython：scipy.stats.t.ppf(1 - alpha, df)\nR：qt(1 - alpha, df)\n\n\n\n\n\n\n正态性检验\n作用\n检验观测数据是否符合正态分布。\n\n\nShapiro‐Wilk检验\n原假设：样本来自正态总体\n备择假设：样本不来自正态总体\nPython# needed 3rd party packages: scipyfrom scipy import statsprint(stats.shapiro(x))\nRshapiro.test(x)\n\n\n\n\nMann-Whitney U检验（Wilcoxon rank-sum检验）\n作用\n此方法是一种非参数的检验方法，不要求满足任何分布，基于样本构造检验统计量，用来检验两个独立样本是否来自同一个总体。\n\n\n例子\n问题：随机检测两组不同人群（NA和CA）的某个生理指标，数据如下表。NA和CA是否来自同一样本？\n原假设：NA和CA来自同一样本\n备择假设：NA和CA来自不同样本\nPython# needed 3rd party packages: scipyfrom scipy import statsx = [8.50, 9.48, 8.65, 8.16, 8.83, 7.76, 8.63]y = [8.27, 8.20, 8.25, 8.14, 9.00, 8.10, 7.20, 8.32, 7.70]print(stats.mannwhitneyu(x, y, alternative=\"two-sided\", method=\"exact\"))\nMannwhitneyuResult(statistic=47.0, pvalue=0.11416083916083916)\nRx &lt;- c(8.50, 9.48, 8.65, 8.16, 8.83, 7.76, 8.63)y &lt;- c(8.27, 8.20, 8.25, 8.14, 9.00, 8.10, 7.20, 8.32, 7.70)wilcox.test(x, y, alternative = \"two.sided\", exact = TRUE)\n          Wilcoxon rank sum exact testdata:  x and yW = 47, p-value = 0.1142alternative hypothesis: true location shift is not equal to 0\n\n\n\n\n标准得分（Z-Scores）\n对于一个样本值，在总体均值和标准差已知的情况下，其对应标准得分为。\n满足标准正态分布（也叫分布），用于原假设下检验分布可以由正态分布来近似的统计检验，称为检验，具有唯一的临界值。\n中心极限定理表明，对于大样本（）来说，许多检验统计都可以由正态分布来近似，而小样本检验更合适。\n\n\n效应量（Effect size）\n作用\n用于测量两个变量关系/差异强度的数值量。\n\n\n\n\n方差分析（ANOVA）\n作用\n用于分析两个以上样本所代表的总体均值差异的方法\n\n\n分类\n单因素方差分析（One-way ANOVA）：使用一个类别型解释变量\n双因素方差分析（Two-way/factorial ANOVA）：使用两/多个解释变量\n\n\n符号重定义\n：总组数\n：样本总数\n：第组样本数\n：第组样本的第个值\n：第组样本的平均值\n：所有样本的平均值\n\n\n基本原理\n总误差平方和可以分解为组间平方和与组内平方和之和\n总误差平方和（）：\n组间平方和（）：\n组内平方和（）：\n组间方差（组间平方和的均方）：\n组内方差（组内平方和的均方）：\n\n\n单因素方差分析\n原假设：每组样本对应的总体的均值之间没有显著差异\n备择假设：至少有两组样本对应的总体的均值存在显著差异\n统计量：\n拒绝域：\n值：\n例子\n问题：下表为个不同地块（block字段）是否施氮肥（N字段）、磷肥（P字段）、钾肥（K字段）（为不施、为施），以及该方案下的豌豆产量（yield字段）。数据来源为R语言自带的npk数据集。不同地块上的豌豆产量之间是否有显著差异？\n原假设：不同地块上的豌豆产量之间没有显著差异\n备择假设：不同地块上的豌豆产量之间有显著差异\n组间方差：\n组内方差：\n统计量：\n临界值：\n结论：不同地块上的豌豆产量之间没有显著差异\nPython# needed 3rd party packages: pandas, statsmodelsimport pandas as pdfrom statsmodels.formula.api import olsfrom statsmodels.stats.anova import anova_lmdf = pd.DataFrame.from_dict({    \"block\": [i // 4 + 1 for i in range(24)],    \"N\": [0] + [int(x) for x in bin(6057132)[2:]],    \"P\": [int(x) for x in bin(12961174)[2:]],    \"K\": [int(x) for x in bin(9852474)[2:]],    \"yield\": [49.5, 62.8, 46.8, 57.0, 59.8, 58.5, 55.5, 56.0,              62.8, 55.8, 69.5, 55.0, 62.0, 48.8, 45.5, 44.2,              52.0, 51.5, 49.8, 48.8, 57.2, 59.0, 53.2, 56.0]})# Rename the column \"yield\" to \"yield_\" to avoid conflicting with Python's # reserved word \"yield\" when passed to `statsmodels.formula.api.ols`.df.rename(columns={\"yield\": \"yield_\"}, inplace=True)print(anova_lm(ols(\"yield_ ~ C(block)\", df).fit()))\n            df   sum_sq  mean_sq         F    PR(&gt;F)C(block)   5.0  343.295   68.659  2.318386  0.086072Residual  18.0  533.070   29.615       NaN       NaN\nRdf &lt;- data.frame(    block = factor(rep(1:6, each = 4), levels = 1:6),    N = factor(c(0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0,                 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0), levels = 0:1),    P = factor(c(1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0,                 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0), levels = 0:1),    K = factor(c(1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1,                 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0), levels = 0:1),    yield = c(49.5, 62.8, 46.8, 57.0, 59.8, 58.5, 55.5, 56.0,              62.8, 55.8, 69.5, 55.0, 62.0, 48.8, 45.5, 44.2,              52.0, 51.5, 49.8, 48.8, 57.2, 59.0, 53.2, 56.0))summary(aov(yield ~ block, df))\n            Df Sum Sq Mean Sq F value Pr(&gt;F)block        5  343.3   68.66   2.318 0.0861 .Residuals   18  533.1   29.61---Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\nKruskal-Wallis H检验（one-way ANOVA on ranks）\n作用\n一种基于排序的非参数检验，用来检验两个或以上的样本是否来自同一总体（是否有显著差异）。\n\n\n符号补充定义\n：第个样本的秩的和\n\n\n一般计算过程\n所有样本混合排序\n计算每个样本秩的和\n计算统计量\n近似满足分布\n\n\nPython# needed 3rd party packages: scipyfrom scipy import statsprint(stats.kruskal(x, y))\nRkruskal.test(y ~ x)\n\n\n双/多因素方差分析\n例子\n数据\n见上文“单因素方差分析”部分的例子\n\n\nPython# needed 3rd party packages: pandas, statsmodelsimport pandas as pdfrom statsmodels.formula.api import olsfrom statsmodels.stats.anova import anova_lmdf = pd.DataFrame.from_dict({    \"block\": [i // 4 + 1 for i in range(24)],    \"N\": [0] + [int(x) for x in bin(6057132)[2:]],    \"P\": [int(x) for x in bin(12961174)[2:]],    \"K\": [int(x) for x in bin(9852474)[2:]],    \"yield\": [49.5, 62.8, 46.8, 57.0, 59.8, 58.5, 55.5, 56.0,              62.8, 55.8, 69.5, 55.0, 62.0, 48.8, 45.5, 44.2,              52.0, 51.5, 49.8, 48.8, 57.2, 59.0, 53.2, 56.0]})# Rename the column \"yield\" to \"yield_\" to avoid conflicting with Python's # reserved word \"yield\" when passed to `statsmodels.formula.api.ols`.df.rename(columns={\"yield\": \"yield_\"}, inplace=True)print(anova_lm(ols(\"yield_ ~ C(block)\", df).fit()))\n                  df      sum_sq     mean_sq          F    PR(&gt;F)C(block)         5.0  343.295000   68.659000   4.446666  0.015939C(N)             1.0  189.281667  189.281667  12.258734  0.004372C(P)             1.0    8.401667    8.401667   0.544130  0.474904C(K)             1.0   95.201667   95.201667   6.165689  0.028795C(N):C(P)        1.0   21.281667   21.281667   1.378297  0.263165C(N):C(K)        1.0   33.135000   33.135000   2.145972  0.168648C(P):C(K)        1.0    0.481667    0.481667   0.031195  0.862752C(N):C(P):C(K)   1.0   23.965461   23.965461   1.552111  0.236600Residual        12.0  185.286667   15.440556        NaN       NaN\nRdf &lt;- data.frame(    block = factor(rep(1:6, each = 4), levels = 1:6),    N = factor(c(0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0,                 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0), levels = 0:1),    P = factor(c(1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0,                 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0), levels = 0:1),    K = factor(c(1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1,                 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0), levels = 0:1),    yield = c(49.5, 62.8, 46.8, 57.0, 59.8, 58.5, 55.5, 56.0,              62.8, 55.8, 69.5, 55.0, 62.0, 48.8, 45.5, 44.2,              52.0, 51.5, 49.8, 48.8, 57.2, 59.0, 53.2, 56.0))summary(aov(yield ~ block + N * P * K, df))\n            Df Sum Sq Mean Sq F value  Pr(&gt;F)block        5  343.3   68.66   4.447 0.01594 *N            1  189.3  189.28  12.259 0.00437 **P            1    8.4    8.40   0.544 0.47490K            1   95.2   95.20   6.166 0.02880 *N:P          1   21.3   21.28   1.378 0.26317N:K          1   33.1   33.13   2.146 0.16865P:K          1    0.5    0.48   0.031 0.86275Residuals   12  185.3   15.44---Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n结果分析\n不同地块之间平均产量有显著差异（）。\n施与不施氮(N)肥之间平均产量有显著差异（）。\n施与不施磷(P)肥之间平均产量没有显著差异（）。\n施与不施钾(K)肥之间平均产量有显著差异（）。\n氮—磷—钾之间的交互作用不显著，意味着施某种肥料对产量的影响不受其它施肥措施的影响。\n\n\n\n\n\n\n相关数值的计算方法\n符号与变量名的对应关系\n：alpha\n：df1\n：df2\n：F\n\n\n\n不完全贝塔函数：\n解析解：\nPython：scipy.stats.f.cdf(F, df1, df2)\nR：pf(F, df1, df2)\n\n\n\nPython：scipy.stats.f.ppf(1 - alpha, df1, df2)\nR：qt(1 - alpha, df1, df2)\n\n\n\n\n\n\n卡方检验\n作用\n用于类别变量（分类型变量），测试观察频数与期望频数没有显著差异。\n\n\n类别变量分类\n无次序（Nominal）：学生、工程师、教师……\n有次序（Ordinal）：不喜欢、喜欢、很喜欢……\n\n\n数据表现\n计数型的频率表\n类别之间的排他性\n\n\n两个类别变量的独立性检验\n符号重定义\n：第一个类别变量的第种取值\n：第一个类别变量总共可取的值数\n：第二个类别变量的第种取值\n：第二个类别变量总共可取的值数\n：第一个类别变量取第个取值、第二个类别变量取第个取值时的观察频数\n：第一个类别变量取第个取值时的总观察频数\n：第二个类别变量取第个取值时的总观察频数\n：观察总数\n：第一个类别变量取第个取值、第二个类别变量取第个取值时的期望频数\n\n\n观察频数表图示\n原假设：不成对的观测对象中的两个变量是相互独立的（观测数据是不同组独立随机选择的）\n备择假设：不成对的观测对象中的两个变量不是相互独立的（观测数据不是不同组独立随机选择的）\n自由度：\n统计量：\n拒绝域：\n值：\nCramer’s V\n作用：评估两个变量之间的关联强度\n统计量：\n计算公式：\n\n\n例子\n问题：份关于性别与对猫和狗偏好（二选一）的调查问卷的结果如下表。性别与对猫和狗偏好是否独立？\n原假设：性别与对猫和狗偏好之间独立\n备择假设：性别与对猫和狗偏好之间不独立\n期望频数表\n统计量：\n临界值：\n结论：性别与对猫和狗偏好之间不独立\nPython# needed 3rd party packages: scipyfrom scipy import statsx = [[207, 282], [231, 242]]chi2, p, df, expected = stats.chi2_contingency(x, correction=False)print(\"chi2 =\", chi2)print(\"p-value =\", p)print(\"df =\", df)print(\"expected values:\", repr(expected), sep=\"\\n\")\nchi2 = 4.103526475356585p-value = 0.04279386669738378df = 1expected values:array([[222.64241164, 266.35758836],       [215.35758836, 257.64241164]])\nRx &lt;- rbind(c(207, 282), c(231, 242))chisq.test(x, correct = FALSE)\n        Pearson's Chi-squared testdata:  xX-squared = 4.1035, df = 1, p-value = 0.04279\n\n\n相关数值的计算方法\n符号与变量名的对应关系\n：alpha\n：df\n：chi2\n\n\n\n解析解：\nPython：scipy.stats.chi2.cdf(chi2, df)\nR：pchisq(chi2, df)\n\n\n\nPython：scipy.stats.chi2.ppf(1 - alpha, df)\nR：qchisq(1 - alpha, df)\n\n\n\n\n\n\n\n\n方差比较\nFisher’s 检验\n作用\n检验两个正态总体的方差与之比与给定值之间的大小关系。一般取，以比较两总体方差之间的大小关系。\n\n\n自由度\n\n\n\n\n统计量\n计算公式：\n注意事项：一般约定取较大的样本方差作为分子，较小的样本方差作为分母，以保证。（参考链接：https://zhuanlan.zhihu.com/p/139151375）\n\n\n不同大小关系应用的假设与拒绝域\n不相等\n原假设：\n备择假设：\n拒绝域：\n值：\n\n\n大于\n原假设：\n备择假设：\n拒绝域：\n值：\n\n\n小于\n原假设：\n备择假设：\n拒绝域：\n值：\n\n\n\n\nRvar.test(x, y, alternative = \"two.sided\")\n\n\nBartlett检验\n作用\n检验多个正态总体的方差是否相同（方差齐次性）。\n\n\n符号重定义\n：样本组数\n：第组样本的样本量\n：样本总数\n：第组样本的标准差\n：第组样本对应总体的标准差\n\n\n原假设：所有样本对应总体的方差均相等\n备择假设：至少有两个样本对应总体的方差不相等\n合并方差：\n统计量：\n拒绝域：\n例子\n问题：下表为种不同杀虫剂（编号A至F）有效杀死害虫的数量，一行表示一种杀虫剂的样本。数据来源为R语言自带的InsectSprays数据集。所有样本对应总体的方差是否相等？\n原假设：所有样本对应总体的方差相等\n备择假设：至少有两组样本对应总体的方差不相等\n统计量：\n临界值：\n结论：至少有两组样本对应总体的方差不相等\nPython# needed 3rd party packages: scipyfrom scipy import statsx = [[10, 7, 20, 14, 14, 12, 10, 23, 17, 20, 14, 13],     [11, 17, 21, 11, 16, 14, 17, 17, 19, 21, 7, 13],     [0, 1, 7, 2, 3, 1, 2, 1, 3, 0, 1, 4],     [3, 5, 12, 6, 4, 3, 5, 5, 5, 5, 2, 4],     [3, 5, 3, 5, 3, 6, 1, 1, 3, 2, 6, 4],     [11, 9, 15, 22, 15, 16, 13, 10, 26, 26, 24, 13]]print(stats.bartlett(*x))\nBartlettResult(statistic=25.959825320368683, pvalue=9.08512233294532e-05)\nRx &lt;- c(10, 7, 20, 14, 14, 12, 10, 23, 17, 20, 14, 13,      11, 17, 21, 11, 16, 14, 17, 17, 19, 21, 7, 13,      0, 1, 7, 2, 3, 1, 2, 1, 3, 0, 1, 4,      3, 5, 12, 6, 4, 3, 5, 5, 5, 5, 2, 4,      3, 5, 3, 5, 3, 6, 1, 1, 3, 2, 6, 4,      11, 9, 15, 22, 15, 16, 13, 10, 26, 26, 24, 13)g &lt;- rep(1:6, each = 12)bartlett.test(x, g)\n        Bartlett test of homogeneity of variancesdata:  x and gBartlett's K-squared = 25.96, df = 5, p-value = 9.085e-05\n\n\n\n\nFligner-Killeen检验\n作用\n基于秩的多组方差齐次性的非参数检验。\n\n\n例子\n数据与问题：如前文“Bartlett检验”部分\nPython# needed 3rd party packages: scipyfrom scipy import statsx = [[10, 7, 20, 14, 14, 12, 10, 23, 17, 20, 14, 13],     [11, 17, 21, 11, 16, 14, 17, 17, 19, 21, 7, 13],     [0, 1, 7, 2, 3, 1, 2, 1, 3, 0, 1, 4],     [3, 5, 12, 6, 4, 3, 5, 5, 5, 5, 2, 4],     [3, 5, 3, 5, 3, 6, 1, 1, 3, 2, 6, 4],     [11, 9, 15, 22, 15, 16, 13, 10, 26, 26, 24, 13]]print(stats.fligner(*x))\nFlignerResult(statistic=14.482781038458608, pvalue=0.012816779189709195)\nRx &lt;- c(10, 7, 20, 14, 14, 12, 10, 23, 17, 20, 14, 13,      11, 17, 21, 11, 16, 14, 17, 17, 19, 21, 7, 13,      0, 1, 7, 2, 3, 1, 2, 1, 3, 0, 1, 4,      3, 5, 12, 6, 4, 3, 5, 5, 5, 5, 2, 4,      3, 5, 3, 5, 3, 6, 1, 1, 3, 2, 6, 4,      11, 9, 15, 22, 15, 16, 13, 10, 26, 26, 24, 13)g &lt;- rep(1:6, each = 12)fligner.test(x, g)\n        Fligner-Killeen test of homogeneity of variancesdata:  x and gFligner-Killeen:med chi-squared = 14.483, df = 5, p-value = 0.01282\n\n\n\n\n\n\n\n\n相关分析\n简单线性相关\n作用\n相关分析测试随机变量之间的统计依赖性。\n相关系数定量给出相关性的大小。\n相关性不能用于推断变量之间的因果关系。\n\n\nPearson相关系数\n概念\n一种参数方法，衡量变量之间的线性相关性，反映整个样本的平均响应。\n\n\n计算\n总体：\n样本：\n\n\n显著性检验\n原假设：两变量之间存在线性相关关系\n备择假设：两变量之间不存在线性相关关系\n自由度：\n统计量：\n\n\n\n\n\n\nSpearman秩相关\n概念\n一种测试统计依赖性的非参数方法，适用于连续与离散型变量，刻画的是随机变量之间的单调关系，测量的是样本对应排序的响应。\n与绝对值大小无关，对异常值不敏感。\n\n\n计算\n观测值的排序差：\n\n\n\n\n\n典型相关\n概念\n将一组变量和另一组变量之间的相关性转化为两个新的综合变量（原变量的线性组合—主成分）之间的相关，并使得新的综合变量之间存在最大可能的相关性。\n\n\n\n\n空间自相关\n“自”是指同一地理现象、过程或变量在空间上的分布。\n空间自相关用来刻画一个对象与其临近对象的相似程度。\n\n\n全局莫兰指数（Global Moran’s I）\n作用\n衡量区域（全局）尺度上某空间随机变量整体自相关的程度。\n\n\n符号定义\n：空间对象（单元）个数\n：变量在第个单元的取值\n：所有单元取值的均值\n：第个单元与第个单元之间的权重（通常两单元相邻取、不相邻取）\n：所有权重之和\n\n\n计算\n\n\n\n\n显著性检验\n原假设：变量在空间个单元上随机分布（期望）\n备择假设：变量在空间个单元上不是随机分布的\n期望：\n方差\n\n\n\n\n\n\n\n\n统计量：\n拒绝域\n：变量空间分布比期望的随机分布更加聚集（正相关），值为。\n：变量空间分布比期望的随机分布更加分散（负相关），值为。\n\n\n\n\n例子\n数据：https://github.com/Nowosad/spData/tree/master/inst/shapes中的eire.dbf、eire.shp和eire.shx。\n问题：计算爱尔兰个县A型血采样人口比例（A字段）数据的全局莫兰指数，空间权重采用二值化边连接情况，问县域空间分布有何特点（采用随机化假设）？\n统计量：\n临界值：\n结论：变量空间分布比期望的随机分布更加聚集。\nPython# needed 3rd party packages: esda, geopandas, libpysal# needed but unused 3rd party packages: matplotlibimport geopandas as gpdfrom esda.moran import Moranfrom libpysal.weights import Rookgdf = gpd.read_file(\"eire.shp\")wgt = Rook.from_dataframe(gdf)moran = Moran(gdf[\"A\"], wgt, \"B\", two_tailed=False)print(\"Moran's I =\", moran.I)print(\"z-score =\", moran.z_rand)print(\"p-value =\", moran.p_rand)print(\"E(I) =\", moran.EI)print(\"Var(I) =\", moran.VI_rand)\nMoran's I = 0.4794475720463515z-score = 4.468431593032059p-value = 3.93976011314745e-06E(I) = -0.04Var(I) = 0.013513667028641053\nR# needed 3rd party packages: sf, spdeplibrary(\"sf\")library(\"spdep\")shp &lt;- sf::st_read(\"eire.shp\")nbs &lt;- spdep::poly2nb(shp, queen = FALSE)wgt &lt;- spdep::nb2listw(nbs, style = \"B\")spdep::moran.test(shp$A, wgt)\n        Moran I test under randomisationdata:  shp$A  weights: spdep::nb2listw(nbs, style = \"B\")    Moran I statistic standard deviate = 4.4684, p-value = 3.94e-06alternative hypothesis: greatersample estimates:Moran I statistic       Expectation          Variance        0.47944757       -0.04000000        0.01351367 \n\n\n相关数值的计算方法\n符号与变量名的对应关系\n：alpha\n：z\n\n\n\n解析解：\nPython：scipy.stats.norm.cdf(z)\nR：pnorm(F)\n\n\n\nPython：scipy.stats.norm.ppf(1 - alpha)\nR：qnorm(1 - alpha)\n\n\n\n\n\n\n高/低聚类（Getis-Ord General G）\n作用\n衡量区域（全局）尺度上某空间随机变量高值/低值的聚集程度的统计量。\n\n\n符号定义\n：空间对象（单元）个数\n：变量在第个单元的取值\n：第个单元与第个单元之间的权重（通常两单元相邻取、不相邻取）\n\n\n计算\n\n当时有\n\n\n显著性检验\n原假设：变量在空间个单元上随机分布\n备择假设：变量在空间个单元上不是随机分布的\n期望：\n方差\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n统计量：\n拒绝域\n：高值变量空间分布比期望的随机分布更加聚集\n：低值变量空间分布比期望的随机分布更加聚集\n\n\n\n\n例子\n数据：https://github.com/Nowosad/spData/tree/master/inst/shapes中的sids.dbf、sids.shp和sids.shx。\n问题：计算美国北卡罗来纳州个县在1979年6月1日至1978年6月30日婴儿猝死综合症（SIDS）数量（SID74字段）数据的Getis-Ord General G，空间权重采用二值化边点连接情况，问在县级尺度空间分布上的特征（采用随机化假设）？\n统计量：\n临界值：\n结论：高值变量空间分布比期望的随机分布更加聚集。\nPython# needed 3rd party packages: esda, geopandas, libpysal# needed but unused 3rd party packages: matplotlibimport geopandas as gpdfrom esda.getisord import Gfrom libpysal.weights import Queengdf = gpd.read_file(\"sids.shp\")wgt = Queen.from_dataframe(gdf)gogg = G(gdf[\"SID79\"], wgt)print(\"G =\", gogg.G)print(\"z-score =\", gogg.z_norm)print(\"p-value =\", gogg.p_norm)print(\"E(G) =\", gogg.EG)print(\"Var(G) =\", gogg.VG)\nG = 0.06879519836041575z-score = 3.64815435158266p-value = 0.00013206547330713025E(G) = 0.049494949494949494Var(G) = 2.7988486120154605e-05\nR# needed 3rd party packages: sf, spdeplibrary(\"sf\")library(\"spdep\")shp &lt;- sf::st_read(\"sids.shp\")nbs &lt;- spdep::poly2nb(shp)wgt &lt;- spdep::nb2listw(nbs, style = \"B\")spdep::globalG.test(shp$SID79, wgt)\n        Getis-Ord global G statisticdata:  shp$SID79 weights: wgt standard deviate = 3.6482, p-value = 0.0001321alternative hypothesis: greatersample estimates:Global G statistic        Expectation           Variance       6.879520e-02       4.949495e-02       2.798849e-05 \n\n\n\n\n局部莫兰指数（Local Moran’s I）\n说明\n全局莫兰指数在假定均质的情况下给出变量总体自相关程度的统计量。\n如果区域是非均质的，全局莫兰指数无实际意义（H0下方差变化）。\n即使不存在显著的全局自相关/聚集，局部尺度也可能存在。\n全局莫兰指数可以分解为Local indicators of spatial association（LISA）。\n\n\n作用\n可以用来识别高—高和低—低聚集，以及高—低和低—高异常。\n\n\n符号定义\n：空间对象（单元）个数\n：变量在第个单元的取值\n：第个单元与第个单元之间的权重\n：所有权重之和\n\n\n计算\n\n\n\n\n与全局莫兰指数的关系\n\n\n\n显著性检验\n原假设：第个单元与相邻的单元不具有相似的值（随机分布）\n备择假设：第个单元与相邻的单元具有相似的值（不为随机分布）\n期望：\n方差\n\n\n\n\n\n\n统计量：\n拒绝域\n：第个单元与相邻单元有相似的值（高—高/低—低），即聚集。\n：第个单元与相邻单元有相似的值（高—低/低—高），即异常。\n\n\n\n\n\n\n\n\n格局分析\nJoin-count统计\n说明\n当空间随机变量是二值/类型的时候，Join-count用来评价空间离散/聚集程度。\nJoin-count统计是全局统计，也称为黑-白统计\n二值化情况下，变量临近区域的排列方式（Join）有三种：BB（1-1），BW（1-0），WW（0-0）。\n\n\n二值型空间变量的Join-count统计\n符号定义\n：空间单元数量\n：第个空间单元的值（为黑色、为白色）\n：黑色单元的数量\n：白色单元的数量\n：第个空间单元与第个空间单元之间的权重（两者相邻取、不相邻或取）\n\n\n假设\n原假设：空间变量不存在空间自相关，为随机分布。\n备择假设：空间变量存在空间自相关。\n\n\n概率\n某个单元为黑色的概率：\n某个单元为白色的概率：\n相邻单元均为黑色的概率：\n相邻单元均为白色的概率：\n相邻单元为一黑一白的概率：\n\n\n期望\n相邻单元均为黑色的期望：\n相邻单元均为白色的期望：\n相邻单元为一黑一白的期望：\n\n\n观察值\n相邻单元均为黑色的观察值：\n相邻单元均为白色的观察值：\n相邻单元为一黑一白的观察值：\n\n\n统计量\n\n\n\n例子\n数据：https://github.com/Nowosad/spData/tree/master/inst/shapes中的columbus.dbf、columbus.shp和columbus.shx。\n问题：数据为美国俄亥俄州哥伦布市1980年个街区入室盗窃和偷车每千户发案率（CRIME字段、单位：），空间权重采用二值化边点连接情况。先按划分为“low”、“high”两个等级，后按划分为三个等级，分别判断在两种划分方式下的空间格局，即犯罪发生是空间集中的（固定作案）还是离散的（随机作案）。\nR# needed 3rd party packages: sf, spdeplibrary(\"sf\")library(\"spdep\")shp &lt;- sf::st_read(\"columbus.shp\")nbs &lt;- spdep::poly2nb(shp)wgt &lt;- spdep::nb2listw(nbs, style = \"B\")crime &lt;- cut(shp$CRIME, c(0, 35, 100), c(\"low\", \"high\"))cat(\"\\nJoincount segments: [0,35], (35,100]\\n\")spdep::joincount.multi(crime, wgt)cat(\"\\n\\nJoincount segments: [0,20], (20,40], (40,100]\\n\")crime &lt;- cut(shp$CRIME, c(0, 20, 40, 100), c(\"low\", \"medium\", \"high\"))spdep::joincount.multi(crime, wgt)cat(\"\\nJtot: all pairs of x:y where x != y\\n\")\nJoincount segments: [0,35], (35,100]          Joincount Expected Variance z-valuelow:low      35.000   30.102   19.247  1.1164high:high    54.000   27.694   18.219  6.1630high:low     29.000   60.204   26.630 -6.0468Jtot         29.000   60.204   26.630 -6.0468Joincount segments: [0,20], (20,40], (40,100]              Joincount Expected Variance z-valuelow:low         12.0000   6.6224   5.4893  2.2952medium:medium   18.0000  15.3520  11.5927  0.7777high:high       37.0000  17.1582  12.7065  5.5663medium:low      17.0000  21.6735  15.5988 -1.1833high:low         5.0000  22.8776  16.2539 -4.4343high:medium     29.0000  34.3163  21.5374 -1.1456Jtot            51.0000  78.8673  23.5658 -5.7406*Jtot: all pairs of x:y where x != y\n\n\n\n\n\n\n\n\n回归分析\n简单线性回归\n说明\n回归分析用以估算自变量和因变量之间的定量关系（二者的函数关系），评估给定自变量的情况下因变量的条件期望值（预测）。\n前提是所设定的自变量和因变量存在理论上的因果关系/相关性。\n简单线性回归拟合两个变量间的线性作用（函数）关系。\n\n\n符号定义\n：样本量\n：第个自变量观测值\n：与对应的第个因变量观测值\n：自变量观测值的均值\n：因变量观测值的均值\n：与对应的第个因变量拟合值\n\n\n基本方程\n\n：因变量\n：截距\n：斜率\n：自变量\n：服从的随机误差\n\n\n最小二乘法\n参数估计\n斜率：\n截距：\n\n\n平方和分解\n总偏差平方和：\n回归平方和：\n残差平方和：\n三者关系：\n决定系数：\n\n\n显著性检验\n线性关系检验\n目的：检验自变量与因变量之间的线性关系是否显著\n原假设：\n备择假设：\n统计量：\n拒绝域：\n\n\n回归系数的检验\n目的：检验自变量对因变量的影响是否显著\n原假设：\n备择假设：\n的标准差：\n统计量：\n拒绝域：\n\n\n\n\n例子\n数据：https://github.com/Nowosad/spData/tree/master/data中的elect80.rda。\n问题：数据为1980年美国个县级区域的总统选举数据，用最小二乘法对自变量（19岁以上合法选民大学毕业的比例、pc_college字段）与因变量（19岁以上合法选民参加投票的比例、pc_turnout字段）进行简单线性回归。\nPython# needed 3rd party packages: rdata, statsmodelsimport rdatafrom statsmodels.formula.api import olsparsed = rdata.parser.parse_file(\"elect80.rda\")converted = rdata.conversion.convert(parsed)df = converted[\"elect80\"].datalm = ols(\"pc_turnout ~ pc_college\", df).fit()print(lm.summary())\n                            OLS Regression Results                            ==============================================================================Dep. Variable:             pc_turnout   R-squared:                       0.232Model:                            OLS   Adj. R-squared:                  0.232Method:                 Least Squares   F-statistic:                     938.4Date:                Sun, 10 Aug 1919   Prob (F-statistic):          2.63e-180Time:                        11:45:14   Log-Likelihood:                 2916.7No. Observations:                3107   AIC:                            -5829.Df Residuals:                    3105   BIC:                            -5817.Df Model:                           1                                         Covariance Type:            nonrobust                                         ==============================================================================                coef    std err          t      P&gt;|t|      [0.025      0.975]------------------------------------------------------------------------------Intercept      0.3218      0.008     38.483      0.000       0.305       0.338pc_college     0.5115      0.017     30.634      0.000       0.479       0.544==============================================================================Omnibus:                       58.803   Durbin-Watson:                   1.236Prob(Omnibus):                  0.000   Jarque-Bera (JB):               71.317Skew:                           0.267   Prob(JB):                     3.26e-16Kurtosis:                       3.515   Cond. No.                         12.2==============================================================================Notes:[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\nR# needed 3rd party packages: spload(\"elect80.rda\")fit &lt;- lm(pc_turnout ~ pc_college, elect80)summary(fit)cat(\"\\n95% Confidence Interval:\\n\")confint(fit, level = 0.95)\nCall:lm(formula = pc_turnout ~ pc_college, data = elect80)Residuals:    Min       1Q   Median       3Q      Max-0.46158 -0.06276 -0.00775  0.06005  0.39146Coefficients:            Estimate Std. Error t value Pr(&gt;|t|)(Intercept) 0.321783   0.008362   38.48   &lt;2e-16 ***pc_college  0.511482   0.016697   30.63   &lt;2e-16 ***---Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1Residual standard error: 0.09467 on 3105 degrees of freedomMultiple R-squared:  0.2321,    Adjusted R-squared:  0.2318F-statistic: 938.4 on 1 and 3105 DF,  p-value: &lt; 2.2e-1695% Confidence Interval:                2.5 %    97.5 %(Intercept) 0.3053883 0.3381782pc_college  0.4787443 0.5442196\n结论：拟合方程为\n\n\n\n\n泰尔—森估算（Theil-Sen Estimator）\n说明\n基于最小二乘的普通线性回归对于异常值敏感。\n该方法将斜率的估计计算为成对点斜率的中位数、截距为成对点截距的中位数，进而有效地排除异常值的影响。\n的置信区间的计算为百分位数之间的成对点斜率和截距。\n该方法是对简单线性回归斜率的无偏估计，比最小二乘方法更加稳健。\n该方法对于异常值的敏感性存在断点，意味着对在此比例之下的异常值均不敏感。\n\n\n\n\n\n\n多元线性回归\n符号定义\n：样本量\n：自变量数\n：第个自变量的第个观测值\n：第个因变量观测值\n：第个自变量观测值的均值\n：因变量观测值的均值\n：第个因变量的拟合值\n\n\n基本方程\n\n：因变量\n：自变量\n：随机误差\n\n\n最小二乘法\n参数估计\n\n\n\n\n\n\n决定系数\n决定系数\n解释：决定系数描述回归模型中因变量变化可由所有自变量解释的程度，会随着自变量个数的增加而递增（即使增加的自变量与因变量间无关）。\n计算：\n\n\n校正决定系数\n解释：校正决定系数使用自由度为权重因子，剔除了自变量个数的影响，仅在增加的自变量能够增加对因变量变化的解释程度时，才会增加。\n计算：\n\n\n\n\n显著性检验\n回归方程的检验\n目的：检验因变量与所有自变量之间的线性关系是否显著\n原假设：所有（）都为\n备择假设：存在（）为\n统计量：\n拒绝域：\n\n\n回归系数的检验\n目的：检验因变量与第个（）自变量之间的线性关系是否显著（该自变量对因变量的影响是否显著）\n原假设：\n备择假设：\n的标准差：\n统计量：\n拒绝域：\n\n\n\n\n例子\n数据：https://github.com/Nowosad/spData/tree/master/data中的elect80.rda。\n问题：数据为1980年美国个县级区域的总统选举数据，用最小二乘法对自变量（19岁以上合法选民大学毕业的比例、pc_college字段）、自变量（19岁以上合法选民中房主的比例、pc_homeownership字段）、自变量（19岁以上合法选民人均收入、pc_income字段）与因变量（19岁以上合法选民参加投票的比例、pc_turnout字段）进行简单线性回归。\nPython# needed 3rd party packages: rdata, statsmodelsimport rdatafrom statsmodels.formula.api import olsparsed = rdata.parser.parse_file(\"elect80.rda\")converted = rdata.conversion.convert(parsed)df = converted[\"elect80\"].datadata = {    \"x1\": df[\"pc_college\"],    \"x2\": df[\"pc_homeownership\"],    \"x3\": df[\"pc_income\"],    \"y\": df[\"pc_turnout\"]}lm = ols(\"y ~ x1 + x2 + x3\", data).fit()print(lm.summary())\n                            OLS Regression Results                            ==============================================================================Dep. Variable:                      y   R-squared:                       0.462Model:                            OLS   Adj. R-squared:                  0.462Method:                 Least Squares   F-statistic:                     889.7Date:                Sun, 10 Aug 1919   Prob (F-statistic):               0.00Time:                        11:45:14   Log-Likelihood:                 3470.7No. Observations:                3107   AIC:                            -6933.Df Residuals:                    3103   BIC:                            -6909.Df Model:                           3                                         Covariance Type:            nonrobust                                         ==============================================================================                coef    std err          t      P&gt;|t|      [0.025      0.975]------------------------------------------------------------------------------Intercept      0.0748      0.015      5.048      0.000       0.046       0.104x1             0.6920      0.019     36.294      0.000       0.655       0.729x2             0.9011      0.033     27.179      0.000       0.836       0.966x3            -0.0199      0.001    -16.806      0.000      -0.022      -0.018==============================================================================Omnibus:                      502.446   Durbin-Watson:                   1.286Prob(Omnibus):                  0.000   Jarque-Bera (JB):             1591.160Skew:                           0.820   Prob(JB):                         0.00Kurtosis:                       6.099   Cond. No.                         221.==============================================================================Notes:[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\nR# needed but not loaded 3rd party packages: spload(\"elect80.rda\")y &lt;- elect80$pc_turnoutx1 &lt;- elect80$pc_collegex2 &lt;- elect80$pc_homeownershipx3 &lt;- elect80$pc_incomefit &lt;- lm(y ~ x1 + x2 + x3)summary(fit)cat(\"\\n95% Confidence Interval\\n\")confint(fit, level = 0.95)\nCall:lm(formula = y ~ x1 + x2 + x3)Residuals:    Min       1Q   Median       3Q      Max-0.23074 -0.05443 -0.00963  0.04717  0.73789Coefficients:            Estimate Std. Error t value Pr(&gt;|t|)(Intercept)  0.074784   0.014814   5.048 4.72e-07 ***x1           0.692005   0.019067  36.294  &lt; 2e-16 ***x2           0.901091   0.033154  27.179  &lt; 2e-16 ***x3          -0.019890   0.001184 -16.806  &lt; 2e-16 ***---Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1Residual standard error: 0.07923 on 3103 degrees of freedomMultiple R-squared:  0.4624,    Adjusted R-squared:  0.4619F-statistic: 889.7 on 3 and 3103 DF,  p-value: &lt; 2.2e-1695% Confidence Interval                  2.5 %      97.5 %(Intercept)  0.04573726  0.10383066x1           0.65461995  0.72938945x2           0.83608491  0.96609765x3          -0.02221041 -0.01756935\n结论：拟合方程为\n\n\n\n\n标准化系数\n解释变量量纲不同时，不容易比较单位自变量的变化引起多少因变量的改变。\n将所有变量进行标准化变换后进行拟合，产生拟合系数。\n解释为自变量一个标准差的变化会引起因变量多少标准差的变化。\n拟合后系数的显著性、整体拟合效果不会改变，只是产生了标准化的系数。\n\n\n逐步回归\n影响因变量的自变量可能很多，从中选择出具有显著影响的自变量建立“最优”的回归方程，为逐步回归。\n可以采用AIC、均方误差最小等为选择依据。\n选择方法包括前向、后向和逐步回归。\n\n\n正则化\n在自变量存在多重共线关系的时候，会使均方根误差变得很大。\n自变量过多和过少会造成过渡拟合与拟合不足。\n逐步回归中变量的选择可能与研究问题的知识背景的矛盾。\n正则化替代最小二乘估计包括L1（Lasso回归）、L2（Ridge回归）。\n\n\n主成分回归\n主成分回归是将一组解释变量利用主成分变换（线性组合）的方法产生新变量，与因变量做回归。\n主成分回归是用来解决解释变量之间的共线问题。\n主成分进行正交变换，是一种非监督式方法，其构建只用到解释变量的信息。\n\n\n偏最小二乘回归\n偏最小二乘也是利用主成分思想，对主成分进行回归。\n偏最小二乘是一种监督式的方法，利用Y和X的信息，通过最小化误差平方和找到最佳变换。\n主成分回归中主成分都是正交的，而偏最小二乘不是。\n确定主成分个数时，都可以采用交叉验证方法。\n\n\n\n\nLogistic回归\n说明\n当因变量是二值型、分类型或有序型变量时，采用Logistic回归。\nLogistic回归对因变量进行Logit变换。\n的概率在Logit变换后假定为解释变量的线性模型。\n\n\n广义线性模型\n估计采用最大似然法。\n参数显著性检验采用Wald检验（例如：Z统计）。\n模型显著性使用似然比检验。\n似然比检验通过包含和排除所有自变量参数所产生的似然函数的比值来计算统计量。\n（Deviance）近似服从自由度为参数个数的分布。\n\n\n基本方程\n\n\n\n\n例子\n数据：https://stats.idre.ucla.edu/stat/data/binary.csv\n问题：采用Logistic回归，拟合自变量（GRE成绩、数值型变量、gre字段）、自变量（GPA、数值型变量、gpa字段）、自变量（排名评级、取值范围为的分类型变量、rank字段）与因变量（是否录取，二值型变量、admit字段）之间的关系。\nPython# needed 3rd party packages: pandas, statsmodelsimport pandas as pdfrom statsmodels.formula.api import glmfrom statsmodels.genmod.families import Binomialdf = pd.read_csv(\"binary.csv\")data = {    \"x1\": df[\"gre\"],    \"x2\": df[\"gpa\"],    \"x3\": df[\"rank\"],    \"y\": df[\"admit\"]}lm = glm(\"y ~ x1 + x2 + C(x3)\", data, family=Binomial()).fit()print(lm.summary())\n                Generalized Linear Model Regression Results==============================================================================Dep. Variable:                      y   No. Observations:                  400Model:                            GLM   Df Residuals:                      394Model Family:                Binomial   Df Model:                            5Link Function:                  Logit   Scale:                          1.0000Method:                          IRLS   Log-Likelihood:                -229.26Date:                Sun, 10 Aug 1919   Deviance:                       458.52Time:                        11:45:14   Pearson chi2:                     397.No. Iterations:                     4   Pseudo R-squ. (CS):            0.09846Covariance Type:            nonrobust==============================================================================                coef    std err          z      P&gt;|z|      [0.025      0.975]------------------------------------------------------------------------------Intercept     -3.9900      1.140     -3.500      0.000      -6.224      -1.756C(x3)[T.2]    -0.6754      0.316     -2.134      0.033      -1.296      -0.055C(x3)[T.3]    -1.3402      0.345     -3.881      0.000      -2.017      -0.663C(x3)[T.4]    -1.5515      0.418     -3.713      0.000      -2.370      -0.733x1             0.0023      0.001      2.070      0.038       0.000       0.004x2             0.8040      0.332      2.423      0.015       0.154       1.454==============================================================================\nRdf &lt;- read.csv(\"binary.csv\")y &lt;- df$admitx1 &lt;- df$grex2 &lt;- df$gpax3_ &lt;- factor(df$rank)fit &lt;- glm(y ~ x1 + x2 + x3_, family = binomial)summary(fit)cat(\"\\n95% Confidence Interval\\n\")confint(fit, level = 0.95)\nCall:glm(formula = y ~ x1 + x2 + x3_, family = binomial)Deviance Residuals:    Min       1Q   Median       3Q      Max-1.6268  -0.8662  -0.6388   1.1490   2.0790Coefficients:            Estimate Std. Error z value Pr(&gt;|z|)(Intercept) -3.989979   1.139951  -3.500 0.000465 ***x1           0.002264   0.001094   2.070 0.038465 *x2           0.804038   0.331819   2.423 0.015388 *x3_2        -0.675443   0.316490  -2.134 0.032829 *x3_3        -1.340204   0.345306  -3.881 0.000104 ***x3_4        -1.551464   0.417832  -3.713 0.000205 ***---Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1(Dispersion parameter for binomial family taken to be 1)    Null deviance: 499.98  on 399  degrees of freedomResidual deviance: 458.52  on 394  degrees of freedomAIC: 470.52Number of Fisher Scoring iterations: 495% Confidence IntervalWaiting for profiling to be done...                    2.5 %       97.5 %(Intercept) -6.2716202334 -1.792547080x1           0.0001375921  0.004435874x2           0.1602959439  1.464142727x3_2        -1.3008888002 -0.056745722x3_3        -2.0276713127 -0.670372346x3_4        -2.4000265384 -0.753542605\n结论\n拟合方程：\n的取值：\n\n\n\n\n\n\nPoisson回归\n说明\n当因变量是计数变量时，使用Poisson回归。\nPoisson回归假定因变量满足Poisson分布。\n假定因变量期望的对数值是解释变量的线性函数。\n\n\n基本方程\n\n\n\n例子\n数据：https://stats.idre.ucla.edu/stat/data/poisson_sim.csv\n问题：采用Poisson回归，拟合自变量（参加项目的类别、取值范围为的分类型变量、prog字段）、自变量（数学成绩、数值型变量、math字段）与因变量（高中生一年内获奖次数，数值型变量、num_awards字段）之间的关系。\nPython# needed 3rd party packages: pandas, statsmodelsimport pandas as pdfrom statsmodels.formula.api import glmfrom statsmodels.genmod.families import Poissondf = pd.read_csv(\"poisson_sim.csv\")data = {    \"x1\": df[\"prog\"],    \"x2\": df[\"math\"],    \"y\": df[\"num_awards\"]}lm = glm(\"y ~ C(x1) + x2\", data, family=Poisson()).fit()print(lm.summary())\n                Generalized Linear Model Regression Results==============================================================================Dep. Variable:                      y   No. Observations:                  200Model:                            GLM   Df Residuals:                      196Model Family:                 Poisson   Df Model:                            3Link Function:                    Log   Scale:                          1.0000Method:                          IRLS   Log-Likelihood:                -182.75Date:                Sun, 10 Aug 1919   Deviance:                       189.45Time:                        11:45:14   Pearson chi2:                     212.No. Iterations:                     5   Pseudo R-squ. (CS):             0.3881Covariance Type:            nonrobust==============================================================================                coef    std err          z      P&gt;|z|      [0.025      0.975]------------------------------------------------------------------------------Intercept     -5.2471      0.658     -7.969      0.000      -6.538      -3.957C(x1)[T.2]     1.0839      0.358      3.025      0.002       0.382       1.786C(x1)[T.3]     0.3698      0.441      0.838      0.402      -0.495       1.234x2             0.0702      0.011      6.619      0.000       0.049       0.091==============================================================================\nRdf &lt;- read.csv(\"poisson_sim.csv\")y &lt;- df$num_awardsx1_ &lt;- factor(df$prog)x2 &lt;- df$mathfit &lt;- glm(y ~ x1_ + x2, family = poisson)summary(fit)cat(\"\\n95% Confidence Interval\\n\")confint(fit, level = 0.95)\nCall:glm(formula = y ~ x1_ + x2, family = poisson)Deviance Residuals:    Min       1Q   Median       3Q      Max-2.2043  -0.8436  -0.5106   0.2558   2.6796Coefficients:            Estimate Std. Error z value Pr(&gt;|z|)(Intercept) -5.24712    0.65845  -7.969 1.60e-15 ***x1_2         1.08386    0.35825   3.025  0.00248 **x1_3         0.36981    0.44107   0.838  0.40179x2           0.07015    0.01060   6.619 3.63e-11 ***---Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1(Dispersion parameter for poisson family taken to be 1)    Null deviance: 287.67  on 199  degrees of freedomResidual deviance: 189.45  on 196  degrees of freedomAIC: 373.5Number of Fisher Scoring iterations: 695% Confidence IntervalWaiting for profiling to be done...                  2.5 %      97.5 %(Intercept) -6.57106799 -3.98529805x1_2         0.43504394  1.85586906x1_3        -0.49020399  1.26602301x2           0.04949674  0.09107698\n结论\n拟合方程：\n的取值：\n\n\n\n\n\n\n广义线性回归\n基本方程：\n简单线性回归：\n多元线性回归：\nLogistic回归：\nPoisson回归：\n……\n\n\n线性混合效应模型\n说明\n混合效应模型是线性回归模型用于分组数据的扩展。\n分组的存在可能影响回归系数的变化。\n混合效应分为固定（fix）效应和随机（random）效应两部分。\n固定效应是指经典线性回归的部分，随机效用是指分组（地区/时间）差异部分。\n传统的线性回归模型不能处理嵌套（nested）效应。\n\n\n\n\n地理加权回归\n符号定义\n：位置\n：自变量数\n：第个自变量\n\n\n基本方程\n\n\n\n参数估计\n\n：与位置和距离有关的核权重矩阵\n\n\n带宽\n其选择决定了核权重随距离衰减的速度,直接影响回归结果。\n由固定带宽和交叉验证来确定。\n\n\n例子\n数据：https://github.com/Nowosad/spData/tree/master/inst/shapes中的columbus.dbf、columbus.shp和columbus.shx。\n问题：数据为美国俄亥俄州哥伦布市1980年个街区入室盗窃和偷车每千户发案率（CRIME字段、单位：）、家庭收入（INC字段）与房屋价值（HOVAL字段）。采用地理加权回归，拟合自变量、与因变量之间的关系。\nPython# needed 3rd party packages: geopandas, mgwrimport geopandas as gpdfrom mgwr.gwr import GWRfrom mgwr.sel_bw import Sel_BWshp = gpd.read_file(\"columbus.shp\")y = shp[[\"CRIME\"]].valuesx = shp[[\"INC\", \"HOVAL\"]].valuescrd = shp[[\"X\", \"Y\"]].valuesbw = Sel_BW(crd, y, x, kernel=\"gaussian\", fixed=True).search(criterion=\"CV\")fit = GWR(crd, y, x, bw, kernel=\"gaussian\", fixed=True, hat_matrix=True).fit()fit.summary()\n===========================================================================Model type                                                         GaussianNumber of observations:                                                  49Number of covariates:                                                     3Global Regression Results---------------------------------------------------------------------------Residual sum of squares:                                           6014.893Log-likelihood:                                                    -187.377AIC:                                                                380.754AICc:                                                               383.664BIC:                                                               5835.869R2:                                                                   0.552Adj. R2:                                                              0.533Variable                              Est.         SE  t(Est/SE)    p-value------------------------------- ---------- ---------- ---------- ----------X0                                  68.619      4.735     14.490      0.000X1                                  -1.597      0.334     -4.780      0.000X2                                  -0.274      0.103     -2.654      0.008Geographically Weighted Regression (GWR) Results---------------------------------------------------------------------------Spatial kernel:                                          Fixed gaussianBandwidth used:                                                       2.280Diagnostic information---------------------------------------------------------------------------Residual sum of squares:                                           1255.132Effective number of parameters (trace(S)):                           23.873Degree of freedom (n - trace(S)):                                    25.127Sigma estimate:                                                       7.068Log-likelihood:                                                    -148.986AIC:                                                                347.717AICc:                                                               403.369BIC:                                                                394.772R2:                                                                   0.907Adjusted R2:                                                          0.814Adj. alpha (95%):                                                     0.006Adj. critical t value (95%):                                          2.858Summary Statistics For GWR Parameter Estimates---------------------------------------------------------------------------Variable                   Mean        STD        Min     Median        Max-------------------- ---------- ---------- ---------- ---------- ----------X0                       58.938     14.623     23.242     63.899     80.882X1                       -1.186      1.132     -3.129     -0.985      1.289X2                       -0.140      0.346     -1.052     -0.097      0.792===========================================================================\nR# needed 3rd party packages: sf, spgwrlibrary(\"sf\")library(\"spgwr\")shp &lt;- sf::st_read(\"columbus.shp\")y &lt;- shp$CRIMEx1 &lt;- shp$INCx2 &lt;- shp$HOVALfm &lt;- y ~ x1 + x2crd &lt;- cbind(shp$X, shp$Y)bw &lt;- spgwr::gwr.sel(fm, coords = crd, gweight = spgwr::gwr.Gauss)cat(paste(\"Bandwidth = \", bw, \"\\n\\n\", sep = \"\"))fit &lt;- spgwr::gwr(fm, coords = crd, bandwidth = bw, gweight = spgwr::gwr.Gauss, hatmatrix = TRUE)fit\nBandwidth = 2.27505962439391Call:spgwr::gwr(formula = formula, coords = xy, bandwidth = bw, gweight = spgwr::gwr.Gauss,     hatmatrix = TRUE)Kernel function: spgwr::gwr.Gauss Fixed bandwidth: 2.27506 Summary of GWR coefficient estimates at data points:                  Min.   1st Qu.    Median   3rd Qu.      Max.  GlobalX.Intercept. 23.233234 54.124872 63.902588 68.756460 80.900619 68.6190x1           -3.130714 -1.912908 -0.984380 -0.368564  1.291075 -1.5973x2           -1.052811 -0.376735 -0.097394  0.030049  0.794577 -0.2739Number of data points: 49 Effective number of parameters (residual: 2traceS - traceS'S): 29.6163 Effective degrees of freedom (residual: 2traceS - traceS'S): 19.3837 Sigma (residual: 2traceS - traceS'S): 8.027502 Effective number of parameters (model: traceS): 23.92796 Effective degrees of freedom (model: traceS): 25.07204 Sigma (model: traceS): 7.058361 Sigma (ML): 5.048946 AICc (GWR p. 61, eq 2.33; p. 96, eq. 4.21): 403.6187 AIC (GWR p. 96, eq. 4.22): 321.6635 Residual sum of squares: 1249.101 Quasi-global R2: 0.9070486\n\n\n\n\n\n\n趋势分析\n线性趋势\n说明\n随着时间/空间存在线性改变，大小与平均变化有关。\n\n\n拟合方程\n\n：因变量\n：截距/基线\n：斜率/变化率\n：时间/空间距离\n\n\n参数求解（最小二乘法）\n\n\n\n\n线性趋势显著性检验\n原假设：\n备择假设：\n统计量：\n拒绝域：\n\n\n\n\n单调趋势\n说明\n随着时间/空间存在上升/下降的改变，通常只关心相对大小，并且对异常值不敏感。\n\n\nMann-Kendall趋势检验\n作用\n一种非参数检验方法，能检验某一自然过程是处于随机波动还是存在确定的单调改变趋势。\nMann-Kendall检验不需要样本遵从一定的分布，也不受少数异常值的干扰，只关心观测值的相对大小。\n\n\n统计量\n\n符号函数：\n时转化为Z-Score：\n\n\n完全随机假设下的期望与方差\n\n\n\n\n\n\n\n\n随机性和断点检验\n随机性（Randomness）检验\n作用：检验观测结果或样本的取值出现是否随机\n方法：Wallis-Moore Phase Frequency检验、Bartels rank von Neumann’s ratio检验、Wald-Wolfowitz Test检验……\n\n\n断点（Change-point/Breakpoint）检验\n作用：检验观测结果或样本是否存在突变点或转折点\n方法：Lanzante’s test procedures、Pettitt检验、Buishand Range检验、Buishand U检验、Standard Normal Homogeneity检验……\n\n\n\n\n空间插值\n空间插值是指由已知点位的测量值预测其它点位的值，如高程、降雨、温度等。\n空间插值是基于插值属性空间相关的假设。\n空间相关性（作用）通常随距离而减少，空间插值一般认为是距离加权作用的函数。\n空间插值输入的是采样点位数据，输出通常是格网化的面数据。\n\n\n反距离权重插值（IDW）\n思想\n假设待插值点的值是其周围一定邻域内已知点的加权平均。\n给距离近的点的权重大于距离远的点的权重。\n权重按照距离呈现幂函数衰减，因此称为反距离权重插值。\n\n\n原理\n设是变量在未知点处的估计值，则有。\n\n其中（）为未知点在一定邻域内的采样点；为搜索邻域内采样点的数目；为每个采样点的权重；为待估点和采样点之间的距离；$$p为指数参数，正值表征权重随距离衰减的快慢。\n\n\n指数参数的确定\n可通过最小化均方根预测误差RMSPE确定最佳值。\nRMSPE是在交叉验证过程中对预测表面的误差进行量化。\n针对几个不同的值绘制RMSPE。\n根据点拟合一条曲线（局部二次多项式插值法）。\n从该曲线上将最小RMSPE对应的值确定为最优选择。\nRMSPE计算公式为。其中为模拟值的个数；为对应模拟值的平均值。\n\n\n\n\n\n\n描述统计量\n距离与相似性\n距离是对象（点）之间相距多远的数值测量。\n距离可以是物理空间的长度。\n距离也可以是度量空间上的一般性测量，估算两个对象的相似性。\n\n\n多样性\n多样性指数定量测量在同一集合（区域）内，有多少种不同类型的对象以及每种类型对象数量的分布特征。\n不同类型的数量称为丰富度（Richness）\n多样性的指标有很多种计算方式，如Shannon指数、Rényi熵、Simpson指数、Gini–Simpson指数等。\n\n\n不均衡系数\nGini系数\nGini系数是统计离散特征的一种测量。\nGini系数用于描述一个区域内收入/财富在人群中的分布以及不均衡性评估。\n由Corrado Gini于1912 的“Variability and Mutability”论文中提出。\n\n\nTheil指数\nTheil指数用来测量经济/地理变量空间分布的不均衡性。\n由荷兰经济学家Henri Theil提出。\nTheil指数具有尺度上的可分解性（Decomposability），而Gini系数不具有。\n\n\n\n\n一致性\n混淆矩阵\nKappa系数\n\n\nROC（受试者工作特征）曲线\nROC利用制图的方法来表现不同阈值对于一个分类或者判别系统的执行情况，可以辅助阈值选取。\nROC通常对比的是TPR（true positive rate = TP/P）和FPR（true negative rate = TN/N）对于不同分类模型和判别阈值的响应，可用于寻找优化的模型和阈值（敏感性与特异性之间的权衡trade-off、cost/benefit）。\n\n\n地理可达性\n考虑与位置拓扑和距离有关的资源供给—需求关系。\n\n\n\n\n\n矢量数据分析和TIN空间分析\n矢量数据分析的再回顾\n基本思想\n矢量数据分析提供最简单、最朴素的空间几何操作\n空间对象的几何属性、几何分析衍生出的变量，是空间统计、聚类分类、空间建模的基础变量。\n\n\n数据组织\n几何表达（二维三维笛卡尔坐标系/球面坐标系）\n点：、（或测度值）\n线：方向性、连通性\n面：规则：三角形、六边形、S2面片等球面剖分单元；不规则：TIN三角网、泰森多边形、多边形；拓扑/非拓扑\n体：三维地质、城市设施零部件、BIM\n\n\n\n\n数据存储\n文件类型：GeoJSON、ESRI Shapefile、ESRI Coverage……\n嵌入式数据库：GeoPackage、SpatiaLite……\n空间数据库：Geodatabase、ArcSDE、PostgreSQL（PostGIS、TimescaleDB、pgRouting）、Oracle Spatial……\n\n\n数据来源\nOpen-Access数据\n遥感：土地利用分类，ICESat-2激光测高，UAV航测……\nOSM、DCW 1:1000000世界地图、腾讯大数据……\n气象、土壤、物种分布等共享网络数据……\n\n\n科学采样、统计数据\n野外样本点、社会调查、经济统计……\n\n\n志愿者地理信息/众包数据/众源数据/社交网络\n泛在定位技术：GNSS、移动通讯网络、地磁导航、Wi-Fi\n交通设施的闸机、刷卡\n社交网络平台的签到、点赞\n\n\n\n\n空间对象的几何特征\n基本特征\n属性：长度、面积\n运动：方向、速度\n空间展布：走向、倾向、倾角、法线\n\n\n高级特征\n几何中心、质心\n骨架线\n最小外接矩形MBR、最小面积矩形MAR\n最小外接圆、最大内切圆\n凸包多边形\n\n\n\n\n空间对象的空间关系判断\n八种基本关系：equal、disjoin、within、contain、intersect、touch、cross、overlap\n九交模型DE-9IM\n\n\n空间对象的基本空间分析\n叠置（Overlay）操作\nUnion、Merge、Append\nIntersection\nDifference、Systemic Difference\n\n\n缓冲分析、邻近分析\nBuffer\nProximity\n\n\n几何变换\nAffine仿射变换\nRotate\nScale\nSkew\n\n\n\n\n空间对象的距离量测\n欧氏距离及其扩展\n地面距离\n网络距离\n\n\n\n\nTIN不规则三角网\n概念\nTIN是一种矢量拓扑数据结构，内含节点（node）、边（edge）、三角形（face）。\n\n\n基本数据\n高程点\n三角面片\n\n\n派生数据\n等高线\n面片坡度、坡向、法线\n面片的方向\n\n\nDelaunay不规则三角网（DT）\n构建规则\n任何一个三角形的外接圆内不能包含任何其它离散点。\n最小角最大准则：相邻两个三角形构成凸四边形，在交换对角线之后，六个内角的最小者不再增大。\n\n\n\n\n\n\n\n栅格数据分析\n地表曲面与场分析\n曲面建模\n栅格模型，采用了一套规则格网来离散化地表的连续分布空间，像元值对应于该像元行列位置上空间对象的特征值。这种简单的数据结构计算效率很高，广泛地用于各类地学建模。\n矢量分析是基于点、线、多边形等几何对象，计算比较复杂；而栅格分析则是基于像元，类似数据矩阵，适合基于数组的数据计算。\n\n\n地表曲面的几何特征\nDEM\n坡度\n坡向\n坡向玫瑰花图\n\n\n地表曲面的可视性\n流域分析\n单向流D8\n多向流MDF\n\n\n曲面插值\n\n\n栅格分析与矢量分析的联系与区别\n矢量—栅格转换\nPOINTGRID、LINEGRID、POLYGRID\nGRIDPOINT、GRIDLINE、GRIDPOLY\n\n\n插值方法\n点：IDW、Spline、Kriging\n线：Topogrid（ANUDEM）\n基于约束条件或辅助数据的插值方法\n\n\n密度分析\n点、线图层：核密度、线密度\n矢量图层+格网：空间连接（Spatial Join）\n\n\n空间建模\n回归分析、地理加权回归法、成本距离分析……\n\n\n\n\n栅格数据分析\n基本要求\n具有统一的投影坐标系\n覆盖范围、像元分辨率相同\n图层之间像元对齐\n\n\n基本运算\n地图代数运算Local：以像元为基本运算单位,开展基于数学函数或者分类的计算。\n窗口滤波Focal：以滤波窗口为计算单元，求解像元的统计值、密度值、滤波、流向，或者构建专业模型。\n分区操作Zonal：以分区为计算单元，求解像元的统计值，或者构建专业模型。\n其他复杂模块：如水文、地下水、交通、空间统计等。\n\n\n\n\n\n连续场对象轨迹表达与分析\n轨迹基本介绍\n定义\n数学：轨迹指的是含有某种性质的所有点集合。它是一种几何形状。常见的轨迹包括直线、圆、椭圆、双曲线、抛物线等。\n力学：轨迹是指动点在空间的位置随时间连续变化而形成的曲线。轨迹是直线，称为直线运动；轨迹是曲线，称为曲线运动。\n空间轨迹：空间轨迹是运动物体在地理空间中产生的痕迹，通常由一系列按时间顺序排列的点来表示，通常用一系列按时间顺序排列的点来表示（例如），其中每个点由地理空间坐标集和时间戳组成（如）。\n\n\n分类\n根据数据描述对象\n车辆\n出租车、公交车、卡车……\n飞机、轮渡……\n\n\n动物\n迁徙：鸟类、斑马、虎……\n\n\n自然现象\n飓风、龙卷风、海洋漩涡……\n\n\n\n\n根据采样方式和驱动因素\n基于时间采样的轨迹数据：按等时间间隔对移动对象进行采样形成轨迹。\n基于位置采样的轨迹数据：移动对象位置发生变化即被记录而形成的轨迹。\n基于事件触发的轨迹数据：移动对象触发传感器事件后而被记录下来形成的轨迹。\n\n\n根据轨迹的复杂性\n简单轨迹：个体如动物、出租车、人等的运动轨迹，由于其刻画的是客观世界中自身结构不随时空发生变化、或是应用研究中可以忽略其自身结构变化的简单空间对象，这样个体的轨迹可以称之为“简单轨迹”，属于线性结构轨迹。\n复杂轨迹：属于非线性结构的轨迹。在客观世界中还存着大量的随时空位置变化自身结构也在不断变化的复杂动态现象，如海洋涡旋、 风暴、污染气体等，其内蕴复杂对象（涡旋、台风、云团等）自身结构和性质呈现快速连续的变化。这些复杂的动态演化过程存在着明显的分裂与合并现象。\n\n\n\n\n研究内容\n轨迹预处理\n噪声过滤\n分割\n压缩\n地图匹配\n停留点提取\n\n\n轨迹索引和检索\n最近邻查询\n范围查询\n\n\n轨迹挖掘\n轨迹不确定性\n轨迹模式挖掘\n轨迹分类\n轨迹异常探测\n\n\n\n\n\n\n连续场对象轨迹\n概念\n移动对象时空位置和属性同时发生变化的轨迹，例如飓风、龙卷风、海洋环流等自然现象的轨迹，这些轨迹捕捉了环境和气候的变化。\n\n\n特点\n轨迹隐含（不是以简单的位置随时间变化的特点）\n轨迹复杂（分裂和合并）\n对象时空属性同时变化\n\n\n轨迹表达\n一般轨迹表达：连续曲线→序列→点集\n复杂轨迹表达：连续曲线→图→序列集→点集\n\n\n\n\n轨迹相似性计算\n概述\n相似性计算：两个实体之间的相似性被量化为计算一个实体转化为另一个实体所需的成本或两个实体间距离。\n轨迹聚类目的是尽可能将相似轨迹划分到同一个轨迹簇，而将具有相异行为的轨迹划分到不同的轨迹簇中。轨迹聚类的关键是根据轨迹数据的特点，定义不同轨迹间相似性度量方法。\n\n\n分类\n空间相似性：找到与当前轨迹相似的几何形状，忽略时间维度\n欧式距离\n最长公共子序列\n动态时间规整\n编辑距离\n\n\n时空相似性：注重轨迹数据的时间和空间方面——时间序列、几何形状\n欧式距离\nLocality in In-between Polylines\n严格变换形式距离\nwDF\n归一化加权编辑距离\n\n\n\n\n距离度量\n时间全区间相似\n轨迹间的欧氏距离\n最小外包矩形距离\n\n\n全区间变换对应相似\n轨迹间的DTW距离\n\n\n多子区间对应相似\n最长公共子序列距离\n\n\n单点对应相似\nFréchet距离\n\n\n\n\n轨迹间距离度量方法\n欧氏距离\n概念：先将轨迹用相同维度的坐标向量表示，然后计算每一个时刻上对应两点的欧式距离，再对这些距离进行综合（如求和，求平均值、最大值或者最小值），就可以得到轨迹间欧式距离。\n优点：利用欧几里德距离来度量轨迹之间的距离简单直观。\n不足：该方法的基本思想是严格计算轨迹在每个时刻的对应距离，对数据中的噪声比较敏感，噪声数据的多少很大程度上会影响距离的度量结果。\n备注：若用欧几里德距离度量轨迹的相似性必须有合理的数据预处理过程，如降噪、插值、轨迹还原等。\n\n\n最小外包矩形距离\n概念：一种简化时空轨迹的方法。首先将整条轨迹划分成一些相对平滑的轨迹区间，再将每条子轨迹用其最小外包矩形（Minimum Boundary Rectangle）表示，这样每条轨迹就变成了一个最小外包矩形序列。最后，通过比较最小外包矩形序列即可度量时空轨迹间的相似性。\n优点：这类方法的优点在于非常直观，易于理解。\n不足：但那些不在一一对应时刻上完全相似的轨迹，则可能被遗漏。\n备注：现实生活中，轨迹的形状往往是不规则的，在对不规则形状的轨迹进行相似性度量时面临着很大的挑战。\n\n\nDTW距离\n概念：基于动态时间规整（Dynamic Time Warping）距离的方法使得轨迹间距离度量能够适应数据在时间维度的拉伸，在保证了时空轨迹对象记录点顺序不变的同时，通过重复之前的记录点完成了轨迹数据在时间维度的缩放，并以此求出轨迹间的最小距离。\n优点：可较好地发现轨迹在时间维度上进行局部缩放后才相似的时空轨迹，解决了采样频率不同造成的轨迹数据时间尺度不统一的问题。\n计算\n\n\n\n\n：第一条空间轨迹\n：第一条空间轨迹所包含的点数\n：第二条空间轨迹\n：第二条空间轨迹所包含的点数\n：两个记录点和之间的距离（函数）\n：空间轨迹去掉第一个记录点后得到的空间轨迹\n\n\n不足：在计算动态时间封装距离时，轨迹间的记录点映射需要具有连续性，因此对于噪声很敏感。此外，如果两条轨迹在小部分区间内完全不相似，该方法将无法识别。\n备注：如果两条轨迹均存在记录点，则采用递归的方式求取最小的距离作为DTW距离，在求取最小距离的过程中会产生记录点的最优对应关系。\n\n\n最长公共子序列距离\n概念：最长公共子序列（Longest Common Sub-Sequence）是指两个或者多个序列中存在的最长的共同子序列。对于时空轨迹来说，计算其最长公共子序列并转化为LCSS距离可以衡量轨迹间的相似程度。\n计算\n\n符号说明见上文“DTW距离”的“计算”部分\n\n\n\n\nFréchet距离\n概念：Fréchet距离可以这样形象地理解：在遛狗过程中，假设狗沿一条轨迹连续运动，它的主人沿另一条轨迹连续运动，他们在各自轨迹上任意一点速度都可以变化，甚至可以停止，但是不能折返，用遛狗绳将他们相连，Fréchet距离就是在保证两者运动不互相干扰的前提下，所需最短的遛狗绳的距离。\n计算\n\n\n其余符号说明见上文“DTW距离”的“计算”部分\n\n\n\n\n历史最近距离\n概念：历史最近距离是任意两条轨迹在给定时间范围内同一时刻的最近距离\n计算：\n与Fréchet距离的异同\n相同之处在于，历史最近距离和Fréchet距离这两种方法，都是将轨迹间的距离抽象为某一个时刻上点与点的距离，以此来代表整条轨迹间的距离。\n不同之处在于，历史最近距离是一种乐观的相似性度量，只要两条轨迹在某一时刻曾经靠近过就认为它们相似，而Fréchet距离是一种悲观的相似性度量，它认为必须在每一时刻都靠近才能说两条轨迹相似。\n\n\n\n\n\n\n\n\n轨迹聚类算法\n概述\n聚类分析是按照相似程度划分数据，并保持类间距离最大，类内距离最小。\n轨迹聚类是聚类分析在时空轨迹上的扩展，其目的基于空间或时间相似性，把具有相似行为的时空对象划分为一类，通过聚类发现物体移动模式，分析移动规律，甚至预测未来运动行为。\n聚类算法是无监督的学习算法；分类算法属于监督的学习算法。\n\n\n分类\n基于划分的聚类算法\n思想：给定个对象或元组的数据库构建数据的个划分，每个划分表示一个聚类，并且。划分的一般准则是：同一个类中对象之间差异（距离）尽可能小，而不同类中对象之间差异（距离）尽可能大。\n主要算法：k-means、k-modes、k-prototypes、k-medoids、CLARA、CLARANS、Focused CLARAN、PCM\n\n\n基于层次的聚类算法\n思想：对给定数据集合进行层次分解。根据层次划分方式，可以被分为凝聚或分裂方法。凝聚方法，称为自底向上方法。分裂方法，也称为自顶向下的方法。\n主要算法：CURE、ROCK、CHEMALOEN、SBAC、BIRCH、BUBBLE、BUBBLE-FM\n\n\n基于密度聚类算法\n思想：只要临近区域的密度（对象或数据点的数目）超过某个阈值，就继续聚类。也就是说，对给定类中的每个数据点，在一个给定范围的区域中必须包含至少某个数目的点。这样的方法可以用来过滤“噪音”数据，发现任意形状的簇。\n主要算法：DBSCAN、GDBSCAN、DBLASD、OPTICS、FDC\n\n\n基于网格的聚类算法\n思想：把对象空间量化为有限数目的单元，形成了一个网格结构。所有的聚类操作都在这个网格结构（即量化的空间）上进行。方法优点是处理速度很快，处理时间独立于数据对象数目，只与量化空间中每一维单元数目有关。\n主要算法：STING、WaveCluster、CLIQUE、OPTIGRID\n\n\n基于模型的方法\n思想：基于模型的方法给每一个聚类假定一个模型，然后去寻找能够很好的满足这个模型的数据集。这样一个模型可能是数据点在空间中的密度分布函数或者其它。它的一个潜在的假定就是：目标数据集是由一系列的概率分布所决定的。通常有两种尝试方向：基于统计的方案和基于神经网络的方案。\n主要算法：Competitive Learning、SOM、COBWeb、CLASSIT、AutoClass\n\n\n图论聚类法\n思想：图论聚类方法解决的第一步是建立与问题相适应的图，图的节点对应于被分析数据的最小单元，图的边（或弧）对应于最小处理单元数据之间的相似性度量。因此，每一个最小处理单元数据之间都会有一个度量表达，这就确保了数据的局部特性比较易于处理。图论聚类法是以样本数据的局域连接特征作为聚类的主要信息源，因而其主要优点是易于处理局部数据的特性。\n\n\n\n\n常见算法介绍\n基于k-means的轨迹聚类算法：E-km（Extended k-means）\nk-means简介\n介绍\nk-means算法是一种无监督学习算法，目的是将相似对象归到同一个簇中。簇内的对象越相似，聚类的效果就越好。\n\n\n原理\n使各个样本与所在簇的质心的均值误差平方和达到最小（这也是评价k-means算法最后聚类效果的评价标准）。\n\n\n优点\n算法快速、简单。\n对大数据集有较高的效率并且是可伸缩性的。\n时间复杂度近于线性，而且适合挖掘大规模数据集。k-means聚类算法时间复杂度是，其中代表数据集中对象的数量，代表算法迭代次数，代表着簇的数目。\n\n\n缺点\n算法中是事先给定，但这个值的选定非常难以估计。\n初始聚类中心的选择对聚类结果有较大的影响，一旦初始值选择的不好，可能无法得到有效的聚类结果。\n算法复杂度不易控制，迭代次数可能较多。\n\n\n\n\n算法概述\n该算法首先将轨迹分解为线段，结合欧式距离和线段方向度量线段的相似性；然后利用扩展的K-means算法对线段进行聚类。在最终结果中，同一条轨迹的线段可能分别属于多个聚类。\n\n\n算法流程\n轨迹分解为线段计算线段方向\n计算所有线段包含的方向数（）并设k-means聚类初始值为\n基于线段相似性距离进行k-means聚类\n评价聚类结果（Silhouette Coefficient）\n\n\n\n\n基于DBSCAN的轨迹聚类算法：CTHD（Clustering of Trajectories based on Hausdorff Distance）\nDBSCAN简介\n介绍\nDBSCAN（Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法）是一种基于密度的空间聚类算法。\n该算法将具有足够密度的区域划分为簇，并在具有噪声的空间数据库中发现任意形状的簇，它将簇定义为密度相连的点的最大集合。\n该算法利用基于密度的聚类算法，即要求聚类空间中的一定区域内所包含对象（点或其他空间对象）的数目不小于某一给定阈值。\n\n\n基本概念\n邻域：给定对象半径内的区域。\n参数：邻域中样本个数最小阈值。\n核心对象：邻域内的样本点数大于等于的对象。\n直接密度可达：给定一个对象集合，如果在的邻域内，且是一个核心对象，则对象从对象出发是直接密度可达的。\n密度可达：对于样本集合，如果存在一个对象链，记，对于所有，是从关于和直接密度可达，则对象是从对象关于和密度可达的。\n密度相连：如果存在对象，使对象和都是从关于和密度可达的，那么对象到是关于和密度相连的。\n\n\n聚类过程\n扫描整个数据集，找到任意一个核心点，对该核心点进行扩充。扩充的方法是寻找从该核心点出发的所有密度相连的数据点（注意是密度相连）。\n遍历该核心点的邻域内的所有核心点（因为边界点是无法扩充的），寻找与这些数据点密度相连的点，直到没有可以扩充的数据点为止。\n最后聚类成的簇的边界节点都是非核心数据点\n之后就是重新扫描数据集（不包括之前寻找到的簇中的任何数据点），寻找没有被聚类的核心点，再重复上面的步骤，对该核心点进行扩充直到数据集中没有新的核心点为止。数据集中没有包含在任何簇中的数据点就构成异常点。\n\n\n优点\n聚类速度快。\n能够有效处理噪声点。\n能发现任意形状的空间聚类，聚类簇的形状没有偏倚。\n与k-means比较起来，不需要事先指定聚类的数目。\n\n\n缺点\n由于DBSCAN直接对整个数据库进行操作且进行聚类时使用了一个全局性的表征密度的参数，因此当数据量增大时，要求较大内存支持I/O消耗也很大；同时，当空间聚类的密度不均匀、聚类间距差相差很大时，聚类质量较差。\n\n\n\n\n算法概述\n将轨迹以流向量的形式表达，并分割为一系列子轨迹，利用豪斯多夫距离计算轨迹间的相似性，最后采用DBSCAN密度聚类方法实现轨迹聚类。\n\n\n研究关键\n文中的轨迹采用流向量的方式表达，流向量既有位置又有方向，因此可以区分不同方向上的运动轨迹。\n\n\n\n\n基于OPTICS算法的轨迹聚类算法：TF-OPTICS（Time-Focused OPTICS）\nOPTICS简介\n介绍\nOPTICS（Odering Points To Identify the Clustering Structure）可视作DBSCAN算法的一种改进算法，与DBSCAN算法相比，OPTICS算法的改进主要在对输入参数不敏感。\nOPTICS算法不显式地生成数据聚类，它并不显示地生成数据聚类，而是为聚类分析生成一个增广的簇排序。这个排序代表了各样本点基于密度的聚类结果，如以可达距离为纵轴，样本点输出次序为横轴的坐标轴，包含的信息等价于从一个广泛的参数设置所获得的基于密度的聚类。\n\n\n基本概念\n由于OPTICS算法是对DBSCAN算法的一种改进，因此两者的许多概念是共用的。此外，OPTICS还引入了两个额外的概念：核心距离和可达距离。\n核心距离：一个对象的核心距离是使其成为核心对象最小半径，如果不是核心点，其核心距离没有定义。\n可达距离：是根据核心距离来定义的，对象到对象的可达距离是指的核心距离和与之间欧几里得距离之间的较大值。如果不是核心对象，和之间的可达距离没有意义。\n\n\n算法流程\n记是原始的点的数据集合；为最后输出结果的点集的有序序列；是一个无重复元素的队列，保存了当前已找到但是还没处理过的属于同一类别的点的集合。\n首先遍历输入的点集，找到一个核心点，如果找不到，则直接结束算法。\n如果找到一个点为核心点，则计算的核心距离以及可达距离并将其加入输出序列，将其所有邻点加入队列。\n从队列中找出可达距离最小的点，将其加入输出序列，如果也是核心点，则将的所有邻点加入到并且更新队列。\n重复以上步骤直到处理完所有的点。\n\n\n算法结果\n给定半径、最少点数和结果队列。\n从中按顺序取出点，如果该点的可达距离不大于给定半径，则该点属于当前类别，否则进行下一步。\n如果该点核心距离大于给定半径，则该点为噪声，可以忽略，否则该点属于新的聚类，跳至上一步。\n当结果队列遍历结束，算法结束。\n\n\n\n\n算法概述\n该算法首先采用改进的欧式距离计算轨迹相似性，然后探测轨迹上模式挖掘的有效时间区间，最后对轨迹进行OPTICS聚类，从而实现轨迹的时空聚类。\n\n\n算法流程\n轨迹线性插值\n轨迹相似性计算\n时间窗口选取\nOPTICS轨迹聚类\n聚类效果评价\n迭代优化（回到“时间窗口选取”）\n\n\n\n\n基于先划分再聚合思路的轨迹聚类算法：TRACLUS\n算法概述\nTRACLUS（TRAjectory CLUStering）算法由Lee等人在2007年提出的，它采用的是先划分再聚合的思路（Partition-and-group Framework），首先将时空轨迹看作一组点序列，然后按照最小描述长度MDL（Minimum Description Length）原则将轨迹划分为一些子轨迹，再用基于密度的聚类方法对这些子轨迹聚类，最终可以得到子轨迹的运动模式和整条轨迹的相似子区间。\n\n\n计算流程\n子轨迹间的距离度量\n轨迹分段\n线段聚类\n\n\n优缺点\n虽然子轨迹聚类方法能发现具有相似性的单个最大时间区间，但是由于该方法预先将轨迹划分成子轨迹，并以子轨迹为基本单位进行聚类，因此相似时间区间会受到子轨迹时间区间的限制，具有一定的局限性。\n\n\n\n\n\n\n\n\n\n空间聚类\n聚类的分类\n空间聚类的分类\n层次聚类（Hierarchical Cluster）\n划分聚类（Partitioning Cluster）\n密度聚类（Density-based Cluster）\n\n\nR型及Q型层次聚类\n相似性度量\n距离系数\n\n：空间维度\n：第个点在第维上的坐标\n：第个点和第个点之间的距离\n\n\n相关系数\n\n：样本数\n：第个样本的第个属性\n：第个样本各属性的均值\n：第个属性和第个属性之间的相关系数\n\n\n夹角余弦\n\n：空间维度\n：第个向量在第维上的坐标\n：第个向量和第个向量之间的夹角余弦（可理解为相似程度）\n\n\n\n\n层次聚类分析流程\n输入：空间数据\n空间相似性度量\n相似性度量矩阵\n依次选取较大的相似性度量\n绘制聚类谱系图\n选择分解阈值确定聚类结果\n\n\n层次聚类特点\n呈树型的层次结构\n需要计算相似性度量矩阵\n聚类过程是从底部向上\n需要人为确定划分阈值\n\n\n\n\n划分聚类\n定义\n给定一个大小为的数据集，将其分为类，使类内具有较高的相似度，而类间的相似度较低。\n\n\n划分聚类的算法流程\n确定聚类数目\n选取个点作为初始聚类中心\n计算各样本点到各聚类中心的距离\n根据距聚类中心的距离划分样本点的归属\n重新计算各类别的中心（转入第三步）\n直到聚类中心坐标不再发生变化为止\n\n\n优缺点\n直观、易实现且占用内存少。\n类别数目以及初始类中心的选择具有较强的主观性，需要借助先验知识。\n适合凸集数据，无法处理形状复杂的数据。\n\n\n\n\n划分聚类的改进算法\n引入组内变量平均标准差上限作为类别是否分裂的标准\n\n：类别遍历变量\n：样本数\n：变量数或维数\n：变量均值\n\n\n引入类间距离下限作为类别是否合并的标准\n\n：类别遍历变量\n：样本数\n：变量数或维数\n：变量均值\n：第个类别中变量的均方差\n\n\n\n\nFuzzy C-Means\n概念\nFCM算法是C-Means算法的改进，两者之间的差别在于，C-Means算法对于数据的划分是硬性的，而FCM则是一种柔性的模糊划分。\n\n\n算法流程\n确定聚类数目\n选取个点作为初始聚类中心\n进行如下迭代直到不发生变化为止\n\n\n\n\n\n\n\n\n\n密度聚类方法DBSCAN\n基本概念\n邻域：给定点半径内的区域\n核心点（对象）：邻域内包含给点最少数目个点的点\n直接密度可达：从核心对象出发到其邻域内的点均为直接密度可达的\n密度相连：从核心对象出发的直接密度可达的两对象是密度相连的\n小结\n直接密度可达比密度相连的要求严格，它要求起点必须是核心对象。\n直接密度可达是不对称的操作，只有核心对象之间的才可形成相互密度可达；而密度相连则是一个对称的操作。\n\n\n\n\n算法描述\n基于密度的聚类方法是寻找这样的簇，即该簇是基于密度可达性性的最大密度相连对象的集合，而不被任何簇所包含的对象被认为是噪声。\n\n\n算法流程\n输入：空间数据\n寻找邻域中的点数大于的对象建立一个新簇（将该点标记）\n反复寻找从该核心对象直接密度可达的对象并将点进行标记\n寻找未有标记的新对象\n是：结束\n否：返回第一步\n\n\n\n\n\n\n密度极值点的可视化\n横轴\n\n：点总数\n：截断距离（认定两点邻近的距离阈值）\n：第个点与第个点之间的距离\n\n：与第个点邻近的点的数量\n\n\n纵轴\n\n：第个点与第个点之间的距离\n\n\n\n\n\n\n\n空间插值\n地统计预备知识\n基本概念\n随机变量和随机向量\n离散随机变量：骰子、足球比赛的胜负……\n连续随机变量：等电话、公共汽车的时间……\n随机向量：多个随机变量的组合\n\n\n分布函数和分布密度函数\n分布函数\n\n定义域：\n\n\n\n\n密度函数：单位概率\n\n\n\n\n\n数学期望和方差\n数学期望（一阶原点矩）：随机变量取值平均的大小\n离散型：\n连续型：\n\n\n方差（二阶中心矩）：反映随机变量取值的变化\n离散型：\n连续型：\n\n\n\n\n几个和“随机”有关的概念\n随机函数\n记一个样本空间为，对于每个样本，都有一个函数与之对应，其中，则称该函数为定义在上的随机函数。\n\n\n随机过程和随机场\n每个确定性的函数，如都是随机函数的一个实现，随机函数可以理解为它所有现实的集合。\n指与时间有关的随机函数，随机函数依赖于空间坐标则称该随机函数为随机场。\n\n\n区域化变量\n以空间点的直角坐标系为自变量的随机场称为一个区域化变量。\n\n\n\n\n协方差（两随机变量的二阶混合中心矩）\n\n\n\n\n\n相关与空间相关\n相关性\n分类\n正相关\n负相关\n\n\n度量\n协方差\n相关系数\n\n\n\n\n空间自相关\n地理学第一定律\n任何事物都相关，只是相近的事物关联更紧密。\n\n\n协方差函数\n协方差函数指随机场中，空间两点和处两个随机变量和的二阶混合中心矩，称为自协方差函数或简称协方差函数，记为。\n该函数的取值随的递增而递减。\n\n\n\n\n平稳假设\n平稳假设\n区域化变量的任意维分布函数不因空间点发生位移而改变。形式化表达如下：\n\n这就要求随机函数的各阶矩都存在，且平稳。在实际中通常采用二阶平稳假设，即要求区域化变量的一、二阶矩存在并平稳。\n平稳的内涵\n为什么要平稳？\n随机场性质的统计\n\n\n什么是平稳？\n与具体位置无关\n质量（平稳）、货币（不平稳）\n\n\n\n\n\n\n二阶平稳假设\n要求\n数学期望存在且平稳：（为常数）\n协方差函数存在且平稳：\n\n\n示例\n平稳的随机场：海水面\n不平稳的随机场：DEM\n局部平稳假设：在局部的范围内平稳\n\n\n\n\n\n\n\n\n\n\n变差函数和结构分析\n地统计的研究内容、历史\n地统计的研究内容\n地统计是真正从地学发展起来的一门学科。\nGIS是真正从地学中发展起来的技术。\n利用空间随机变量之间的空间相关性来研究空间随机场的统计特征。\n地统计的基础就是空间邻近原理。\n具体的内容可以分为结构分析理论（变差函数）、克立格估值理论（Kriging方法）和条件模拟理论（蒙特卡罗方法）。\n\n\n地统计的研究历史\n南非的采矿工程师D G Krige\n巴黎枫丹白露地质统计学和数学形态学研究中心G Matheron\n斯坦福大学 A G Journel\n\n\n\n\n变差函数的概念\n定义\n区域化变量和两点之差的方差之半定义为的变差函数。\n\n\n公式\n\n\n\n与协方差函数的关系\n\n\n\n\n\n实验变差函数的计算\n公式\n\n：距离为时样本点对的数量\n\n\n例子\\begin{array}{|c|c|c|}\\hline2&1&2\\\\\\hline4&3&3\\\\\\hline3&4&5\\\\\\hline\\end{array}\n东西\n南北\n西北东南\n\n\n\n\n变差函数的类型\n分类\n连续型：\n过渡型：\n随机型：\n\n\n模型\n球状模型：\n指数模型：\n高斯模型：\n\n\n模型中的参数\n：块金常数\n：变程\n：拱高\n\n\n\n\n实验变差函数的拟合与套和\n拟合方法\n加权最小二乘法\n线性规划方法\n遗传算法\n交互式拟合方法\n\n\n变差函数的套和\n实际的地学空间随机场的变化性是十分复杂的，往往包含着各种尺度上的多层次性，反映在变差函数上就是它的结构不是单纯的一种结构，而是多层次结构叠加在一起称为套和结构。\n\n\n\n\n实验变差函数的应用\n变差函数和空间随机场的对应关系（噪声，相关程度，相关范围）\n空间场的各向异性\n空间场的尺度特征\n空间场的周期性特征\n\n\n\n\n\n","categories":["学科笔记"]}]